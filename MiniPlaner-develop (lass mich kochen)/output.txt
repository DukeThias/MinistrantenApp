===== ./src/view/MainFrame.cpp =====
/* 
 * File:   MainFrame.cpp
 * Author: Yannik
 * 
 * Created on August 11, 2015, 4:00 PM
 */

#include "MainFrame.h"
#include <wx/textfile.h>
#include <wx/dir.h>
#include <wx/tokenzr.h>
#include <wx/display.h>
#include <wx/settings.h>
#include <wx/filename.h>
#include <wx/mimetype.h>
#include <wx/intl.h>
#include "../R.h"
#include "../file/DataFileHandler.h"
#include "../img/minis.xpm"
#include "AboutPanel.h"

MainFrame::MainFrame(App* _app)
: wxFrame((wxFrame*) NULL, R::ID_ANY, R::MINI_PLANER, wxDefaultPosition, wxDefaultSize, wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxRESIZE_BORDER | wxSYSTEM_MENU | wxCAPTION | wxCLOSE_BOX) {
	app = _app;
	wxFrame::SetIcon(wxICON(minis));
	wxDisplay display;
	wxRect screen = display.GetGeometry();
	wxFrame::SetSize(0, 0, screen.GetWidth() * 3 / 4, screen.GetHeight() * 3 / 4);

	wxPanel* pl_bg = new wxPanel(this, R::ID_ANY);

	wxBoxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);

	pl_tabs = new wxPanel(pl_bg, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxBORDER_NONE | wxTAB_TRAVERSAL);
	wxBoxSizer* sizer_tabs = new wxBoxSizer(wxVERTICAL);

	wxString list_names[9] = {R::DIENSTE, R::MINIS, R::MGRUPPEN, R::TERMINE, R::TGRUPPEN, R::FEHLZEITEN, R::PLAENE, R::HILFE, R::UEBER};
	list_tabs.reserve(9);
	for (int i = 0; i < 9; i++) {
		wxPanel* pl = new wxPanel(pl_tabs, 1000 + i);
		wxBoxSizer* sz = new wxBoxSizer(wxHORIZONTAL);
		wxStaticText* st = new wxStaticText(pl, 1000 + i, list_names[i]);
		sz->Add(st, 1, wxEXPAND | wxLEFT | wxRIGHT, 8);
		wxBoxSizer* sz2 = new wxBoxSizer(wxHORIZONTAL);
		sz2->Add(sz, 1, wxEXPAND | wxTOP | wxBOTTOM, 2);
		pl->SetSizer(sz2);
		if (i == 7) sizer_tabs->Add(new wxPanel(pl_tabs, R::ID_ANY), 1, wxEXPAND, 0);
		sizer_tabs->Add(pl, 0, wxEXPAND | wxALL, 0);

		pl->Bind(wxEVT_LEFT_DOWN, &MainFrame::onLBSel, this);
		st->Bind(wxEVT_LEFT_DOWN, &MainFrame::onLBSel, this);
		pl->Bind(wxEVT_RIGHT_DOWN, &MainFrame::onLBSel, this);
		st->Bind(wxEVT_RIGHT_DOWN, &MainFrame::onLBSel, this);
		list_tabs.push_back(std::make_pair(pl, st));
	}
	pl_tabs->SetSizerAndFit(sizer_tabs);

	sizer->Add(pl_tabs, 0, wxEXPAND | wxALL, 0);
	sizer->AddSpacer(5);

	dienste_panel = new DienstePanel(pl_bg, app);
	minis_panel = new MinisPanel(pl_bg, app);
	m_gruppen_panel = new MGruppenPanel(pl_bg, app);
	termine_panel = new TerminePanel(pl_bg, app);
	t_gruppen_panel = new TGruppenPanel(pl_bg, app);
	fehlzeiten_panel = new FehlzeitenPanel(pl_bg, app);
	plaene_panel = new PlaenePanel(pl_bg, app);
	about_panel = new AboutPanel(pl_bg);

	sizer_r = new wxBoxSizer(wxVERTICAL);

	sizer_r->Add(dienste_panel, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(minis_panel, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(m_gruppen_panel, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(termine_panel, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(t_gruppen_panel, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(fehlzeiten_panel, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(plaene_panel, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(about_panel, 1, wxEXPAND | wxALL, 0);

	list_pls.reserve(8);
	list_pls.push_back(dienste_panel);
	list_pls.push_back(minis_panel);
	list_pls.push_back(m_gruppen_panel);
	list_pls.push_back(termine_panel);
	list_pls.push_back(t_gruppen_panel);
	list_pls.push_back(fehlzeiten_panel);
	list_pls.push_back(plaene_panel);
	list_pls.push_back(about_panel);

	handleLBSel(1); //init with minis
	sizer->Add(sizer_r, 1, wxEXPAND | wxALL, 0);

	pl_bg->SetSizer(sizer);
	loadGUISettings();

	wxFrame::Show(true);
}

void MainFrame::OnClose(wxCloseEvent&) {
	saveGUISettings();
	Destroy();
}

void MainFrame::loadGUISettings() {
	wxString line = R::window_size;
	if (!line.IsEmpty()) {
		wxStringTokenizer zr(line, DataFileHandler::D, wxTOKEN_RET_EMPTY_ALL);
		wxString s1 = zr.NextToken();
		if (s1.Cmp(wxT("FULLSCREEN")) == 0) {
			this->Maximize(true);
		} else {
			int x = wxAtoi(s1);
			int y = wxAtoi(zr.NextToken());
			int width = wxAtoi(zr.NextToken());
			int height = wxAtoi(zr.NextToken());
			this->SetSize(x, y, width, height);
		}
	}
}

void MainFrame::saveGUISettings() {
	wxPoint point = this->GetPosition();
	wxSize size = this->GetSize();
	wxString line;
	if (this->IsMaximized()) {
		line = wxT("FULLSCREEN");
	} else {
		line = wxString::Format(wxT("%i"), point.x) + DataFileHandler::D
				+ wxString::Format(wxT("%i"), point.y) + DataFileHandler::D
				+ wxString::Format(wxT("%i"), size.GetWidth()) + DataFileHandler::D
				+ wxString::Format(wxT("%i"), size.GetHeight());
	}
	R::window_size = line;
}

void MainFrame::notifyDienste(int index) {
	dienste_panel->notifyDienste(index);
}

void MainFrame::notifyMinis(int index) {
	minis_panel->notifyMinis(index);
}

void MainFrame::notifyEinzeltermine(int index) {
	termine_panel->notifyEinzeltermine(index);
}

void MainFrame::notifySerientermine(int index) {
	termine_panel->notifySerientermine(index);
}

void MainFrame::notifyMGruppen(int index) {
	m_gruppen_panel->notifyMGruppen(index);
}

void MainFrame::notifyTGruppen(int index) {
	t_gruppen_panel->notifyTGruppen(index);
}

void MainFrame::notifyFehlzeiten(int index) {
	fehlzeiten_panel->notifyFehlzeiten(index);
}

void MainFrame::notifyPlaene(int index) {
	plaene_panel->notifyPlaene(index);
}

BEGIN_EVENT_TABLE(MainFrame, wxFrame)
EVT_CLOSE(MainFrame::OnClose)
END_EVENT_TABLE()

void MainFrame::onLBSel(wxMouseEvent& evt) {
	wxWindow* wnd = (wxWindow*) evt.GetEventObject();
	for (int i = 0; i < 9; i++) {
		if (wnd == (wxWindow*) list_tabs.at(i).first || wnd == (wxWindow*) list_tabs.at(i).second) {
			handleLBSel(i);
			return;
		}
	}
}

void MainFrame::handleLBSel(int index) {
	if (index == 7) {
		wxFileType* filetype = wxTheMimeTypesManager->GetFileTypeFromExtension(wxString("pdf"));
		if (filetype == NULL) {
			wxMessageDialog dialog(this, R::MSG_MANUAL_NOT_OPENED, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			wxString cmd = filetype->GetOpenCommand(wxT("help/Handbuch.pdf"));
			wxExecute(cmd);
			delete filetype;
		}
		return;
	}
	if (index == sel) return;
	for (int i = 0; i < 9; i++) {
		if (i == 7) continue;
		bool isSel = (i == index);
		list_pls.at(i == 8 ? 7 : i)->Show(isSel);
		if (isSel) {
			list_tabs.at(i).first->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHT));
			list_tabs.at(i).second->SetForegroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT));
		} else {
			list_tabs.at(i).first->SetBackgroundColour(wxNullColour);
			list_tabs.at(i).second->SetForegroundColour(wxNullColour);
		}
		list_tabs.at(i).first->Refresh();
	}
	sizer_r->Layout();
	sel = index;
}

===== ./src/view/MainFrame.h =====
/* 
 * File:   MainFrame.h
 * Author: Yannik
 *
 * Created on August 11, 2015, 4:00 PM
 */

#ifndef MAINFRAME_H
#define	MAINFRAME_H

#include <wx/wx.h>
#include <vector>
#include "../view-data/DienstePanel.h"
#include "../view-data/MinisPanel.h"
#include "../view-data/TerminePanel.h"
#include "../view-data/MGruppenPanel.h"
#include "../view-data/TGruppenPanel.h"
#include "../view-data/FehlzeitenPanel.h"
#include "../view-plan/PlaenePanel.h"
#include "AboutPanel.h"
class App;

class MainFrame : public wxFrame {
public:
	MainFrame(App* _app);
	void notifyDienste(int index = -1);
	void notifyMinis(int index = -1);
	void notifyEinzeltermine(int index = -1);
	void notifySerientermine(int index = -1);
	void notifyMGruppen(int index = -1);
	void notifyTGruppen(int index = -1);
	void notifyFehlzeiten(int index = -1);
	void notifyPlaene(int index = -1);
private:
	void loadGUISettings();
	void saveGUISettings();
	virtual void OnClose(wxCloseEvent&);
	
	wxBoxSizer* sizer_r;
	wxPanel* pl_tabs;
	std::vector<std::pair<wxPanel*, wxStaticText*> > list_tabs;
	std::vector<wxPanel*> list_pls;
	int sel;
	
	App* app;
	DienstePanel* dienste_panel;
	MinisPanel* minis_panel;
	TerminePanel* termine_panel;
	MGruppenPanel* m_gruppen_panel;
	TGruppenPanel* t_gruppen_panel;
	FehlzeitenPanel* fehlzeiten_panel;
	PlaenePanel* plaene_panel;
	AboutPanel* about_panel;
	DECLARE_EVENT_TABLE();
	void onLBSel(wxMouseEvent& evt);
	void handleLBSel(int index);
};

#endif	/* MAINFRAME_H */

===== ./src/view/AboutPanel.h =====
/* 
 * File:   AboutPanel.h
 * Author: Yannik
 *
 * Created on October 4, 2015, 11:10 PM
 */

#ifndef ABOUTPANEL_H
#define	ABOUTPANEL_H

#include <wx/wx.h>

class AboutPanel : public wxPanel {
public:
	AboutPanel(wxWindow* parent);
private:

};

#endif	/* ABOUTPANEL_H */



===== ./src/view/AboutPanel.cpp =====
/* 
 * File:   AboutPanel.cpp
 * Author: Yannik
 * 
 * Created on October 4, 2015, 11:10 PM
 */

#include "AboutPanel.h"
#include <wx/generic/statbmpg.h>
#include <wx/hyperlink.h>
#include <wx/stdpaths.h>
#include <wx/filename.h>
#include <wx/image.h>
#include <config.h>
#include "../img/minis.xpm"
#include "../R.h"
#include "../Util.h"

AboutPanel::AboutPanel(wxWindow* parent)
: wxPanel(parent, R::ID_ANY) {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxBoxSizer* sizer_1 = new wxBoxSizer(wxHORIZONTAL);
#ifdef __WINDOWS__
	// Load from a resource with explicit width and height
	wxIcon icon(wxT("minis"), wxICON_DEFAULT_TYPE, 64, 64);
#else
	wxIcon icon = wxICON(minis);
#endif
	wxBitmap bitmap;
	bitmap.CopyFromIcon(icon);
	wxStaticBitmap* sb_icon = new wxStaticBitmap(this, R::ID_ANY, bitmap);
	sizer_1->Add(sb_icon, 0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
	wxBoxSizer* sizer_1_r = new wxBoxSizer(wxVERTICAL);
	wxStaticText* st_name = new wxStaticText(this, R::ID_ANY, wxT(NAME_STR " " VERSION_STR));
	st_name->SetFont(st_name->GetFont().Bold());
	sizer_1_r->Add(st_name, 0, wxALL, 1);
	wxStaticText* st_desc = new wxStaticText(this, R::ID_ANY, R::HEADLINE);
	sizer_1_r->Add(st_desc, 0, wxALL, 1);
	sizer_1_r->Add(new wxStaticText(this, R::ID_ANY, wxT(COPYRIGHT_STR)), 0, wxALL, 1);
	sizer_1->Add(sizer_1_r, 0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
	sizer->Add(sizer_1, 0, wxEXPAND | wxALL, 10);

	wxFlexGridSizer* sizer_2 = new wxFlexGridSizer(10, 2, 0, 0);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, R::AUTOR), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT(AUTHOR_STR)), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT("E-Mail: ")), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT("yannik.schaelte@gmail.com")), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT("Homepage: ")), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT("https://yannikschaelte.github.io/MiniPlaner/")), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, R::BEITRAGENDE), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT("Yannik Schälte, Martin Kröning")), 0, wxALL, 2);
	sizer_2->AddSpacer(10);
	sizer_2->AddSpacer(10);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, R::KOMPILIERTMIT), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT(COMPILER_STR)), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, R::BIBLIOTHEKEN), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, wxT(WX_DEP_STR)), 0, wxALL, 2);
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, R::INSTALLATIONSVERZEICHNIS), 0, wxALL, 2);
	wxFileName file(wxStandardPaths::Get().GetExecutablePath());
	sizer_2->Add(new wxStaticText(this, R::ID_ANY, file.GetPath()), 0, wxALL, 2);
	sizer_2->AddGrowableCol(1, 1);
	sizer->Add(sizer_2, 0, wxEXPAND | wxALL, 10);

	sizer->AddSpacer(40);
	sizer->Add(new wxStaticText(this, R::ID_ANY, R::KONTAKT_MSG), 0, wxALL, 10);

	SetSizer(sizer);
}

===== ./src/update/UpdateChecker.cpp =====
/* 
 * File:   UpdateChecker.cpp
 * Author: Yannik
 * 
 * Created on October 12, 2015, 12:23 PM
 */

#include "UpdateChecker.h"
#include <wx/utils.h>
#include <wx/sstream.h>
#include <config.h>
#include "../R.h"

void UpdateChecker::checkUpdate(wxWindow* parent) {
	wxURL url(wxT("https://raw.githubusercontent.com/yannikschaelte/MiniPlaner/master/version.dat"));
	if (url.GetError() == wxURL_NOERR) {
		wxString htmlData;
		wxInputStream* in = url.GetInputStream();
		if (in && in->IsOk()) {
			wxStringOutputStream html_stream(&htmlData);
			in->Read(html_stream);
			if (!htmlData.IsSameAs(wxT(VERSION_STR))) {
				UpdateDialog dialog(parent);
				dialog.ShowModal();
			}
		}
		delete in;
	}
}

UpdateChecker::UpdateDialog::UpdateDialog(wxWindow* parent)
: wxDialog(parent, R::ID_ANY, wxT("Update-Information"), wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	wxStaticText* st_msg = new wxStaticText(this, R::ID_ANY, wxT("Es ist eine neuere Version des Programms verfügbar."));
	sizer->Add(st_msg, 1, wxEXPAND | wxALL, 10);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_download = new wxButton(this, R::ID_BT_COMPUTE, wxT("Zum Download"));
	btsizer->Add(bt_download);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
}

BEGIN_EVENT_TABLE(UpdateChecker::UpdateDialog, wxDialog)
EVT_BUTTON(R::ID_BT_COMPUTE, UpdateDialog::onBtDownload)
EVT_BUTTON(R::ID_BT_OK, UpdateDialog::onBtOk)
END_EVENT_TABLE()


void UpdateChecker::UpdateDialog::onBtDownload(wxCommandEvent&) {
	wxLaunchDefaultBrowser(wxT("https://yannikschaelte.github.io/MiniPlaner/"));
}

void UpdateChecker::UpdateDialog::onBtOk(wxCommandEvent&) {
	Close(true);
}

===== ./src/update/UpdateChecker.h =====
/* 
 * File:   UpdateChecker.h
 * Author: Yannik
 *
 * Created on October 12, 2015, 12:22 PM
 */

#ifndef UPDATECHECKER_H
#define	UPDATECHECKER_H

#include <wx/wx.h>
#include <wx/url.h>

namespace UpdateChecker {
	void checkUpdate(wxWindow* parent);
	
	class UpdateDialog : public wxDialog {
	public:
		UpdateDialog(wxWindow* parent);
	private:
		wxButton* bt_download;
		wxButton* bt_ok;
		DECLARE_EVENT_TABLE();
		void onBtOk(wxCommandEvent&);
		void onBtDownload(wxCommandEvent&);
	};
}

#endif	/* UPDATECHECKER_H */



===== ./src/controller-plan/PlanerController.h =====
/* 
 * File:   PlanerController.h
 * Author: Yannik
 *
 * Created on September 11, 2015, 2:52 PM
 */

#ifndef PLANERCONTROLLER_H
#define	PLANERCONTROLLER_H

#include "../model-plan/Planer.h"
#include "../view-plan/PlanPlanerDialog.h"
#include "../model-plan/CTermin.h"

class PlanerController {
public:
	PlanerController(Planer* _planer, PlanPlanerDialog* _view);
	~PlanerController();
	Planer* planer;

	bool edt = false;
	int simpleCheckCanCreatePlan();
	void computePlan(bool* continueComputation);
	void onClear();
	void onEntryChanged(PTermin* termin, int dienst, int mini_old_i, PMessdiener* mini_new);
	void onSave();
	void onUndo();
	void onRedo();
	void onEdtTermin(int index);
	void onDelTermin(int index);
	
	static void recalculateAvailableListsInTGruppe(PTermin* termin);
private:

	class PositionInfo {
	public:
		CTermin* termin;
		int dienst;
		int diff; //avai - needed = avai - (req - has)

		PositionInfo(CTermin* _termin, int _dienst, int _diff);
	};

	PlanPlanerDialog* view;
	//deep-copy lists, used internally
	std::vector<CTermin*> tmp_list_termin;
	std::vector<PMessdiener*> tmp_list_mini;
	std::vector<PMGruppe*> tmp_list_mgruppe;
	std::vector<PFehlzeit*> tmp_list_fehlzeit;

	//for undo-redo
	std::vector<std::vector<std::vector<PMessdiener*> > >history_list;
	std::vector<std::vector<std::vector<PMessdiener*> > >future_list;

	void computePlanMinimumSearch(bool* continueComputation);
	void computePlanChronologically(bool* continueComputation);

	void prepareMiniNumsFehlzeiten();
	void prepareMiniNumsFehlzeitenAfter(wxDateTime termin_datum);
	void addProbableMiniNum(PFehlzeit* fehlzeit);

	PositionInfo findMinimumTerminDienst();
	bool fillDienst(CTermin* termin, int dienst);
	void findMinimumMiniNum(std::unordered_set<PMessdiener*>* list_avai, std::unordered_set<PMessdiener*>* list_minimum);

	void eraseSurroundings(CTermin* termin, Dienst* dienst, std::unordered_set<PMessdiener*>* list_minimum);
	void addAllMinis(CTermin* termin, std::unordered_set<PMessdiener*>* list_gesamt, Dienst* dienst, std::unordered_set<PMessdiener*>* list_dienst);

	void prepareMGruppenHard();
	void handleMGruppen(CTermin* termin, int dienst, PMessdiener* mini);
	void handleMGruppenHard(CTermin* termin);
	bool insertMGruppeHard(CTermin* termin, std::vector<PMessdiener*> list, bool keep);

	void handleTGruppen(CTermin* termin, PMessdiener* mini);
	void handleTGruppenP(PTermin* termin, PMessdiener* mini);
	void handleTGruppenWithdrawP(PTermin* termin, PMessdiener* mini);
	void eraseFromAvailableList(CTermin* t, PMessdiener* m);
	void eraseFromAvailableListP(PTermin* t, PMessdiener* m);
	void addToAvailableListIfPossibleP(PTermin* t, PMessdiener* m);

	void initTmpLists();
	void deleteTmpLists();
	void fillRealLists();

	/**
	 * Calculate correct mini.nums from occurrences in mini_lists
	 */
	void putCorrectMiniNums();
	
	/**
	 * Adapt history / future lists.
	 */
	void handleDataChange();
	std::vector<std::vector<PMessdiener*> > copyMinisToList();
	void copyMinisFromList(std::vector<std::vector<PMessdiener*> >* list);
};

#endif	/* PLANERCONTROLLER_H */

===== ./src/controller-plan/PlanerController.cpp =====
/* 
 * File:   PlanerController.cpp
 * Author: Yannik
 * 
 * Created on September 11, 2015, 2:52 PM
 */

#include "PlanerController.h"
#include <cstdlib>
#include <algorithm>
#include "../view-plan/PlanPlanerDialog.h"
#include "../file/PlanFileHandler.h"
#include "../Util.h"
#include "../view-plan/PTerminDialog.h"

PlanerController::PlanerController(Planer* _planer, PlanPlanerDialog* _view) {
	planer = _planer;
	view = _view;
}

PlanerController::~PlanerController() {
	delete planer;
}

//0: can create
//1: impossible
//2: full

int PlanerController::simpleCheckCanCreatePlan() {
	initTmpLists();
	prepareMGruppenHard();
	//check 1: overall needed minis
	int num_termine = tmp_list_termin.size();
	int num_minis = tmp_list_mini.size();
	for (int i = 0; i < num_termine; i++) {
		CTermin* termin = tmp_list_termin.at(i);
		if (termin->prev != NULL) continue;
		int num = 0;
		do {
			for (std::vector<std::pair<Dienst*, int> >::iterator iter_d = termin->list_dienst_req.begin();
					iter_d != termin->list_dienst_req.end(); iter_d++) {
				num += iter_d->second;
			}
			termin = termin->next;
		} while (termin != NULL);
		if (num > num_minis) {
			deleteTmpLists();
			return 1;
		}
	}
	//check 2: needed minis in single lists
	PositionInfo info = findMinimumTerminDienst();
	if (info.diff < 0) {
		deleteTmpLists();
		return 1;
	}
	if (info.termin == NULL) {
		deleteTmpLists();
		return 2;
	}
	return 0;
}

//compute plan -----------------------------------------------------------------

void PlanerController::computePlan(bool* continueComputation) {
	if (planer->settings.modus_algorithmus == Planer::Settings::MODUS_ALGORITHMUS_MINIMUM)
		computePlanMinimumSearch(continueComputation);
	else
		computePlanChronologically(continueComputation);
}

//approach number 1

void PlanerController::computePlanMinimumSearch(bool* continueComputation) {
	bool foundSolution = false;
	while (!foundSolution && *continueComputation) {
		if (planer->settings.modus_fehlzeiten == Planer::Settings::MODUS_FEHLZEITEN_ANRECHNEN) prepareMiniNumsFehlzeiten();
		PositionInfo info = findMinimumTerminDienst();
		bool couldFill = true;
		while (info.termin != NULL && info.diff >= 0 && couldFill && *continueComputation) {
			couldFill = fillDienst(info.termin, info.dienst);
			if (couldFill) {
				info = findMinimumTerminDienst();
			}
		}
		if (info.termin == NULL) {//alle Positionen besetzt (couldFill = false => info.termin != NULL))
			foundSolution = true;
		} else {//some diff < 0
			initTmpLists();
			prepareMGruppenHard();
		}
	}
	if (*continueComputation) {
		if (planer->settings.modus_fehlzeiten == Planer::Settings::MODUS_FEHLZEITEN_ANRECHNEN) putCorrectMiniNums();
		history_list.push_back(copyMinisToList());
		future_list.clear();
		fillRealLists();
		edt = true;
	}
	deleteTmpLists();
}

//approach number 2

void PlanerController::computePlanChronologically(bool* continueComputation) {
	bool foundSolution = false;
	while (!foundSolution && *continueComputation) {
		bool couldFill = true;
		for (std::vector<CTermin*>::iterator iter_t = tmp_list_termin.begin(); iter_t != tmp_list_termin.end() && couldFill; iter_t++) {
			if (planer->settings.modus_fehlzeiten == Planer::Settings::MODUS_FEHLZEITEN_ANRECHNEN) prepareMiniNumsFehlzeitenAfter((**iter_t).datum);
			int num_dienste = (**iter_t).list_dienst_req.size();
			for (int i = 0; i < num_dienste && couldFill; i++) {
				couldFill = fillDienst(*iter_t, i);
			}
		}
		if (!couldFill) {
			initTmpLists();
			prepareMGruppenHard();
		} else {
			foundSolution = true;
		}
	}
	if (*continueComputation) {
		if (planer->settings.modus_fehlzeiten == Planer::Settings::MODUS_FEHLZEITEN_ANRECHNEN) putCorrectMiniNums();
		history_list.push_back(copyMinisToList());
		future_list.clear();
		fillRealLists();
		edt = true;
	}
	deleteTmpLists();
}

// for termin-minimum search ---------------------------------------------------

PlanerController::PositionInfo PlanerController::findMinimumTerminDienst() {
	PositionInfo info(NULL, 0, 0);
	for (std::vector<CTermin*>::iterator iter_t = tmp_list_termin.begin(); iter_t != tmp_list_termin.end(); iter_t++) {
		int num_dienste = (**iter_t).list_dienst_req.size();
		for (int i = 0; i < num_dienste; i++) {
			int req = (**iter_t).list_dienst_req.at(i).second;
			if (req > 0) {
				int diff = (**iter_t).list_dienst_minis_available.at(i).second.size() - req;
				if (info.termin == NULL || diff < info.diff) {
					info = PositionInfo(*iter_t, i, diff);
				}
			}
		}
	}
	return info;
}

// for fehlzeiten --------------------------------------------------------------

void PlanerController::prepareMiniNumsFehlzeiten() {
	for (std::vector<PFehlzeit*>::iterator iter_f = tmp_list_fehlzeit.begin(); iter_f != tmp_list_fehlzeit.end(); iter_f++) {
		addProbableMiniNum(*iter_f);
	}
}

void PlanerController::prepareMiniNumsFehlzeitenAfter(wxDateTime termin_datum) {
	for (std::vector<PFehlzeit*>::iterator iter_f = tmp_list_fehlzeit.begin(); iter_f != tmp_list_fehlzeit.end();) {
		if (!(**iter_f).datum_beginn.IsLaterThan(termin_datum)) {
			addProbableMiniNum(*iter_f);
			delete *iter_f;
			iter_f = tmp_list_fehlzeit.erase(iter_f);
		} else {
			iter_f++;
		}
	}
}

void PlanerController::addProbableMiniNum(PFehlzeit* fehlzeit) {
	PMessdiener* mini = fehlzeit->mini;
	float probEinsaetze = 0;
	//iterate termine and add to probEinsaetze whenever iter_f-->mini could be inserted according to its dienste
	std::vector<CTermin*>::iterator iter_t = tmp_list_termin.begin();
	while (iter_t != tmp_list_termin.end() && (**iter_t).datum.IsEarlierThan(fehlzeit->datum_beginn)) iter_t++;
	while (iter_t != tmp_list_termin.end() && !(**iter_t).datum.IsLaterThan(fehlzeit->datum_ende)) {
		int num_dienste = (**iter_t).list_dienst_req.size();
		for (int i = 0; i < num_dienste; i++) {
			if (std::find(mini->dienste.begin(), mini->dienste.end(), (**iter_t).list_dienst_req.at(i).first) != mini->dienste.end()) {//mini could possibly have been useful here
				probEinsaetze += ((float) (**iter_t).list_dienst_req.at(i).second) / ((float) ((**iter_t).list_dienst_minis_available.at(i).second.size() + 1));
			}
		}
		iter_t++;
	}
	mini->num += (int) probEinsaetze;
}

// fill a specific service -----------------------------------------------------

bool PlanerController::fillDienst(CTermin* termin, int dienst) {
	while (termin->list_dienst_req.at(dienst).second > 0) {
		//check if possible to continue
		if (termin->list_dienst_minis_available.at(dienst).second.size() == 0) {
			return false;
		}

		//get minimum list
		std::unordered_set<PMessdiener*> list_minimum;
		findMinimumMiniNum(&termin->list_dienst_minis_available.at(dienst).second, &list_minimum);
		//mind surroundings
		eraseSurroundings(termin, termin->list_dienst_minis.at(dienst).first, &list_minimum);

		//select a mini
		int index = std::rand() % list_minimum.size();
		PMessdiener* m;
		int i = 0;
		std::unordered_set<PMessdiener*>::iterator iter_m = list_minimum.begin();
		for (; i < index; i++) {
			iter_m++;
		}
		m = *iter_m;
		if (m->gruppe != NULL && m->gruppe->modus == MGruppe::NUR_GEM) {
			//might need to be inserted somewhere else
			insertMGruppeHard(termin, m->gruppe->list, true);
			//nums incremented, reqs decremented, missing:
			for (std::vector<PMessdiener*>::iterator iter_m = m->gruppe->list.begin(); iter_m != m->gruppe->list.end(); iter_m++) {
				handleTGruppen(termin, *iter_m);
			}
			//mgruppen.hard: no further checks needed
		} else {
			termin->list_dienst_minis.at(dienst).second.insert(m);
			termin->list_dienst_req.at(dienst).second--;
			m->num++;

			//erase m from lists
			handleTGruppen(termin, m);

			//insert mgruppe somewhere
			handleMGruppen(termin, dienst, m);
			//check whether some groups have become impossible to insert
			handleMGruppenHard(termin);
		}
	}
	return true;
}

void PlanerController::findMinimumMiniNum(std::unordered_set<PMessdiener*>* list_avai, std::unordered_set<PMessdiener*>* list_minimum) {
	int minimum = -1;
	for (std::unordered_set<PMessdiener*>::iterator iter = list_avai->begin(); iter != list_avai->end(); iter++) {
		if ((**iter).num < minimum || minimum == -1) {
			list_minimum->clear();
			list_minimum->insert(*iter);
			minimum = (**iter).num;
		} else if ((**iter).num == minimum) {
			list_minimum->insert(*iter);
		}
	}
}

void PlanerController::eraseSurroundings(CTermin* termin, Dienst* dienst, std::unordered_set<PMessdiener*>* list_minimum) {
	int random = rand() % 61;
	const int steps = 4;
	const int num_termine = tmp_list_termin.size();
	std::unordered_set<PMessdiener*> list_dienst[steps];
	std::unordered_set<PMessdiener*> list_gesamt[steps];
	for (int i = 0; i < steps; i++) {
		if (random < 61 - (i + 1)) {
			if (termin->_id > i)
				addAllMinis(tmp_list_termin.at(termin->_id - (i + 1)), &list_gesamt[i], dienst, &list_dienst[i]);
			if (termin->_id < num_termine - (i + 1))
				addAllMinis(tmp_list_termin.at(termin->_id + (i + 1)), &list_gesamt[i], dienst, &list_dienst[i]);
		}
		if (i < steps - 1) {
			list_gesamt[i + 1] = list_gesamt[i];
			list_dienst[i + 1] = list_dienst[i];
		}
	}

	std::unordered_set<PMessdiener*> list_minimum_tmp;
	for (int i = steps - 1; i >= 0; i--) {
		list_minimum_tmp = *list_minimum;
		for (std::unordered_set<PMessdiener*>::iterator iter_m = list_gesamt[i].begin(); iter_m != list_gesamt[i].end(); iter_m++) {
			list_minimum_tmp.erase(*iter_m);
		}
		if (list_minimum_tmp.size() > 0) *list_minimum = list_minimum_tmp;
		return;
	}
	for (int i = steps - 1; i >= 0; i--) {
		list_minimum_tmp = *list_minimum;
		for (std::unordered_set<PMessdiener*>::iterator iter_m = list_dienst[i].begin(); iter_m != list_dienst[i].end(); iter_m++) {
			list_minimum_tmp.erase(*iter_m);
		}
		if (list_minimum_tmp.size() > 0) *list_minimum = list_minimum_tmp;
		return;
	}
}

/**
 * Used by eraseSurroundings().
 * @param termin
 * @param list_gesamt
 * @param dienst
 * @param list_dienst
 */
void PlanerController::addAllMinis(CTermin* termin, std::unordered_set<PMessdiener*>* list_gesamt, Dienst* dienst, std::unordered_set<PMessdiener*>* list_dienst) {
	int num_dienste = termin->list_dienst_req.size();
	for (int j = 0; j < num_dienste; j++) {
		for (std::unordered_set<PMessdiener*>::iterator iter_m = termin->list_dienst_minis.at(j).second.begin(); iter_m != termin->list_dienst_minis.at(j).second.end(); iter_m++) {
			list_gesamt->insert(*iter_m);
			if (termin->list_dienst_minis.at(j).first == dienst) {
				list_dienst->insert(*iter_m);
			}
		}
	}
}

//handle mgruppen --------------------------------------------------------------

void PlanerController::prepareMGruppenHard() {
	for (std::vector<PMGruppe*>::iterator iter_mg = tmp_list_mgruppe.begin(); iter_mg != tmp_list_mgruppe.end(); iter_mg++) {
		if ((**iter_mg).modus == MGruppe::NUR_GEM) {
			for (std::vector<CTermin*>::iterator iter_t = tmp_list_termin.begin(); iter_t != tmp_list_termin.end(); iter_t++) {
				if (!insertMGruppeHard(*iter_t, (**iter_mg).list, false)) {
					//not possible to insert mg in here
					for (std::vector<PMessdiener*>::iterator iter_m = (**iter_mg).list.begin(); iter_m != (**iter_mg).list.end(); iter_m++) {
						eraseFromAvailableList(*iter_t, *iter_m);
					}
				}
			}
		}
	}
}

void PlanerController::handleMGruppen(CTermin* termin, int dienst, PMessdiener * mini) {
	if (mini->gruppe != NULL) {
		std::vector<PMessdiener*> mgruppe = mini->gruppe->list;
		for (std::vector<PMessdiener*>::iterator iter_m = mgruppe.begin(); iter_m != mgruppe.end(); iter_m++) {
			if (*iter_m != mini) {
				//try to insert into same service-list
				if (termin->list_dienst_req.at(dienst).second > 0
						&& termin->list_dienst_minis_available.at(dienst).second.find(*iter_m) != termin->list_dienst_minis_available.at(dienst).second.end()) {
					termin->list_dienst_minis.at(dienst).second.insert(*iter_m);
					termin->list_dienst_req.at(dienst).second--;
					(**iter_m).num++;
					handleTGruppen(termin, *iter_m);
				} else {//try to insert somewhere else
					int num_dienste = termin->list_dienst_req.size();
					for (int j = 0; j < num_dienste; j++) {
						if (j != dienst && termin->list_dienst_req.at(j).second > 0
								&& termin->list_dienst_minis_available.at(j).second.find(*iter_m) != termin->list_dienst_minis_available.at(j).second.end()) {
							termin->list_dienst_minis.at(j).second.insert(*iter_m);
							termin->list_dienst_req.at(j).second--;
							(**iter_m).num++;
							handleTGruppen(termin, *iter_m);
							break;
						}
					}
				}
			}
		}
	}
}

void PlanerController::handleMGruppenHard(CTermin* termin) {
	for (std::vector<PMGruppe*>::iterator iter_mg = tmp_list_mgruppe.begin(); iter_mg != tmp_list_mgruppe.end(); iter_mg++) {
		if ((**iter_mg).modus == MGruppe::NUR_GEM) {
			if (!insertMGruppeHard(termin, (**iter_mg).list, false)) {
				//not possible to insert mg in here
				for (std::vector<PMessdiener*>::iterator iter_m = (**iter_mg).list.begin(); iter_m != (**iter_mg).list.end(); iter_m++) {
					eraseFromAvailableList(termin, *iter_m);
				}
			}
			CTermin* t = termin;
			while (t->next != NULL) {
				t = t->next;
				if (!insertMGruppeHard(t, (**iter_mg).list, false)) {
					//not possible to insert mg in here
					for (std::vector<PMessdiener*>::iterator iter_m = (**iter_mg).list.begin(); iter_m != (**iter_mg).list.end(); iter_m++) {
						eraseFromAvailableList(t, *iter_m);
					}
				}
			}
			t = termin;
			while (t->prev != NULL) {
				t = t->prev;
				if (!insertMGruppeHard(t, (**iter_mg).list, false)) {
					//not possible to insert mg in here
					for (std::vector<PMessdiener*>::iterator iter_m = (**iter_mg).list.begin(); iter_m != (**iter_mg).list.end(); iter_m++) {
						eraseFromAvailableList(t, *iter_m);
					}
				}
			}
		}
	}
}

/**
 * To be called with keep = true only when succeeded with keep = false.
 * @param termin
 * @param list
 * @param keep: keep result in system or remove when finished
 */
bool PlanerController::insertMGruppeHard(CTermin* termin, std::vector<PMessdiener*> list, bool keep) {
	if (list.empty()) return true;
	PMessdiener* m = list.front();
	list.erase(list.begin());
	//check if already contained
	bool inside = false;
	for (std::vector<std::pair<Dienst*, std::unordered_set<PMessdiener*> > >::iterator iter_d = termin->list_dienst_minis.begin();
			iter_d != termin->list_dienst_minis.end(); iter_d++) {
		if (iter_d->second.find(m) != iter_d->second.end()) {
			inside = true;
			break;
		}
	}
	if (inside) return true;
	int num_dienste = termin->list_dienst_req.size();
	for (int i = 0; i < num_dienste; i++) {
		if (termin->list_dienst_minis_available.at(i).second.find(m) == termin->list_dienst_minis_available.at(i).second.end()) continue;
		if (termin->list_dienst_req.at(i).second == 0) continue;
		termin->list_dienst_minis_available.at(i).second.erase(m);
		termin->list_dienst_minis.at(i).second.insert(m);
		termin->list_dienst_req.at(i).second--;
		if (insertMGruppeHard(termin, list, keep)) {
			if (keep) {
				m->num++;
			} else {
				termin->list_dienst_minis_available.at(i).second.insert(m);
				termin->list_dienst_minis.at(i).second.erase(m);
				termin->list_dienst_req.at(i).second++;
			}
			return true;
		}
		termin->list_dienst_minis_available.at(i).second.insert(m);
		termin->list_dienst_minis.at(i).second.erase(m);
		termin->list_dienst_req.at(i).second++;

	}
	return false;
}

//handle tgruppen --------------------------------------------------------------

/**
 * erase (inserted) mini from all lists in tgruppe(termin).
 * @param termin
 * @param mini
 */
void PlanerController::handleTGruppen(CTermin* termin, PMessdiener * mini) {
	eraseFromAvailableList(termin, mini);
	CTermin* t = termin;
	while (t->next != NULL) {
		t = t->next;
		eraseFromAvailableList(t, mini);
	}
	t = termin;
	while (t->prev != NULL) {
		t = t->prev;
		eraseFromAvailableList(t, mini);
	}
}

void PlanerController::handleTGruppenP(PTermin* termin, PMessdiener * mini) {
	eraseFromAvailableListP(termin, mini);
	PTermin* t = termin;
	while (t->next != NULL) {
		t = t->next;
		eraseFromAvailableListP(t, mini);
	}
	t = termin;
	while (t->prev != NULL) {
		t = t->prev;
		eraseFromAvailableListP(t, mini);
	}
}

void PlanerController::handleTGruppenWithdrawP(PTermin* termin, PMessdiener * mini) {
	addToAvailableListIfPossibleP(termin, mini);
	PTermin* t = termin;
	while (t->next != NULL) {
		t = t->next;
		addToAvailableListIfPossibleP(t, mini);
	}
	t = termin;
	while (t->prev != NULL) {
		t = t->prev;
		addToAvailableListIfPossibleP(t, mini);
	}
}

void PlanerController::eraseFromAvailableList(CTermin* t, PMessdiener * m) {
	for (std::vector<std::pair<Dienst*, std::unordered_set<PMessdiener*> > >::iterator iter_d = t->list_dienst_minis_available.begin(); iter_d != t->list_dienst_minis_available.end(); iter_d++) {
		iter_d->second.erase(m);
	}
}

void PlanerController::addToAvailableListIfPossibleP(PTermin* t, PMessdiener * m) {
	int num_dienste = t->list_dienst_num.size();
	for (int j = 0; j < num_dienste; j++) {
		if (std::find(t->list_dienst_minis_possible.at(j).second.begin(), t->list_dienst_minis_possible.at(j).second.end(), m)
				!= t->list_dienst_minis_possible.at(j).second.end()) {
			if (std::find(t->list_dienst_minis_available.at(j).second.begin(), t->list_dienst_minis_available.at(j).second.end(), m)
					== t->list_dienst_minis_available.at(j).second.end()) {
				t->list_dienst_minis_available.at(j).second.push_back(m);
				std::sort(t->list_dienst_minis_available.at(j).second.begin(), t->list_dienst_minis_available.at(j).second.end(), PMessdiener::cmp);
			}
		}
	}
}

void PlanerController::eraseFromAvailableListP(PTermin* t, PMessdiener * m) {
	for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_d = t->list_dienst_minis_available.begin(); iter_d != t->list_dienst_minis_available.end(); iter_d++) {
		Util::erase_from_minivec(&iter_d->second, m);
	}
}

//connection to real lists -----------------------------------------------------

void PlanerController::initTmpLists() {
	int num_termine = planer->list_termin.size();
	if (tmp_list_termin.size() == 0 && tmp_list_mgruppe.size() == 0 && tmp_list_mini.size() == 0 && tmp_list_fehlzeit.size() == 0) {//first initialization
		for (std::vector<PMessdiener*>::iterator iter_m = planer->list_mini.begin(); iter_m != planer->list_mini.end(); iter_m++) {
			tmp_list_mini.push_back(new PMessdiener(**iter_m));
		}
		for (std::vector<PMGruppe*>::iterator iter_mg = planer->list_mgruppe.begin(); iter_mg != planer->list_mgruppe.end(); iter_mg++) {
			tmp_list_mgruppe.push_back(new PMGruppe(**iter_mg));
		}
		for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end(); iter_t++) {
			tmp_list_termin.push_back(new CTermin());
		}
		//adapt links
		for (std::vector<PMessdiener*>::iterator iter_m = tmp_list_mini.begin(); iter_m != tmp_list_mini.end(); iter_m++) {
			if ((**iter_m).gruppe != NULL) {
				(**iter_m).gruppe = tmp_list_mgruppe.at((**iter_m).gruppe->_id);
			}
		}
		for (std::vector<PMGruppe*>::iterator iter_mg = tmp_list_mgruppe.begin(); iter_mg != tmp_list_mgruppe.end(); iter_mg++) {
			int num_minis = (**iter_mg).list.size();
			for (int i = 0; i < num_minis; i++) {
				(**iter_mg).list.at(i) = tmp_list_mini.at((**iter_mg).list.at(i)->_id);
			}
		}
		for (int i = 0; i < num_termine; i++) {
			PTermin* pt = planer->list_termin.at(i);
			CTermin* ct = tmp_list_termin.at(i);
			ct->_id = pt->_id;
			ct->datum = pt->datum;
			if (pt->prev != NULL) {
				ct->prev = tmp_list_termin.at(pt->prev->_id);
			}
			if (pt->next != NULL) {
				ct->next = tmp_list_termin.at(pt->next->_id);
			}
		}
	} else {
		for (std::vector<PMessdiener*>::iterator iter_m = tmp_list_mini.begin(); iter_m != tmp_list_mini.end(); iter_m++) {
			(**iter_m).num = planer->list_mini.at((**iter_m)._id)->num;
		}
		for (int i = 0; i < num_termine; i++) {
			tmp_list_termin.at(i)->list_dienst_minis.clear();
			tmp_list_termin.at(i)->list_dienst_minis_available.clear();
			tmp_list_termin.at(i)->list_dienst_req.clear();
		}
		for (std::vector<PFehlzeit*>::iterator iter_f = tmp_list_fehlzeit.begin(); iter_f != tmp_list_fehlzeit.end(); iter_f++) {
			delete *iter_f;
		}
		tmp_list_fehlzeit.clear();
	}
	//Fehlzeiten
	for (std::vector<PFehlzeit*>::iterator iter_f = planer->list_fehlzeit.begin(); iter_f != planer->list_fehlzeit.end(); iter_f++) {
		tmp_list_fehlzeit.push_back(new PFehlzeit(**iter_f));
	}
	for (std::vector<PFehlzeit*>::iterator iter_f = tmp_list_fehlzeit.begin(); iter_f != tmp_list_fehlzeit.end(); iter_f++) {
		(**iter_f).mini = tmp_list_mini.at((**iter_f).mini->_id);
	}
	//Termin-Listen
	for (int i = 0; i < num_termine; i++) {
		PTermin* pt = planer->list_termin.at(i);
		CTermin* ct = tmp_list_termin.at(i);
		int num_dienste = pt->list_dienst_num.size();
		for (int j = 0; j < num_dienste; j++) {
			Dienst* d = pt->list_dienst_num.at(j).first;
			//available list
			std::unordered_set<PMessdiener*> mini_avai;
			for (std::vector<PMessdiener*>::iterator iter_m = pt->list_dienst_minis_available.at(j).second.begin();
					iter_m != pt->list_dienst_minis_available.at(j).second.end(); iter_m++) {
				mini_avai.insert(tmp_list_mini.at((**iter_m)._id));
			}
			ct->list_dienst_minis_available.push_back(std::make_pair(d, mini_avai));
			//minis list and req
			std::unordered_set<PMessdiener*> minis;
			int req = pt->list_dienst_num.at(j).second;
			for (std::vector<PMessdiener*>::iterator iter_m = pt->list_dienst_minis.at(j).second.begin();
					iter_m != pt->list_dienst_minis.at(j).second.end(); iter_m++) {
				if (*iter_m != NULL) {
					minis.insert(tmp_list_mini.at((**iter_m)._id));
					req--;
				}
			}
			ct->list_dienst_minis.push_back(std::make_pair(d, minis));
			ct->list_dienst_req.push_back(std::make_pair(d, req));
		}
	}
}

void PlanerController::deleteTmpLists() {
	for (std::vector<CTermin*>::iterator iter = tmp_list_termin.begin(); iter != tmp_list_termin.end(); iter++) {
		delete *iter;
	}
	for (std::vector<PMGruppe*>::iterator iter = tmp_list_mgruppe.begin(); iter != tmp_list_mgruppe.end(); iter++) {
		delete *iter;
	}
	for (std::vector<PMessdiener*>::iterator iter = tmp_list_mini.begin(); iter != tmp_list_mini.end(); iter++) {
		delete *iter;
	}
	for (std::vector<PFehlzeit*>::iterator iter = tmp_list_fehlzeit.begin(); iter != tmp_list_fehlzeit.end(); iter++) {
		delete *iter;
	}
	tmp_list_termin.clear();
	tmp_list_mgruppe.clear();
	tmp_list_mini.clear();
	tmp_list_fehlzeit.clear();
}

void PlanerController::fillRealLists() {
	int num_minis = tmp_list_mini.size();
	for (int i = 0; i < num_minis; i++) {
		planer->list_mini.at(i)->num = tmp_list_mini.at(i)->num;
	}
	int num_termine = tmp_list_termin.size();
	for (int i = 0; i < num_termine; i++) {
		PTermin* pt = planer->list_termin.at(i);
		CTermin* ct = tmp_list_termin.at(i);
		int num_dienste = pt->list_dienst_num.size();
		for (int j = 0; j < num_dienste; j++) {
			//minis list
			for (std::unordered_set<PMessdiener*>::iterator iter_m = ct->list_dienst_minis.at(j).second.begin();
					iter_m != ct->list_dienst_minis.at(j).second.end(); iter_m++) {
				if (std::find(pt->list_dienst_minis.at(j).second.begin(), pt->list_dienst_minis.at(j).second.end(), planer->list_mini.at((**iter_m)._id))
						== pt->list_dienst_minis.at(j).second.end()) {
					for (std::vector<PMessdiener*>::iterator iter_m_vec = pt->list_dienst_minis.at(j).second.begin();
							iter_m_vec != pt->list_dienst_minis.at(j).second.end(); iter_m_vec++) {
						if (*iter_m_vec == NULL) {
							iter_m_vec = pt->list_dienst_minis.at(j).second.erase(iter_m_vec);
							pt->list_dienst_minis.at(j).second.insert(iter_m_vec, planer->list_mini.at((**iter_m)._id));
							break;
						}
					}
				}
			}
		}
	}
	//available lists: for each termin->dienst: avai = poss; for each mini in tgruppe->dienste->minis: erase mini from avai
	for (std::vector<PTermin*>::iterator iter = planer->list_termin.begin(); iter != planer->list_termin.end(); iter++) {
		if ((**iter).prev == (PTermin *) NULL) {
			recalculateAvailableListsInTGruppe(*iter);
		}
	}
	//Fehlzeiten: nothing to be done
}

void PlanerController::putCorrectMiniNums() {
	for (std::vector<PMessdiener*>::iterator iter_m = tmp_list_mini.begin(); iter_m != tmp_list_mini.end(); iter_m++) {
		(**iter_m).num = 0;
	}
	for (std::vector<CTermin*>::iterator iter_t = tmp_list_termin.begin(); iter_t != tmp_list_termin.end(); iter_t++) {
		for (std::vector<std::pair<Dienst*, std::unordered_set<PMessdiener*> > >::iterator iter_d = (**iter_t).list_dienst_minis.begin();
				iter_d != (**iter_t).list_dienst_minis.end(); iter_d++) {
			for (std::unordered_set<PMessdiener*>::iterator iter_m = iter_d->second.begin(); iter_m != iter_d->second.end(); iter_m++) {
				(**iter_m).num++;
			}
		}
	}
}

// stuff -----------------------------------------------------------------------

void PlanerController::onClear() {
	bool someNotEmpty = false;
	for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end() && !someNotEmpty; iter_t++) {
		int num_dienste = (**iter_t).list_dienst_num.size();
		for (int j = 0; j < num_dienste && !someNotEmpty; j++) {
			int num_minis = (**iter_t).list_dienst_minis.at(j).second.size();
			for (int k = 0; k < num_minis; k++) {
				if ((**iter_t).list_dienst_minis.at(j).second.at(k) != NULL) {
					someNotEmpty = true;
				}
			}
		}
	}
	if (someNotEmpty) {
		handleDataChange();
		for (std::vector<PMessdiener*>::iterator iter_m = planer->list_mini.begin(); iter_m != planer->list_mini.end(); iter_m++) {
			(**iter_m).num = 0;
		}
		for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end(); iter_t++) {
			//available list
			(**iter_t).list_dienst_minis_available = (**iter_t).list_dienst_minis_possible;
			//minis list
			int num_dienste = (**iter_t).list_dienst_num.size();
			for (int j = 0; j < num_dienste; j++) {
				int num_minis = (**iter_t).list_dienst_num.at(j).second;
				for (int k = 0; k < num_minis; k++) {
					(**iter_t).list_dienst_minis.at(j).second.at(k) = NULL;
				}
			}
		}
		edt = true;
		view->notifySave(true);
		view->notifyMinis();
		view->unHighlight();
		view->notifyMaskeAndPreview();
	}
}

void PlanerController::onEntryChanged(PTermin* termin, int dienst, int mini_old_i, PMessdiener* mini_new) {
	PMessdiener* mini_old = termin->list_dienst_minis.at(dienst).second.at(mini_old_i);
	if (mini_old != mini_new) {
		handleDataChange();
		termin->list_dienst_minis.at(dienst).second.at(mini_old_i) = mini_new;
		if (mini_new != NULL) {
			mini_new->num++;
			handleTGruppenP(termin, mini_new);
		}
		if (mini_old != NULL) {
			mini_old->num--;
			handleTGruppenWithdrawP(termin, mini_old);
		}
		view->notifyMinis();
		view->notifyMaskeAndPreview();
		view->highlightPMiniChoiceDialog(termin, dienst, mini_old_i);
		edt = true;
		view->notifySave(true);
	}
}

void PlanerController::onSave() {
	PlanFileHandler::savePlaner(planer);
	edt = false;
	view->notifySave(false);
}

void PlanerController::onUndo() {
	if (!history_list.empty()) {
		future_list.push_back(copyMinisToList());
		copyMinisFromList(&history_list.back());
		history_list.erase(history_list.begin() + history_list.size() - 1);
		view->notifyMinis();
		view->notifyMaskeAndPreview();
		edt = true;
		view->notifySave(true);
		view->notifyHistory(!history_list.empty());
		view->notifyFuture(true);
		view->unHighlight();
	}
}

void PlanerController::onRedo() {
	if (!future_list.empty()) {
		history_list.push_back(copyMinisToList());
		copyMinisFromList(&future_list.back());
		future_list.erase(future_list.begin() + future_list.size() - 1);
		view->notifyMinis();
		view->notifyMaskeAndPreview();
		edt = true;
		view->notifySave(true);
		view->notifyHistory(true);
		view->notifyFuture(!future_list.empty());
		view->unHighlight();
	}
}

void PlanerController::handleDataChange() {
	history_list.push_back(copyMinisToList());
	future_list.clear();
	view->notifyHistory(true);
	view->notifyFuture(false);
}

std::vector<std::vector<PMessdiener*> > PlanerController::copyMinisToList() {
	std::vector<std::vector<PMessdiener*> >list;
	for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end(); iter_t++) {
		int num_dienste = (**iter_t).list_dienst_num.size();
		for (int j = 0; j < num_dienste; j++) {
			list.push_back((**iter_t).list_dienst_minis.at(j).second);
			list.push_back((**iter_t).list_dienst_minis_available.at(j).second);
		}
	}
	return list;
}

void PlanerController::copyMinisFromList(std::vector<std::vector<PMessdiener*> >* list) {
	int counter = 0;
	for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end(); iter_t++) {
		int num_dienste = (**iter_t).list_dienst_num.size();
		for (int j = 0; j < num_dienste; j++) {
			(**iter_t).list_dienst_minis.at(j).second = list->at(counter++);
			(**iter_t).list_dienst_minis_available.at(j).second = list->at(counter++);
		}
	}
	Util::setMiniNums(&planer->list_mini, &planer->list_termin);
}

void PlanerController::recalculateAvailableListsInTGruppe(PTermin* termin) {
	std::vector<PTermin*> tgruppe;
	tgruppe.push_back(termin);
	PTermin* t = termin;
	while (t->next != NULL) {
		t = t->next;
		tgruppe.push_back(t);
	}
	t = termin;
	while (t->prev != NULL) {
		t = t->prev;
		tgruppe.push_back(t);
	}
	int num_tgruppe = tgruppe.size();
	for (int i = 0; i < num_tgruppe; i++) {
		PTermin* t = tgruppe.at(i);
		int num_dienste = t->list_dienst_num.size();
		t->list_dienst_minis_available = t->list_dienst_minis_possible;
		for (int j = 0; j < num_dienste; j++) {
			//erase all that are used somewhere
			for (int i2 = 0; i2 < num_tgruppe; i2++) {
				PTermin* t2 = tgruppe.at(i2);
				int num_dienste2 = t2->list_dienst_num.size();
				for (int j2 = 0; j2 < num_dienste2; j2++) {
					for (std::vector<PMessdiener*>::iterator iter_m = t2->list_dienst_minis.at(j2).second.begin(); 
							iter_m != t2->list_dienst_minis.at(j2).second.end(); 
							iter_m++) {
						if (*iter_m != NULL) Util::erase_from_minivec(&t->list_dienst_minis_available.at(j).second, *iter_m);
					}
				}
			}
		}
	}
}

void PlanerController::onEdtTermin(int index) {
	PTermin* termin = planer->list_termin.at(index);
	bool edt_termin = false;
	PTerminDialog* dialog = new PTerminDialog(view, termin, &planer->list_termin, &planer->list_dienst, &planer->list_mini, &edt_termin);
	dialog->ShowModal();
	delete dialog;
	if (edt_termin) {
		int j = 0;
		while (planer->list_termin.at(j) != termin) j++;
		view->notifyTermine(j);
		view->notifyTGruppen();
		view->notifyMinis();
		view->redrawMaske();
		view->notifyMaskeAndPreview();
		history_list.clear();
		future_list.clear();
		view->notifyHistory(false);
		view->notifyFuture(false);
		edt = true;
		view->notifySave(true);
	}
}

void PlanerController::onDelTermin(int index) {
	PTermin* t = planer->list_termin.at(index);
	if (t->prev != NULL) {
		t->prev->next = t->next;
	}
	if (t->next != NULL) {
		t->next->prev = t->prev;
	}
	delete t;
	planer->list_termin.erase(planer->list_termin.begin() + index);
	int counter = 0;
	for (std::vector<PTermin*>::iterator iter = planer->list_termin.begin(); iter != planer->list_termin.end(); iter++) {
		(**iter)._id = counter++;
	}
	Util::setMiniNums(&planer->list_mini, &planer->list_termin);
	view->notifyTermine();
	view->notifyTGruppen();
	view->notifyMinis();
	view->redrawMaske();
	view->notifyMaskeAndPreview();
	history_list.clear();
	future_list.clear();
	view->notifyHistory(false);
	view->notifyFuture(false);
	edt = true;
	view->notifySave(true);
}

PlanerController::PositionInfo::PositionInfo(CTermin* _termin, int _dienst, int _diff)
: termin(_termin), dienst(_dienst), diff(_diff) {
}

===== ./src/controller-plan/TerminCreator.cpp =====
/* 
 * File:   TerminCreator.cpp
 * Author: Yannik
 * 
 * Created on August 28, 2015, 1:26 PM
 */

#include "TerminCreator.h"
#include <algorithm>
#include "../Util.h"

TerminCreator::PTerminHolder::PTerminHolder(PTermin* _termin, Einzeltermin* _e) {
	termin = _termin;
	e = _e;
	s = (Serientermin*) NULL;
}

TerminCreator::PTerminHolder::PTerminHolder(PTermin* _termin, Serientermin* _s) {
	termin = _termin;
	s = _s;
	e = (Einzeltermin*) NULL;
}

bool TerminCreator::PTerminHolder::cmp(const PTerminHolder& p1, const PTerminHolder& p2) {
	return PTermin::cmp(p1.termin, p2.termin);
}

void TerminCreator::createLists(wxDateTime datum_beginn, wxDateTime datum_ende,
		std::vector<Dienst*>* dlist,
		std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist, std::vector<TGruppe*>* tglist,
		std::vector<Messdiener*>* mlist, std::vector<MGruppe*>* mglist, std::vector<Fehlzeit*>* flist,
		std::vector<Dienst*>* pdlist, std::vector<PTerminHolder>* pthlist, std::vector<PMessdiener*>* pmlist, std::vector<PMGruppe*>* pmglist, std::vector<PFehlzeit*>* pflist) {
	//prepare lists
	pdlist->clear();
	pthlist->clear();
	pmlist->clear();
	pmglist->clear();
	pflist->clear();
	//get new services
	createDienste(dlist, pdlist);
	//create intermediate objects
	createOrderedPTerminOriginList(datum_beginn, datum_ende, elist, slist, pthlist);
	addTGruppen(tglist, pthlist);

	std::vector<std::pair<PMessdiener*, Messdiener*> > pmhlist;
	createPMessdienerOriginList(mlist, &pmhlist);
	addMGruppen(mglist, &pmhlist, pmglist);
	//translate services (dienst_ids need to be set)
	for (std::vector<PTerminHolder>::iterator iter = pthlist->begin(); iter != pthlist->end(); iter++) {
		for (std::vector<std::pair<Dienst*, int> >::iterator iter_d = (*iter).termin->list_dienst_num.begin(); iter_d != (*iter).termin->list_dienst_num.end(); iter_d++) {
			(*iter_d).first = pdlist->at((*iter_d).first->_id);
		}
	}
	for (std::vector<std::pair<PMessdiener*, Messdiener*> >::iterator iter = pmhlist.begin(); iter != pmhlist.end(); iter++) {
		for (int i = 0; i < (int) iter->first->dienste.size(); i++) {
			iter->first->dienste.at(i) = pdlist->at(iter->first->dienste.at(i)->_id);
		}
	}
	//create needed objects from intermediate objects
	for (std::vector<std::pair<PMessdiener*, Messdiener*> >::iterator iter = pmhlist.begin(); iter != pmhlist.end(); iter++) {
		pmlist->push_back(iter->first);
	}
	//create list of Zeitraum-Fehlzeiten, needed for distribution of minis later
	createFehlzeitList(datum_beginn, datum_ende, pmlist, flist, pflist);
}

void TerminCreator::createDienste(std::vector<Dienst*>* dlist, std::vector<Dienst*>* pdlist) {
	for (std::vector<Dienst*>::iterator iter = dlist->begin(); iter != dlist->end(); iter++) {
		Dienst* d = new Dienst((**iter).name);
		pdlist->push_back(d);
	}
}

void TerminCreator::createOrderedPTerminOriginList(wxDateTime datum_beginn, wxDateTime datum_ende,
		std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist,
		std::vector<PTerminHolder>* pthlist) {
	//Einzeltermine
	for (std::vector<Einzeltermin*>::iterator iter = elist->begin(); iter != elist->end(); iter++) {
		Einzeltermin t = **iter;
		wxDateTime datum = Util::wxString_to_wxDateTime(t.datum);
		if (!datum_beginn.IsLaterThan(datum) && !datum_ende.IsEarlierThan(datum)) {
			PTermin* termin = new PTermin(t.name, t.ort, Util::wxString_to_wxDateTime(t.datum), t.zeit_beginn, t.bem, t.dienste);
			pthlist->push_back(PTerminHolder(termin, *iter));
		}
	}
	//Serientermine
	for (std::vector<Serientermin*>::iterator iter = slist->begin(); iter != slist->end(); iter++) {
		Serientermin t = **iter;
		wxDateTime beginn = datum_beginn;
		if (!t.datum_beginn.IsEmpty()) {
			wxDateTime t_datum_beginn = Util::wxString_to_wxDateTime(t.datum_beginn);
			if (t_datum_beginn.IsLaterThan(datum_beginn)) {
				beginn = t_datum_beginn;
			}
		}
		wxDateTime ende = datum_ende;
		if (!t.datum_ende.IsEmpty()) {
			wxDateTime t_datum_ende = Util::wxString_to_wxDateTime(t.datum_ende);
			if (t_datum_ende.IsEarlierThan(datum_ende)) {
				ende = t_datum_ende;
			}
		}
		switch (t.modus) {
			case Serientermin::TAEGLICH:
			{
				wxDateTime current_day(beginn);
				while (!current_day.IsLaterThan(ende)) {
					pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
					current_day.Add(wxDateSpan(0, 0, 0, 1));
				}
			}
				break;
			case Serientermin::WOECHENTLICH:
			{
				int wday = t.wochentag;
				int cur_wday = beginn.GetWeekDay();
				wxDateTime current_day(beginn);
				current_day.Add(wxDateSpan(0, 0, 0, (wday < cur_wday) ? wday - cur_wday + 7 : wday - cur_wday));
				while (!current_day.IsLaterThan(ende)) {
					pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
					current_day.Add(wxDateSpan(0, 0, 0, 7));
				}
			}
				break;
			case Serientermin::GERADE_KW:
			{
				int wday = t.wochentag;
				int cur_wday = beginn.GetWeekDay();
				wxDateTime current_day(beginn);
				current_day.Add(wxDateSpan(0, 0, 0, (wday < cur_wday) ? wday - cur_wday + 7 : wday - cur_wday));
				while (!current_day.IsLaterThan(ende)) {
					//std:: week starts with monday
					if (current_day.GetWeekOfYear() % 2 == 0) {
						pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
					}
					current_day.Add(wxDateSpan(0, 0, 0, 7));
				}
			}
				break;
			case Serientermin::UNGERADE_KW:
			{
				int wday = t.wochentag;
				int cur_wday = beginn.GetWeekDay();
				wxDateTime current_day(beginn);
				current_day.Add(wxDateSpan(0, 0, 0, (wday < cur_wday) ? wday - cur_wday + 7 : wday - cur_wday));
				while (!current_day.IsLaterThan(ende)) {
					if (current_day.GetWeekOfYear() % 2 != 0) {
						pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
					}
					current_day.Add(wxDateSpan(0, 0, 0, 7));
				}
			}
				break;
			case Serientermin::N_WOECHENTLICH:
			{
				wxDateTime current_day(Util::wxString_to_wxDateTime(t.datum_beginn));
				int wday = t.wochentag;
				int cur_wday = current_day.GetWeekDay();
				current_day.Add(wxDateSpan(0, 0, 0, (wday < cur_wday) ? wday - cur_wday + 7 : wday - cur_wday));
				while (!current_day.IsLaterThan(ende)) {
					if (!current_day.IsEarlierThan(beginn)) {
						pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
					}
					current_day.Add(wxDateSpan(0, 0, 0, t.n * 7));
				}
			}
				break;
			case Serientermin::W_IM_MONAT:
			{
				int wday = t.wochentag;
				wxDateTime current_day(beginn);
				if (t.n < 5) {
					current_day.SetDay(1);
					int cur_wday = current_day.GetWeekDay();
					current_day.Add(wxDateSpan(0, 0, 0, (wday < cur_wday) ? wday - cur_wday + 7 : wday - cur_wday));
					int month = current_day.GetMonth();
					current_day.Add(wxDateSpan(0, 0, 0, 7 * t.n));
					while (!current_day.IsLaterThan(ende)) {
						if (month == current_day.GetMonth()) {
							pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
							current_day.Add(wxDateSpan(0, 1, 0, 0));
						}
						current_day.SetDay(1);
						cur_wday = current_day.GetWeekDay();
						current_day.Add(wxDateSpan(0, 0, 0, (wday < cur_wday) ? wday - cur_wday + 7 : wday - cur_wday));
						month = current_day.GetMonth();
						current_day.Add(wxDateSpan(0, 0, 0, 7 * t.n));
					}
				} else {
					//get first day
					current_day.SetDay(1);
					current_day.Add(wxDateSpan(0, 1, 0, 0));
					current_day.Add(wxDateSpan(0, 0, 0, -1));
					int cur_wday = current_day.GetWeekDay();
					current_day.Add(wxDateSpan(0, 0, 0, (wday <= cur_wday) ? wday - cur_wday : wday - cur_wday - 7));
					if (t.n == 5) {//vorletzter [Wochentag]
						current_day.Add(wxDateSpan(0, 0, -1, 0));
					}
					while (!current_day.IsLaterThan(ende)) {
						if (!current_day.IsEarlierThan(beginn)) {
							pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
						}
						//one month up
						current_day.Add(wxDateSpan(0, 1, 0, 0));
						//get day
						current_day.SetDay(1);
						current_day.Add(wxDateSpan(0, 1, 0, 0));
						current_day.Add(wxDateSpan(0, 0, 0, -1));
						int cur_wday = current_day.GetWeekDay();
						current_day.Add(wxDateSpan(0, 0, 0, (wday <= cur_wday) ? wday - cur_wday : wday - cur_wday - 7));
						if (t.n == 5) {//vorletzter [Wochentag]
							current_day.Add(wxDateSpan(0, 0, -1, 0));
						}
					}
				}
			}
				break;
			case Serientermin::MONATLICH:
			{
				int mday = t.n;
				wxDateTime current_day(beginn);
				wxDateTime current_day2(current_day);
				current_day2.SetDay(1);
				current_day2.Add(wxDateSpan(0, 1, 0, 0));
				current_day2.Add(wxDateSpan(0, 0, 0, -1));
				bool mHasDay = true;
				if (current_day2.GetDay() < mday) {
					mHasDay = false;
				} else {
					current_day.SetDay(mday);
				}
				while (!current_day.IsLaterThan(ende)) {
					if (!current_day.IsEarlierThan(beginn) && mHasDay) {
						pthlist->push_back(PTerminHolder(new PTermin(t.name, t.ort, current_day, t.zeit_beginn, t.bem, t.dienste), *iter));
					}
					current_day.Add(wxDateSpan(0, 1, 0, 0));
					//get new day if possible
					wxDateTime current_day2(current_day);
					current_day2.SetDay(1);
					current_day2.Add(wxDateSpan(0, 1, 0, 0));
					current_day2.Add(wxDateSpan(0, 0, 0, -1));
					mHasDay = true;
					if (current_day2.GetDay() < mday) {
						mHasDay = false;
					} else {
						current_day.SetDay(mday);
					}
				}
			}
				break;
		}
		std::sort(pthlist->begin(), pthlist->end(), PTerminHolder::cmp);
	}
}

void TerminCreator::addTGruppen(std::vector<TGruppe*>* tglist, std::vector<PTerminHolder>* pthlist) {
	//first date used later on, so prepare for that case
	if (pthlist->empty()) {
		return;
	}
	for (std::vector<TGruppe*>::iterator tgiter = tglist->begin(); tgiter != tglist->end(); tgiter++) {
		if ((**tgiter).list_serie.empty()) {
			//alle Termine der TGruppe bilden eine PTGruppe
			std::vector<PTermin*> current_list;
			for (std::vector<PTerminHolder>::iterator pthiter = pthlist->begin(); pthiter != pthlist->end(); pthiter++) {
				if (std::find((**tgiter).list_einzel.begin(), (**tgiter).list_einzel.end(), pthiter->e) != (**tgiter).list_einzel.end()) {
					current_list.push_back(pthiter->termin);
				}
			}
			for (int i = 1; i < (int) current_list.size(); i++) {
				current_list.at(i - 1)->next = current_list.at(i);
				current_list.at(i)->prev = current_list.at(i - 1);
			}
		} else {//week by week
			int wday = (**tgiter).wochentag;
			wxDateTime current_day(pthlist->at(0).termin->datum);
			int cur_wday = current_day.GetWeekDay();
			current_day.Add(wxDateSpan(0, 0, 0, (wday <= cur_wday) ? wday - cur_wday : wday - cur_wday - 7));
			wxDateTime week_later(current_day);
			week_later.Add(wxDateSpan(0, 0, 0, 7));
			std::vector<PTerminHolder>::iterator pthiter = pthlist->begin();
			while (!current_day.IsLaterThan(pthlist->back().termin->datum)) {
				std::vector<PTermin*> current_list;
				while (pthiter != pthlist->end() && pthiter->termin->datum.IsEarlierThan(week_later)) {
					if (pthiter->e != NULL) {
						if (std::find((**tgiter).list_einzel.begin(), (**tgiter).list_einzel.end(), pthiter->e) != (**tgiter).list_einzel.end()) {
							current_list.push_back(pthiter->termin);
						}
					} else {//pthiter->s != NULL
						if (std::find((**tgiter).list_serie.begin(), (**tgiter).list_serie.end(), pthiter->s) != (**tgiter).list_serie.end()) {
							current_list.push_back(pthiter->termin);
						}
					}
					pthiter++;
				}
				for (int i = 1; i < (int) current_list.size(); i++) {
					current_list.at(i - 1)->next = current_list.at(i);
					current_list.at(i)->prev = current_list.at(i - 1);
				}
				current_day.Add(wxDateSpan(0, 0, 1, 0));
				week_later.Add(wxDateSpan(0, 0, 1, 0));
			}
		}
	}
}

void TerminCreator::createPMessdienerOriginList(std::vector<Messdiener*>* mlist, std::vector<std::pair<PMessdiener*, Messdiener*> >* pmhlist) {
	for (std::vector<Messdiener*>::iterator iter = mlist->begin(); iter != mlist->end(); iter++) {
		pmhlist->push_back(std::make_pair(new PMessdiener((**iter).name, (**iter).vorname, (**iter).dienste), *iter));
	}
}

void TerminCreator::addMGruppen(std::vector<MGruppe*>* mglist, std::vector<std::pair<PMessdiener*, Messdiener*> >* pmhlist, std::vector<PMGruppe*>* pmglist) {
	for (std::vector<MGruppe*>::iterator iter = mglist->begin(); iter != mglist->end(); iter++) {
		std::vector<PMessdiener*> gruppe;
		for (std::vector<Messdiener*>::iterator iter_m = (**iter).list.begin(); iter_m != (**iter).list.end(); iter_m++) {
			gruppe.push_back(pmhlist->at((**iter_m)._id).first);
		}
		PMGruppe* pmgruppe = new PMGruppe((**iter).modus, gruppe);
		pmglist->push_back(pmgruppe);
		for (std::vector<Messdiener*>::iterator iter_m = (**iter).list.begin(); iter_m != (**iter).list.end(); iter_m++) {
			pmhlist->at((*iter_m)->_id).first->gruppe = pmgruppe;
		}
	}
}

void TerminCreator::fillMLists(std::vector<PTerminHolder>* pthlist, std::vector<PMessdiener*>* pmlist,
		std::vector<Fehlzeit*>* flist, std::vector<Dienst*>* pdlist) {
	//fill lists according to abilities
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_dienst_minis;
	for (std::vector<Dienst*>::iterator iter_d = pdlist->begin(); iter_d != pdlist->end(); iter_d++) {
		std::vector<PMessdiener*> m_liste;
		for (std::vector<PMessdiener*>::iterator iter_m = pmlist->begin(); iter_m != pmlist->end(); iter_m++) {
			if (std::find((**iter_m).dienste.begin(), (**iter_m).dienste.end(), *iter_d) != (**iter_m).dienste.end()) {
				m_liste.push_back(*iter_m);
			}
		}
		list_dienst_minis.push_back(std::make_pair(*iter_d, m_liste));
	}
	//fill list_dienst_minis (with ZEROs) and list_dienst_minis_possible (according to above abilities)
	for (std::vector<PTerminHolder>::iterator iter_t = pthlist->begin(); iter_t != pthlist->end(); iter_t++) {
		for (std::vector<std::pair<Dienst*, int> >::iterator iter_d = iter_t->termin->list_dienst_num.begin(); iter_d != iter_t->termin->list_dienst_num.end(); iter_d++) {
			std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_list = list_dienst_minis.begin();
			for (; iter_list->first != iter_d->first; iter_list++) {
			}
			iter_t->termin->list_dienst_minis_possible.push_back(*iter_list);
			//fill in same order and initiate with NULL pointers (needed later and for file)
			std::vector<PMessdiener*> mset;
			mset.reserve(iter_d->second);
			for (int i = 0; i < iter_d->second; i++) {
				mset.push_back(NULL);
			}
			iter_t->termin->list_dienst_minis.push_back(std::make_pair(iter_list->first, mset));
		}
	}
	//iterate fehlzeiten and delete accordingly
	for (std::vector<Fehlzeit*>::iterator iter_f = flist->begin(); iter_f != flist->end(); iter_f++) {
		switch ((**iter_f).modus) {
			case Fehlzeit::ZEITRAUM:
			{
				wxDateTime beginn = Util::wxString_to_wxDateTime((**iter_f).beginn);
				wxDateTime ende = Util::wxString_to_wxDateTime((**iter_f).ende);
				std::vector<PTerminHolder>::iterator iter_t = pthlist->begin();
				while (iter_t != pthlist->end() && iter_t->termin->datum.IsEarlierThan(beginn)) {
					iter_t++;
				}
				while (iter_t != pthlist->end() && !iter_t->termin->datum.IsLaterThan(ende)) {
					for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_poss = iter_t->termin->list_dienst_minis_possible.begin();
							iter_poss != iter_t->termin->list_dienst_minis_possible.end(); iter_poss++) {
						Util::erase_from_minivec(&iter_poss->second, pmlist->at((**iter_f).mini->_id));
					}
					iter_t++;
				}
				break;
			}
			case Fehlzeit::WOCHENTAG:
			{
				int wday = (**iter_f).wochentag;
				wxString zeit_beginn = (**iter_f).beginn;
				wxString zeit_ende = (**iter_f).ende;
				for (std::vector<PTerminHolder>::iterator iter_t = pthlist->begin(); iter_t != pthlist->end(); iter_t++) {
					if (iter_t->termin->datum.GetWeekDay() == wday && iter_t->termin->zeit_beginn >= zeit_beginn && iter_t->termin->zeit_beginn <= zeit_ende) {
						for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_poss = iter_t->termin->list_dienst_minis_possible.begin();
								iter_poss != iter_t->termin->list_dienst_minis_possible.end(); iter_poss++) {
							Util::erase_from_minivec(&iter_poss->second, pmlist->at((**iter_f).mini->_id));
						}
					}
				}
				break;
			}
			case Fehlzeit::EINZELTERMIN:
			{
				for (std::vector<PTerminHolder>::iterator iter_t = pthlist->begin(); iter_t != pthlist->end(); iter_t++) {
					if (iter_t->e == (**iter_f).einzeltermin) {
						for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_poss = iter_t->termin->list_dienst_minis_possible.begin();
								iter_poss != iter_t->termin->list_dienst_minis_possible.end(); iter_poss++) {
							Util::erase_from_minivec(&iter_poss->second, pmlist->at((**iter_f).mini->_id));
						}
					}
				}
				break;
			}
			case Fehlzeit::SERIENTERMIN:
			{
				for (std::vector<PTerminHolder>::iterator iter_t = pthlist->begin(); iter_t != pthlist->end(); iter_t++) {
					if (iter_t->s == (**iter_f).serientermin) {
						for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_poss = iter_t->termin->list_dienst_minis_possible.begin();
								iter_poss != iter_t->termin->list_dienst_minis_possible.end(); iter_poss++) {
							Util::erase_from_minivec(&iter_poss->second, pmlist->at((**iter_f).mini->_id));
						}
					}
				}
				break;
			}
		}
	}
	//initiate available lists, same as possible lists
	for (std::vector<PTerminHolder>::iterator iter_t = pthlist->begin(); iter_t != pthlist->end(); iter_t++) {
		iter_t->termin->list_dienst_minis_available = iter_t->termin->list_dienst_minis_possible;
	}
}

void TerminCreator::createTerminList(std::vector<PTerminHolder>* pthlist, std::vector<PTermin*>* ptlist) {
	for (std::vector<PTerminHolder>::iterator iter = pthlist->begin(); iter != pthlist->end(); iter++) {
		ptlist->push_back(iter->termin);
	}
}

void TerminCreator::createFehlzeitList(wxDateTime datum_beginn, wxDateTime datum_ende, std::vector<PMessdiener*>* pmlist, std::vector<Fehlzeit*>* flist, std::vector<PFehlzeit*>* pflist) {
	for (std::vector<Fehlzeit*>::iterator iter_f = flist->begin(); iter_f != flist->end(); iter_f++) {
		if ((**iter_f).modus != Fehlzeit::ZEITRAUM) continue;
		wxDateTime f_datum_beginn = Util::wxString_to_wxDateTime((**iter_f).beginn);
		wxDateTime f_datum_ende = Util::wxString_to_wxDateTime((**iter_f).ende);
		if (f_datum_beginn.IsLaterThan(datum_ende) || f_datum_ende.IsEarlierThan(datum_beginn)) continue;
		pflist->push_back(new PFehlzeit(pmlist->at((**iter_f).mini->_id), f_datum_beginn, f_datum_ende));
	}
}

===== ./src/controller-plan/TerminCreator.h =====
/* 
 * File:   TerminCreator.h
 * Author: Yannik
 *
 * Created on August 28, 2015, 1:26 PM
 */

#ifndef TERMINCREATOR_H
#define	TERMINCREATOR_H

#include <vector>
#include "../model-data/Dienst.h"
#include "../model-data/Einzeltermin.h"
#include "../model-data/Serientermin.h"
#include "../model-data/Messdiener.h"
#include "../model-data/TGruppe.h"
#include "../model-data/MGruppe.h"
#include "../model-data/Fehlzeit.h"
#include "../model-plan/PTermin.h"
#include "../model-plan/PMGruppe.h"
#include "../model-plan/PFehlzeit.h"

/**
 * Call createLists to fill dlist, mlist, mglist, pthlist.
 * Do some changes (also to services) and call fillMLists.
 * Finally call createTerminList.
 */
namespace TerminCreator {

	class PTerminHolder {
	public:
		PTermin* termin;
		Einzeltermin* e;
		Serientermin* s;
		PTerminHolder(PTermin* _termin, Einzeltermin* _e);
		PTerminHolder(PTermin* _termin, Serientermin* _s);
		static bool cmp(const PTerminHolder& p1, const PTerminHolder& p2);
	private:
	};

	void createLists(wxDateTime datum_beginn, wxDateTime datum_ende,
			std::vector<Dienst*>* dlist,
			std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist, std::vector<TGruppe*>* tglist,
			std::vector<Messdiener*>* mlist, std::vector<MGruppe*>* mglist, std::vector<Fehlzeit*>* flist,
			std::vector<Dienst*>* pdlist, std::vector<PTerminHolder>* pthlist, std::vector<PMessdiener*>* pmlist, std::vector<PMGruppe*>* pmglist, std::vector<PFehlzeit*>* pflist);
	void createDienste(std::vector<Dienst*>* dlist, std::vector<Dienst*>* pdlist);
	void createOrderedPTerminOriginList(wxDateTime datum_beginn, wxDateTime datum_ende,
			std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist,
			std::vector<PTerminHolder>* pthlist);
	void addTGruppen(std::vector<TGruppe*>* tglist, std::vector<PTerminHolder>* pthlist);
	void createPMessdienerOriginList(std::vector<Messdiener*>* mlist, std::vector<std::pair<PMessdiener*, Messdiener*> >* pmhlist);
	void addMGruppen(std::vector<MGruppe*>* mglist, std::vector<std::pair<PMessdiener*, Messdiener*> >* pmhlist, std::vector<PMGruppe*>* pmglist);
	void fillMLists(std::vector<PTerminHolder>* pthlist, std::vector<PMessdiener*>* pmlist, std::vector<Fehlzeit*>* flist, std::vector<Dienst*>* pdlist);
	void createTerminList(std::vector<PTerminHolder>* pthlist, std::vector<PTermin*>* ptlist);
	void createFehlzeitList(wxDateTime datum_beginn, wxDateTime datum_ende, std::vector<PMessdiener*>* pmlist, std::vector<Fehlzeit*>* flist, std::vector<PFehlzeit*>* pflist);
};

#endif	/* TERMINCREATOR_H */

===== ./src/R.cpp =====
/* 
 * File:   R.cpp
 * Author: Yannik
 *
 * Created on August 11, 2015, 4:18 PM
 */

#include "R.h"

//Allgemein
wxString R::MINI_PLANER = wxT("MiniPlaner");
wxString R::DIENST_DIALOG = wxT("Dienst-Dialog");
wxString R::MINI_DIALOG = wxT("Mini-Dialog");
wxString R::EINZELTERMIN_DIALOG = wxT("Einzeltermin-Dialog");
wxString R::SERIENTERMIN_DIALOG = wxT("Serientermin-Dialog");
wxString R::TERMIN_DIENST_DIALOG = wxT("Termin-Dienst-Dialog");
wxString R::MGRUPPE_DIALOG = wxT("Minigruppe-Dialog");
wxString R::TGRUPPE_DIALOG = wxT("Terminverbund-Dialog");
wxString R::FEHLZEIT_DIALOG = wxT("Fehlzeit-Dialog");
wxString R::PLAN_DIALOG = wxT("Planer");
wxString R::TERMIN_DIALOG = wxT("Termin-Dialog");
wxString R::EXPORT_LAYOUT_DIALOG = wxT("Export-Layout-Dialog");
wxString R::MINI_EXPORT_DIALOG = wxT("Mini-Export-Dialog");
wxString R::MINI_IMPORT_DIALOG = wxT("Mini-Import-Dialog");
wxString R::MINI_EXTRAS_DIALOG = wxT("Mini-Extras-Dialog");
wxString R::EINZELTERMIN_IMPORT_DIALOG = wxT("Einzeltermin-Import-Dialog");
wxString R::SPEICHERN_DIALOG = wxT("");
wxString R::LOESCHEN_DIALOG = wxT("");
wxString R::PLANER_SETTINGS_DIALOG = wxT("Algorithmus-Einstellungen-Dialog");

wxString R::HILFE = wxT("Hilfe");
wxString R::UEBER = wxT("Über");
wxString R::SPRACHE = wxT("Sprache der Benutzeroberfläche");
wxString R::KONTAKT_MSG = wxT("Bei Fragen, Programmfehlern, Problemen oder Ideen dürfen Sie sich jederzeit gern melden.");
wxString R::EXTRAS = wxT("Extras");
wxString R::SEMIKOLON = wxT("Semikolon");
wxString R::KOMMA = wxT("Komma");
wxString R::LEERZEICHEN = wxT("Leerzeichen");
wxString R::ANDERES = wxT("Anderes: ");

wxString R::OK = wxT("OK");
wxString R::CANCEL = wxT("Abbrechen");
wxString R::ADD = wxT("Neu");
wxString R::DEL = wxT("Entfernen");
wxString R::EDT = wxT("Ändern");
wxString R::JA = wxT("Ja");
wxString R::NEIN = wxT("Nein");

wxString R::DIENSTE = wxT("Dienste");
wxString R::MINI = wxT("Mini");
wxString R::MINIS = wxT("Minis");
wxString R::MGRUPPEN = wxT("M.-Gruppen");
wxString R::TERMINE = wxT("Termine");
wxString R::TGRUPPEN = wxT("T.-Verbünde");
wxString R::FEHLZEITEN = wxT("Fehlzeiten");
wxString R::PLAENE = wxT("Pläne");
//Adresse
wxString R::STRASSE_NR = wxT("Straße Nr.");
wxString R::PLZ_ORT = wxT("PLZ Ort");
wxString R::TEL = wxT("Telefon");
wxString R::MOBILE = wxT("Mobil");
wxString R::EMAIL = wxT("E-Mail");
//Messdiener
wxString R::NAME = wxT("Name");
wxString R::NACHNAME = wxT("Nachname");
wxString R::VORNAME = wxT("Vorname");
wxString R::GEBURTSTAG = wxT("Geburtsdatum");
wxString R::BEM = wxT("Bem.");
wxString R::MINI_ATTS[] = {R::NACHNAME, R::VORNAME, R::DIENSTE, R::GEBURTSTAG, R::STRASSE_NR, R::PLZ_ORT, R::TEL, R::MOBILE, R::EMAIL, R::BEM};
//Termine
wxString R::EINZELTERMINE = wxT("Einzeltermine");
wxString R::SERIENTERMINE = wxT("Serientermine");
wxString R::ANZAHL = wxT("Anzahl");
wxString R::ORT = wxT("Ort");
wxString R::DATUM = wxT("Datum");
wxString R::ZEIT = wxT("Zeit");
wxString R::MODUS = wxT("Modus");
wxString R::DATUM_BEGINN = wxT("Anfangsdatum (inkl.)");
wxString R::DATUM_ENDE = wxT("Enddatum (inkl.)");
wxString R::TEINZEL_ATTS[] = {NAME, ORT, DATUM, ZEIT, DIENSTE, BEM};
wxString R::TSERIE_ATTS[] = {NAME, ORT, MODUS, ZEIT, DIENSTE, DATUM_BEGINN, DATUM_ENDE, BEM};

wxString R::SONNTAG = wxT("So.");
wxString R::MONTAG = wxT("Mo.");
wxString R::DIENSTAG = wxT("Di.");
wxString R::MITTWOCH = wxT("Mi.");
wxString R::DONNERSTAG = wxT("Do.");
wxString R::FREITAG = wxT("Fr.");
wxString R::SAMSTAG = wxT("Sa.");
wxString R::WOCHENTAGE[] = {SONNTAG, MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG};
//Modus
wxString R::TAEGLICH = wxT("täglich");
wxString R::WOECHENTLICH = wxT("wöchentlich");
wxString R::GERADE_KW = wxT("in geraden KWs");
wxString R::UNGERADE_KW = wxT("in ungeraden KWs");
wxString R::N_WOECHENTLICH = wxT("[n]-wöchentlich ab (inkl.) der Woche nach [Anfangsdatum]");
wxString R::W_IM_MONAT = wxT("[n-ter] [Wochentag] im Monat");
wxString R::MONATLICH = wxT("monatlich");
wxString R::TMODI[] = {TAEGLICH, WOECHENTLICH, GERADE_KW, UNGERADE_KW, N_WOECHENTLICH, W_IM_MONAT, MONATLICH};
wxString R::LETZTER = wxT("letzter");
wxString R::VORLETZTER = wxT("vorletzter");
wxString R::WOCHENTAG = wxT("Wochentag");
wxString R::TAG = wxT("Tag");
wxString R::DATUM_AB = wxT("Anfangsdatum (inkl.)");
wxString R::DATUM_BIS = wxT("Enddatum (inkl.)");
//Gruppen
wxString R::GRUPPE = wxT("Gruppe");
wxString R::RESTLISTE = wxT("restliche Minis");
wxString R::BEV_GEM = wxT("vorzugsweise gemeinsam");
wxString R::NUR_GEM = wxT("ausschließlich gemeinsam");
wxString R::MGMODI[] = {BEV_GEM, NUR_GEM};
wxString R::RESTTERMINE = wxT("restliche Termine");
wxString R::TGRUPPE = wxT("Verbund");
wxString R::PERIODISCH = wxT("wöchentlich: 7-Tage-Periode, beginnend ab (inkl.) ");
wxString R::NICHT_PERIODISCH = wxT("nicht-periodisch");
wxString R::TGMODI[] = {PERIODISCH, NICHT_PERIODISCH};
//Dienste
wxString R::DIENST = wxT("Dienst");
wxString R::ALLGEMEIN = wxT("Normal");
//Fehlzeiten
wxString R::FEHLZEIT = wxT("Fehlzeit");
wxString R::ZEITRAUM = wxT("Zeitraum");
wxString R::TERMIN = wxT("Termin");
wxString R::FEHLZEIT_MODI[] = {ZEITRAUM, WOCHENTAG, TERMIN};
wxString R::VON = wxT("von");
wxString R::BIS = wxT("bis");
//Pläne
wxString R::OEFFNEN = wxT("Öffnen");
wxString R::ZURUECK = wxT("Zurück");
wxString R::WEITER = wxT("Weiter");
wxString R::EINSAETZE = wxT("Einsätze");
wxString R::MASKE = wxT("Eingabemaske");
wxString R::AUTOMATISCH = wxT("Automatisch");
wxString R::STOPPEN = wxT("Stoppen");
wxString R::LEEREN = wxT("Leeren");
wxString R::EXPORT = wxT("Export");
wxString R::SPEICHERN = wxT("Speichern");
wxString R::DATEN = wxT("Daten");
wxString R::EINSTELLUNGEN = wxT("Einstellungen");
wxString R::FEHLZEITEN_ANRECHNEN = wxT("Fehl-Zeiträume werden intern bei Einsatzhäufigkeiten anteilig angerechnet");
wxString R::FEHLZEITEN_KOMPENSIEREN = wxT("Fehl-Zeiträume werden zu einer anderen Zeit kompensiert, falls möglich");
wxString R::ALG_MINIMUM = wxT("Algorithmus 1 (mit erweiterter Minimumssuche, evtl. schneller)");
wxString R::ALG_CHRONO = wxT("Algorithmus 2 (evtl. gleichmäßigere Abstände zwischen Einsätzen)");
//Export
wxString R::MESSDIENERPLAN = wxT("Ministrantenplan");
wxString R::MESSDIENERPLAN_SH = R::MESSDIENERPLAN;
wxString R::LAYOUT = wxT("Layout");
wxString R::VORSCHAU = wxT("Vorschau");
wxString R::MINIS_LAYOUT = wxT("Anordnung Minis");
wxString R::MINIS_LAYOUT_MODI[] = {wxT("in [n] Spalten"), wxT("kommasepariert")};
wxString R::BASICS_LAYOUT = wxT("Position Terminbeschreibung");
wxString R::BASICS_LAYOUT_MODI[] = {wxT("links"), wxT("oben")};
wxString R::NAMEN_LAYOUT = wxT("Format Namen");
wxString R::NAMEN_LAYOUT_MODI[] = {wxT("Vorname Nachname"), wxT("V. Nachname"), wxT("Vorname N."), wxT("Vorname")};
wxString R::DATEI_AUSGABE = wxT("Als Datei speichern");
wxString R::CLIPBOARD_AUSGABE = wxT("In Zwischenablage kopieren");
wxString R::TITEL = wxT("Überschrift");
wxString R::DIENSTE_ZEIGEN = wxT("Unterteilung nach Diensten");
wxString R::SPEICHERN_HTML = wxT("Im HTML-Format speichern");
wxString R::SPEICHERN_CSV = wxT("Im Tab-separierten CSV-Format speichern");
wxString R::SPEICHERN_EXCEL_XML = wxT("Im Excel-XML-Format speichern");
wxString R::SPALTEN = wxT("Spalten");
wxString R::NUM = wxT("Nr.");
wxString R::MESSDIENERLISTE = wxT("Ministrantenliste");
wxString R::MESSDIENERLISTE_SH = R::MESSDIENERLISTE;
//Import
wxString R::IMPORT = wxT("Import");
wxString R::IMPORTIEREN = wxT("Importieren");
wxString R::SEPARATOR = wxT("Separator");
wxString R::CSV_DATEI_WAEHLEN = wxT("CSV-Datei wählen");
wxString R::MINI_CSV_MSG = wxT("Die Zeilen der CSV-Datei werden von links nach rechts in folgendem Format ausgewertet:");
wxString R::MINI_IMPORT_MSG = wxT("Es werden nur Minis importiert, die über die Kennung Nachname+Vorname noch nicht in der\n"
		"bisherigen Liste enthalten sind.");
wxString R::EINZELTERMIN_CSV_MSG = wxT("Die Zeilen der CSV-Datei werden von links nach rechts in folgendem ");
wxString R::EINZELTERMIN_IMPORT_MSG = wxT("Es werden nur Termine importiert, die über die Kennung Ort+Datum+Zeit noch nicht in der\n"
		"bisherigen Liste enthalten sind.");
//Extras
wxString R::EMAILS = wxT("E-Mails");
wxString R::KOPIERTEMAILS = wxT("kopiert vorhandene E-Mail-Adressen Semikolon-separiert in Zwischenablage");
wxString R::ADRESSEN = wxT("Adressen");
wxString R::KOPIERTADRESSEN = wxT("kopiert Liste aller vorhandenen Adressen formatiert in Zwischenablage");
wxString R::KOPIERTEMAILSFERTIG = wxT("Email-Adressen in Zwischenablage kopiert!");
wxString R::KOPIERTADRESSENFERTIG = wxT("Adressen in Zwischenablage kopiert!");
wxString R::KOPIERTWARNICHTMOEGLICH = wxT("\nBei folgenden Minis war dies nicht möglich:\n");
//Über
wxString R::HEADLINE = wxT("ein Programm zum effizienten Erstellen hochwertiger Ministrantenpläne");
wxString R::AUTOR = wxT("Autor: ");
wxString R::BEITRAGENDE = wxT("Beitragende: ");
wxString R::KOMPILIERTMIT = wxT("Kompiliert mit: ");
wxString R::BIBLIOTHEKEN = wxT("Bibliotheken: ");
wxString R::INSTALLATIONSVERZEICHNIS = wxT("Installationsverzeichnis: ");
//Einstellungen
wxString R::MSG_LANG_CHANGE_DE = wxT("(Änderung erst bei Programm-Neustart wirksam)");
wxString R::MSG_LANG_CHANGE_EN = wxT("(Change only visible after program restart)");
//Nachrichten
wxString R::MSG_MINI_UNIQUE = wxT("Ein Mini muss über Name+Vorname eindeutig identifizierbar sein.");
wxString R::MSG_FEHLZEIT_UNIQUE = wxT("Diese Fehlzeit existiert bereits.");
wxString R::MSG_TIME_ERR = wxT("Bitte eine gültige Zeit im Format hh:mm angeben.");
wxString R::MSG_TIME_BEGINN_ERR = wxT("Bitte eine gültige Anfangszeit im Format hh:mm angeben.");
wxString R::MSG_TIME_ENDE_ERR = wxT("Bitte eine gültige Endzeit im Format hh:mm angeben.");
wxString R::MSG_WEEK_NUM_ERR = wxT("Bitte eine gültige Anzahl Wochen [n] angeben.");
wxString R::MSG_WEEK_COUNT_START = wxT("Bitte ein Anfangsdatum angeben, ab dem die Zählung der Wochen erfolgen soll (erster Termin ist an erstem passendem Wochentag ab [") + DATUM_BEGINN + wxT("]).");
wxString R::MSG_GROUP_NUM = wxT("Eine Gruppe sollte mindestens 2 Mitglieder haben.");
wxString R::MSG_TGROUP_NUM = wxT("Ein Verbund sollte mindestens 2 Mitglieder haben.");
wxString R::MSG_EINZEL_UNIQUE = wxT("Ein Einzeltermin muss über Ort, Datum und Zeit eindeutig identifizierbar sein.");
wxString R::MSG_SERIE_UNIQUE = wxT("Ein Serientermin muss über Ort, Zeit, Modus, Anfangs- und Enddatum eindeutig identifizierbar sein.");
wxString R::MSG_DIENST_UNIQUE = wxT("Ein Dienst muss eine eindeutige Bezeichnung haben.");
wxString R::MSG_MINI_SEL_ERR = wxT("Bitte wählen Sie einen Mini aus.");
wxString R::MSG_TERMIN_SEL_ERR = wxT("Bitte wählen Sie einen Termin aus.");
wxString R::MSG_DIENST_SEL_ERR = wxT("Bitte wählen Sie einen Dienst aus.");
wxString R::MSG_DATUM_ORDER = wxT("Das Enddatum liegt vor dem Anfangsdatum.");
wxString R::MSG_PLAN_CREATE_IMPOSSIBLE = wxT("Zu diesen Vorgaben kann leider definitiv kein Plan erstellt werden.");
wxString R::MSG_MANUAL_NOT_OPENED = wxT("Es konnte kein Programm gefunden werden, um das PDF-Handbuch unter MiniPlaner/help/Handbuch.pdf zu öffnen.");
wxString R::MSG_FILE_NOT_FOUND = wxT("Die Datei konnte nicht gefunden werden.");
wxString R::MSG_RETRIEVE_NOT_POSSIBLE = wxT("Die folgenden Einträge konnten nicht eingelesen werden");
wxString R::MSG_IMPORT_NOT_POSSIBLE = wxT("Die folgenden Einträge wurden nicht importiert, da sie bereits vorhanden sind:");
wxString R::Q_SPEICHERN = wxT("Änderungen speichern?");
wxString R::Q_LOESCHEN = wxT("Entfernen?");

void R::setLangDE() {
	//default
}

void R::setLangEN() {
	//Allgemein
	R::MINI_PLANER = wxT("MiniPlaner");
	R::DIENST_DIALOG = wxT("Ministry Dialog");
	R::MINI_DIALOG = wxT("Volunteer Dialog");
	R::EINZELTERMIN_DIALOG = wxT("Single Mass Dialog");
	R::SERIENTERMIN_DIALOG = wxT("Regular Mass Dialog");
	R::TERMIN_DIENST_DIALOG = wxT("Mass-Ministry Dialog");
	R::MGRUPPE_DIALOG = wxT("Volunteer Group Dialog");
	R::TGRUPPE_DIALOG = wxT("Mass Collection Dialog");
	R::FEHLZEIT_DIALOG = wxT("Absence Time Dialog");
	R::PLAN_DIALOG = wxT("Planner");
	R::TERMIN_DIALOG = wxT("Mass Dialog");
	R::EXPORT_LAYOUT_DIALOG = wxT("Export Layout Dialog");
	R::MINI_EXPORT_DIALOG = wxT("Volunteer Export Dialog");
	R::MINI_IMPORT_DIALOG = wxT("Volunteer Import Dialog");
	R::MINI_EXTRAS_DIALOG = wxT("Volunteer Extras Dialog");
	R::SPEICHERN_DIALOG = wxT("");
	R::LOESCHEN_DIALOG = wxT("");
	R::PLANER_SETTINGS_DIALOG = wxT("Algorithm Settings Dialog");

	R::HILFE = wxT("Help");
	R::UEBER = wxT("About");
	R::SPRACHE = wxT("Interface Language");
	R::KONTAKT_MSG = wxT("If you have questions, problems or remarks, please contact me.");
	R::SEMIKOLON = wxT("Semicolon");
	R::KOMMA = wxT("Comma");
	R::LEERZEICHEN = wxT("Space");
	R::ANDERES = wxT("Other: ");

	R::OK = wxT("OK");
	R::CANCEL = wxT("Cancel");
	R::ADD = wxT("New");
	R::DEL = wxT("Delete");
	R::EDT = wxT("Edit");
	R::JA = wxT("Yes");
	R::NEIN = wxT("No");

	R::DIENSTE = wxT("Ministries");
	R::MINI = wxT("Volunteer");
	R::MINIS = wxT("Volunteers");
	R::MGRUPPEN = wxT("Volunteer Groups");
	R::TERMINE = wxT("Masses");
	R::TGRUPPEN = wxT("Mass Collections");
	R::FEHLZEITEN = wxT("Absence Times");
	R::PLAENE = wxT("Plans");
	//Adresse
	R::STRASSE_NR = wxT("Street No.");
	R::PLZ_ORT = wxT("ZIP City");
	R::TEL = wxT("Telephone");
	R::MOBILE = wxT("Mobile");
	R::EMAIL = wxT("E-Mail");
	//Messdiener
	R::NAME = wxT("Name");
	R::NACHNAME = wxT("Surname");
	R::VORNAME = wxT("First Name");
	R::GEBURTSTAG = wxT("Birth Date");
	R::BEM = wxT("Remark");
	wxString mini_atts[] = {R::NACHNAME, R::VORNAME, R::DIENSTE, R::GEBURTSTAG, R::STRASSE_NR, R::PLZ_ORT, R::TEL, R::MOBILE, R::EMAIL, R::BEM};
	for (int i = 0; i < R::MINI_ATTS_NUM; i++) {
		R::MINI_ATTS[i] = mini_atts[i];
	}
	//Termine
	R::EINZELTERMINE = wxT("Single Masses");
	R::SERIENTERMINE = wxT("Regular Masses");
	R::ANZAHL = wxT("Amount");
	R::ORT = wxT("Place");
	R::DATUM = wxT("Date");
	R::ZEIT = wxT("Time");
	R::MODUS = wxT("Mode");
	R::DATUM_BEGINN = wxT("Beginning date (incl.)");
	R::DATUM_ENDE = wxT("End date (incl.)");
	wxString teinzel_atts[] = {R::NAME, R::ORT, R::DATUM, R::ZEIT, R::DIENSTE, R::BEM};
	for (int i = 0; i < R::TEINZEL_NUM; i++) {
		R::TEINZEL_ATTS[i] = teinzel_atts[i];
	}
	wxString tserie_atts[] = {R::NAME, R::ORT, R::MODUS, R::ZEIT, R::DIENSTE, R::DATUM_BEGINN, R::DATUM_ENDE, R::BEM};
	for (int i = 0; i < R::TSERIE_NUM; i++) {
		R::TSERIE_ATTS[i] = tserie_atts[i];
	}
	R::SONNTAG = wxT("Su.");
	R::MONTAG = wxT("Mo.");
	R::DIENSTAG = wxT("Tu.");
	R::MITTWOCH = wxT("We.");
	R::DONNERSTAG = wxT("Th.");
	R::FREITAG = wxT("Fr.");
	R::SAMSTAG = wxT("Sa.");
	wxString wochentage[] = {R::SONNTAG, R::MONTAG, R::DIENSTAG, R::MITTWOCH, R::DONNERSTAG, R::FREITAG, R::SAMSTAG};
	for (int i = 0; i < 7; i++) {
		R::WOCHENTAGE[i] = wochentage[i];
	}
	//Modus
	R::TAEGLICH = wxT("daily");
	R::WOECHENTLICH = wxT("weekly");
	R::GERADE_KW = wxT("in even weeks");
	R::UNGERADE_KW = wxT("in odd weeks");
	R::N_WOECHENTLICH = wxT("[n]-weekly from (incl.) the week after [beginning date]");
	R::W_IM_MONAT = wxT("[n-th] [weekday] in month");
	R::MONATLICH = wxT("monthly");
	wxString tmodi[] = {R::TAEGLICH, R::WOECHENTLICH, R::GERADE_KW, R::UNGERADE_KW, R::N_WOECHENTLICH, R::W_IM_MONAT, R::MONATLICH};
	for (int i = 0; i < R::TMODI_NUM; i++) {
		R::TMODI[i] = tmodi[i];
	}
	R::LETZTER = wxT("Last");
	R::VORLETZTER = wxT("Last but one");
	R::WOCHENTAG = wxT("Weekday");
	R::TAG = wxT("Day");
	R::DATUM_AB = wxT("Beginning date (incl.)");
	R::DATUM_BIS = wxT("End date (incl.)");
	//Gruppen
	R::GRUPPE = wxT("Group");
	R::RESTLISTE = wxT("Remaining volunteers");
	R::BEV_GEM = wxT("Preferably together");
	R::NUR_GEM = wxT("Exclusively together");
	wxString mgmodi[] = {R::BEV_GEM, R::NUR_GEM};
	for (int i = 0; i < 2; i++) {
		R::MGMODI[i] = mgmodi[i];
	}
	R::RESTTERMINE = wxT("Remaining masses");
	R::TGRUPPE = wxT("Collection");
	R::PERIODISCH = wxT("Weekly: 7-day-period, beginning on (incl.) ");
	R::NICHT_PERIODISCH = wxT("Non-periodic");
	wxString tgmodi[] = {R::PERIODISCH, R::NICHT_PERIODISCH};
	for (int i = 0; i < R::TGMODI_NUM; i++) {
		R::TGMODI[i] = tgmodi[i];
	}
	//Dienste
	R::DIENST = wxT("Duty");
	R::ALLGEMEIN = wxT("Normal");
	//Fehlzeiten
	R::FEHLZEIT = wxT("Absence time");
	R::ZEITRAUM = wxT("Period of time");
	R::TERMIN = wxT("Mass");
	wxString fehlzeit_modi[] = {R::ZEITRAUM, R::WOCHENTAG, R::TERMIN};
	for (int i = 0; i < 3; i++) {
		R::FEHLZEIT_MODI[i] = fehlzeit_modi[i];
	}
	R::VON = wxT("From");
	R::BIS = wxT("Until");
	//Pläne
	R::OEFFNEN = wxT("Open");
	R::ZURUECK = wxT("Back");
	R::WEITER = wxT("Continue");
	R::EINSAETZE = wxT("Assignments");
	R::MASKE = wxT("Input mask");
	R::AUTOMATISCH = wxT("Automatic");
	R::STOPPEN = wxT("Stop");
	R::LEEREN = wxT("Empty");
	R::EXPORT = wxT("Export");
	R::SPEICHERN = wxT("Save");
	R::DATEN = wxT("Data");
	R::EINSTELLUNGEN = wxT("Settings");
	R::FEHLZEITEN_ANRECHNEN = wxT("Absence times will be partially considered when running algorithm");
	R::FEHLZEITEN_KOMPENSIEREN = wxT("Absence times have to be compensated if possible");
	R::ALG_MINIMUM = wxT("Algorithm 1 (with extensive minimum search, poss. faster)");
	R::ALG_CHRONO = wxT("Algorithm 2 (poss. more evenly distributed)");
	//Export
	R::MESSDIENERPLAN = wxT("Service Plan");
	R::MESSDIENERPLAN_SH = wxT("ServicePlan");
	R::LAYOUT = wxT("Layout");
	R::VORSCHAU = wxT("Preview");
	R::MINIS_LAYOUT = wxT("Order of volunteers");
	wxString minis_layout_modi[] = {wxT("in [n] columns"), wxT("comma-separated")};
	for (int i = 0; i < 2; i++) {
		R::MINIS_LAYOUT_MODI[i] = minis_layout_modi[i];
	}
	R::BASICS_LAYOUT = wxT("Position of Mass Description");
	wxString basics_layout_modi[] = {wxT("left"), wxT("top")};
	for (int i = 0; i < 2; i++) {
		R::BASICS_LAYOUT_MODI[i] = basics_layout_modi[i];
	}
	R::NAMEN_LAYOUT = wxT("Format of Names");
	wxString namen_layout_modi[] = {wxT("First-Name Surname"), wxT("F. Surname"), wxT("F. S."), wxT("First-Name")};
	for (int i = 0; i < 4; i++) {

		R::NAMEN_LAYOUT_MODI[i] = namen_layout_modi[i];
	}
	R::DATEI_AUSGABE = wxT("Save to file");
	R::CLIPBOARD_AUSGABE = wxT("Copy to clipboard");
	R::TITEL = wxT("Title");
	R::DIENSTE_ZEIGEN = wxT("Distinguish ministries");
	R::SPEICHERN_HTML = wxT("Save as HTML");
	R::SPEICHERN_CSV = wxT("Save as CSV (tab-separated)");
	R::SPEICHERN_EXCEL_XML = wxT("Save as Excel-XML");
	R::SPALTEN = wxT("Columns");
	R::NUM = wxT("No.");
	R::MESSDIENERLISTE = wxT("Volunteer List");
	R::MESSDIENERLISTE_SH = wxT("VolunteerList");
	//Import
	R::IMPORT = wxT("Import");
	R::IMPORTIEREN = wxT("Import");
	R::SEPARATOR = wxT("Separator");
	R::CSV_DATEI_WAEHLEN = wxT("Choose CSV file");
	R::MINI_CSV_MSG = wxT("The lines of the CSV file are evaluated from left to right in the following format (entries may be empty or missing):");
	R::MINI_IMPORT_MSG = wxT("Only volunteers are imported that are not yet contained in the list by the id name + first-name.");
	//Extras
	R::EMAILS = wxT("E-Mails");
	R::KOPIERTEMAILS = wxT("copies existing e-mail addresses to clipboard");
	R::ADRESSEN = wxT("Addresses");
	R::KOPIERTADRESSEN = wxT("copies formated list of existing addresses to clipboard");
	R::KOPIERTEMAILSFERTIG = wxT("E-mail addresses copied to clipboard!");
	R::KOPIERTADRESSENFERTIG = wxT("Addresses copied to clipboard!");
	R::KOPIERTWARNICHTMOEGLICH = wxT("\nFailed doing the following volunteers:\n");
	//Über
	R::HEADLINE = wxT("a small program to efficiently create high-quality service plans");
	R::AUTOR = wxT("Author: ");
	R::BEITRAGENDE = wxT("Contributors: ");
	R::KOMPILIERTMIT = wxT("Compiled with: ");
	R::BIBLIOTHEKEN = wxT("Libraries: ");
	R::INSTALLATIONSVERZEICHNIS = wxT("Installation directory: ");

	//Einstellungen

	//Nachrichten
	R::MSG_MINI_UNIQUE = wxT("A volunteer must be uniquely identifiable by name + first-name.");
	R::MSG_FEHLZEIT_UNIQUE = wxT("This absence time already exists.");
	R::MSG_TIME_ERR = wxT("Please enter a valid time in the format hh:mm.");
	R::MSG_TIME_BEGINN_ERR = wxT("Please enter a valid beginning time in the format hh:mm.");
	R::MSG_TIME_ENDE_ERR = wxT("Please enter a valid end time in the format hh:mm.");
	R::MSG_WEEK_NUM_ERR = wxT("Please enter a valid amount of weeks [n].");
	R::MSG_WEEK_COUNT_START = wxT("Please enter a beginning time from which the weeks shall be counted (first mass is on first fitting weekday after [") + R::DATUM_BEGINN + wxT("]).");
	R::MSG_GROUP_NUM = wxT("A group should contain at least 2 members.");
	R::MSG_TGROUP_NUM = wxT("A collection should contain at least 2 members.");
	R::MSG_EINZEL_UNIQUE = wxT("A single mass must be uniquely identifiable by place, date and time.");
	R::MSG_SERIE_UNIQUE = wxT("A regular mass must be uniquely identifiable by place, time, mode, beginning and end date.");
	R::MSG_DIENST_UNIQUE = wxT("A ministry must have a unique name.");
	R::MSG_MINI_SEL_ERR = wxT("Please select a volunteer.");
	R::MSG_TERMIN_SEL_ERR = wxT("Please select a mass.");
	R::MSG_DIENST_SEL_ERR = wxT("Please select a ministry.");
	R::MSG_DATUM_ORDER = wxT("The end date is before the beginning date.");
	R::MSG_PLAN_CREATE_IMPOSSIBLE = wxT("Unfortunately, it is impossible to create a plan given these requirements.");
	R::MSG_MANUAL_NOT_OPENED = wxT("Could not find a program to open the PDF handbook under MiniPlaner/help/Handbuch.pdf.");
	R::MSG_FILE_NOT_FOUND = wxT("File not found.");
	R::Q_SPEICHERN = wxT("Save changes?");
	R::Q_LOESCHEN = wxT("Delete?");
}

void R::setLang() {
	if (R::lang == R::LANG_DE) {
		setLangDE();
	} else {
		setLangEN();
	}
}

int R::lang = R::LANG_DE;

void R::setSubWindowPosition(wxWindow* parent, wxDialog* self) {
	wxPoint parent_point = parent->GetScreenPosition();
	wxSize parent_size = parent->GetSize();
	wxSize own_size = self->GetSize();
	self->SetPosition(wxPoint(parent_point.x + parent_size.x - own_size.x - 150, parent_point.y + 30));
}

const int R::VERSION_NUMBER = 4;//need number for comparison

wxString R::window_size = wxT("");

===== ./src/file/PlanFileHandler.h =====
/* 
 * File:   PlanFileHandler.h
 * Author: Yannik
 *
 * Created on August 27, 2015, 9:06 PM
 */

#ifndef PLANFILEHANDLER_H
#define	PLANFILEHANDLER_H

#include "DataFileHandler.h"
#include "../model-plan/Planer.h"
#include "../model-plan/PlanerInfo.h"
#include "../controller-plan/PlanerController.h"

namespace PlanFileHandler {
	extern const wxString RES;
	extern const wxString D;
	extern const wxString DIENSTEFILE;
	extern const wxString MINISFILE;
	extern const wxString TERMINEFILE;
	extern const wxString MGRUPPENFILE;
	extern const wxString FEHLZEITENFILE;
	extern const wxString SETTINGSFILE;
	extern PlanerInfo createDir(wxDateTime datum_beginn, wxDateTime datum_ende);
	extern void deleteDir(PlanerInfo info);
	extern void savePlaner(Planer* planer);
	extern void loadPlaner(Planer* planer);
};

#endif	/* PLANFILEHANDLER_H */

===== ./src/file/DataFileHandler.h =====
/* 
 * File:   DataFileHandler.h
 * Author: Yannik
 *
 * Created on August 11, 2015, 4:44 PM
 */

#ifndef DATAFILEHANDLER_H
#define	DATAFILEHANDLER_H

#include <wx/wx.h>
#include <vector>
#include "../model-data/Dienst.h"
#include "../model-data/Messdiener.h"
#include "../model-data/Einzeltermin.h"
#include "../model-data/Serientermin.h"
#include "../model-data/MGruppe.h"
#include "../model-data/TGruppe.h"
#include "../model-data/Fehlzeit.h"
#include "../model-plan/PlanerInfo.h"

namespace DataFileHandler {
	extern const wxString RES;
	extern const wxString D;
	extern const wxString SETTINGSFILE;
	extern const wxString DIENSTEFILE;
	extern const wxString MINISFILE;
	extern const wxString EINZELTERMINEFILE;
	extern const wxString SERIENTERMINEFILE;
	extern const wxString MGRUPPENFILE;
	extern const wxString TGRUPPENFILE;
	extern const wxString FEHLZEITENFILE;
	extern const wxString PLANERINFOSFILE;
	extern void prepareFiles();
	extern void implementUpdates();
	extern void saveSettings();
	extern void loadSettings();
	extern void saveDienste(const std::vector<Dienst*>* list);
	extern void loadDienste(std::vector<Dienst*>* list);
	extern void saveMinis(const std::vector<Messdiener*>* list);
	extern void loadMinis(std::vector<Dienst*>* dlist, std::vector<Messdiener*>* list);
	extern void saveEinzeltermine(const std::vector<Einzeltermin*>* list);
	extern void loadEinzeltermine(std::vector<Dienst*>* dlist, std::vector<Einzeltermin*>* list);
	extern void saveSerientermine(const std::vector<Serientermin*>* list);
	extern void loadSerientermine(std::vector<Dienst*>* dlist, std::vector<Serientermin*>* list);
	extern void saveMGruppen(const std::vector<MGruppe*>* list);
	extern void loadMGruppen(std::vector<Messdiener*>* mlist, std::vector<MGruppe*>* list);
	extern void saveTGruppen(const std::vector<TGruppe*>* list);
	extern void loadTGruppen(std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist, std::vector<TGruppe*>* list);
	extern void saveFehlzeiten(const std::vector<Fehlzeit*>* list);
	extern void loadFehlzeiten(std::vector<Messdiener*>* mlist, std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist, std::vector<Fehlzeit*>* list);
	extern void savePlanerInfos(std::vector<PlanerInfo>* list);
	extern void loadPlanerInfos(std::vector<PlanerInfo>* list);
};

#endif	/* DATAFILEHANDLER_H */

===== ./src/file/PlanFileHandler.cpp =====
/* 
 * File:   PlanFileHandler.cpp
 * Author: Yannik
 * 
 * Created on August 27, 2015, 9:06 PM
 */

#include "PlanFileHandler.h"
#include <wx/textfile.h>
#include <wx/dir.h>
#include <wx/filename.h>
#include <wx/tokenzr.h>
#include "DataFileHandler.h"
#include "../Util.h"

const wxString PlanFileHandler::RES = wxT("res");
const wxString PlanFileHandler::D = wxT("\t");
const wxString PlanFileHandler::DIENSTEFILE = wxT("/dienste.dat");
const wxString PlanFileHandler::MINISFILE = wxT("/minis.dat");
const wxString PlanFileHandler::TERMINEFILE = wxT("/termine.dat");
const wxString PlanFileHandler::MGRUPPENFILE = wxT("/mgruppen.dat");
const wxString PlanFileHandler::FEHLZEITENFILE = wxT("/fehlzeiten.dat");
const wxString PlanFileHandler::SETTINGSFILE = wxT("/settings.dat");

PlanerInfo PlanFileHandler::createDir(wxDateTime datum_beginn, wxDateTime datum_ende) {
	wxString base = datum_beginn.Format(wxT("%Y-%m-%d")) + wxT("_") + datum_ende.Format(wxT("%Y-%m-%d"));
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	if (wxDir::Exists(RES + wxT("/") + base)) {
		int counter = 2;
		while (wxDir::Exists(RES + wxT("/") + base + wxString::Format(wxT("(%i)"), counter))) {
			counter++;
		}
		wxDir::Make(RES + wxT("/") + base + wxString::Format(wxT("(%i)"), counter));
		return PlanerInfo(datum_beginn, datum_ende, counter);
	} else {
		wxDir::Make(RES + wxT("/") + base);
		return PlanerInfo(datum_beginn, datum_ende, 1);
	}
}

void PlanFileHandler::deleteDir(PlanerInfo info) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	} else {
		wxString dir = RES + wxT("/") + info.getDir();
		wxDir::Remove(dir, wxPATH_RMDIR_RECURSIVE);
	}
}

void PlanFileHandler::savePlaner(Planer* planer) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxString base = RES + wxT("/") + planer->getDir();
	if (!wxDir::Exists(base)) {
		wxDir::Make(base);
	}
	//save Dienste
	wxTextFile dienste_file(base + DIENSTEFILE);
	if (!dienste_file.Exists()) {
		dienste_file.Create();
	}
	dienste_file.Open();
	dienste_file.Clear();
	for (int i = 0; i < (int) planer->list_dienst.size(); i++) {
		Dienst d = *(planer->list_dienst.at(i));
		dienste_file.AddLine(d.name);
	}
	dienste_file.Write();
	dienste_file.Close();
	//save Termine
	wxTextFile termine_file(base + TERMINEFILE);
	if (!termine_file.Exists()) {
		termine_file.Create();
	}
	termine_file.Open();
	termine_file.Clear();
	for (int i = 0; i < (int) planer->list_termin.size(); i++) {
		PTermin t = *(planer->list_termin.at(i));
		wxString line = t.name + D + t.ort + D + Util::wxDateTime_to_wxString(t.datum) + D + t.zeit_beginn + D
				+ (t.prev == NULL ? wxT("-1") : wxString::Format(wxT("%i"), t.prev->_id)) + D
				+ (t.next == NULL ? wxT("-1") : wxString::Format(wxT("%i"), t.next->_id)) + D
				+ t.bem;
		termine_file.AddLine(line);
		line = wxString::Format(wxT("%zu"), t.list_dienst_num.size());
		termine_file.AddLine(line); //Anzahl Dienste, gleich für alle Listen
		for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter = t.list_dienst_minis.begin(); iter != t.list_dienst_minis.end(); iter++) {
			line = wxString::Format(wxT("%i"), iter->first->_id);
			for (std::vector<PMessdiener*>::iterator iter_m = iter->second.begin(); iter_m != iter->second.end(); iter_m++) {
				line += D + (*iter_m == NULL ? wxT("-1") : wxString::Format(wxT("%i"), (**iter_m)._id));
			}
			termine_file.AddLine(line);
		}
		for (std::vector<std::pair<Dienst*, int> >::iterator iter = t.list_dienst_num.begin(); iter != t.list_dienst_num.end(); iter++) {
			line = wxString::Format(wxT("%i"), iter->first->_id) + D + wxString::Format(wxT("%i"), iter->second);
			termine_file.AddLine(line);
		}
		for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter = t.list_dienst_minis_possible.begin(); iter != t.list_dienst_minis_possible.end(); iter++) {
			line = wxString::Format(wxT("%i"), iter->first->_id);
			for (std::vector<PMessdiener*>::iterator iter_m = iter->second.begin(); iter_m != iter->second.end(); iter_m++) {
				line += D + wxString::Format(wxT("%i"), (**iter_m)._id);
			}
			termine_file.AddLine(line);
		}
		for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter = t.list_dienst_minis_available.begin(); iter != t.list_dienst_minis_available.end(); iter++) {
			line = wxString::Format(wxT("%i"), iter->first->_id);
			for (std::vector<PMessdiener*>::iterator iter_m = iter->second.begin(); iter_m != iter->second.end(); iter_m++) {
				line += D + wxString::Format(wxT("%i"), (**iter_m)._id);
			}
			termine_file.AddLine(line);
		}
	}
	termine_file.Write();
	termine_file.Close();
	//save Minis
	wxTextFile minis_file(base + MINISFILE);
	if (!minis_file.Exists()) {
		minis_file.Create();
	}
	minis_file.Open();
	minis_file.Clear();
	for (int i = 0; i < (int) planer->list_mini.size(); i++) {
		PMessdiener m = *(planer->list_mini.at(i));
		wxString line = m.name + D + m.vorname + D + wxString::Format(wxT("%i"), m.num);
		for (std::vector<Dienst*>::iterator iter_d = m.dienste.begin(); iter_d != m.dienste.end(); iter_d++) {
			line += D + wxString::Format(wxT("%i"), (**iter_d)._id);
		}
		minis_file.AddLine(line);
	}
	minis_file.Write();
	minis_file.Close();
	//save MGruppen
	wxTextFile mgruppen_file(base + MGRUPPENFILE);
	if (!mgruppen_file.Exists()) {
		mgruppen_file.Create();
	}
	mgruppen_file.Open();
	mgruppen_file.Clear();
	for (int i = 0; i < (int) planer->list_mgruppe.size(); i++) {
		PMGruppe mg = *(planer->list_mgruppe.at(i));
		wxString line = wxString::Format(wxT("%i"), mg.modus);
		for (std::vector<PMessdiener*>::iterator iter_m = mg.list.begin(); iter_m != mg.list.end(); iter_m++) {
			line += D + wxString::Format(wxT("%i"), (**iter_m)._id);
		}
		mgruppen_file.AddLine(line);
	}
	mgruppen_file.Write();
	mgruppen_file.Close();
	//save Fehlzeiten
	wxTextFile fehlzeiten_file(base + FEHLZEITENFILE);
	if (!fehlzeiten_file.Exists()) {
		fehlzeiten_file.Create();
	}
	fehlzeiten_file.Open();
	fehlzeiten_file.Clear();
	int num_fehlzeiten = planer->list_fehlzeit.size();
	for (int i = 0; i < num_fehlzeiten; i++) {
		PFehlzeit* f = planer->list_fehlzeit.at(i);
		wxString line = wxString::Format(wxT("%i"), Fehlzeit::ZEITRAUM) + D + wxString::Format(wxT("%i"), f->mini->_id)
				+ D + Util::wxDateTime_to_wxString(f->datum_beginn)
				+ D + Util::wxDateTime_to_wxString(f->datum_ende);
		fehlzeiten_file.AddLine(line);
	}
	fehlzeiten_file.Write();
	fehlzeiten_file.Close();
	//save Settings
	wxTextFile settings_file(base + SETTINGSFILE);
	if (!settings_file.Exists()) {
		settings_file.Create();
	}
	settings_file.Open();
	settings_file.Clear();
	wxString line = wxString::Format(wxT("%i"), planer->settings.modus_fehlzeiten) + D + wxString::Format(wxT("%i"), planer->settings.modus_algorithmus);
	settings_file.AddLine(line);
	settings_file.Write();
	settings_file.Close();
}

void PlanFileHandler::loadPlaner(Planer* planer) {
	wxString base = RES + wxT("/") + planer->getDir();
	//load Dienste
	planer->list_dienst.clear();
	wxTextFile dienste_file(base + DIENSTEFILE);
	dienste_file.Open();
	for (wxString line = dienste_file.GetFirstLine(); !dienste_file.Eof(); line = dienste_file.GetNextLine()) {
		planer->list_dienst.push_back(new Dienst(line));
	}
	dienste_file.Close();
	//load Minis
	planer->list_mini.clear();
	wxTextFile minis_file(base + MINISFILE);
	minis_file.Open();
	for (wxString line = minis_file.GetFirstLine(); !minis_file.Eof(); line = minis_file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		wxString name = zr.NextToken();
		wxString vorname = zr.NextToken();
		int num = wxAtoi(zr.NextToken());
		std::vector<Dienst*> mdlist;
		while (zr.HasMoreTokens()) {
			int d = wxAtoi(zr.NextToken());
			mdlist.push_back(planer->list_dienst.at(d));
		}
		planer->list_mini.push_back(new PMessdiener(name, vorname, mdlist, num));
	}
	minis_file.Close();
	//load MGruppen
	planer->list_mgruppe.clear();
	wxTextFile mgruppen_file(base + MGRUPPENFILE);
	mgruppen_file.Open();
	for (wxString line = mgruppen_file.GetFirstLine(); !mgruppen_file.Eof(); line = mgruppen_file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		int modus = wxAtoi(zr.NextToken());
		std::vector<PMessdiener*> mlist;
		while (zr.HasMoreTokens()) {
			mlist.push_back(planer->list_mini.at(wxAtoi(zr.NextToken())));
		}
		planer->list_mgruppe.push_back(new PMGruppe(modus, mlist));
	}
	mgruppen_file.Close();
	//set missing links Minis-MGruppen
	for (std::vector<PMGruppe*>::iterator iter = planer->list_mgruppe.begin(); iter != planer->list_mgruppe.end(); iter++) {
		for (std::vector<PMessdiener*>::iterator iter_m = (**iter).list.begin(); iter_m != (**iter).list.end(); iter_m++) {
			(**iter_m).gruppe = *iter;
		}
	}
	//load Fehlzeiten
	wxTextFile fehlzeiten_file(base + FEHLZEITENFILE);
	fehlzeiten_file.Open();
	for (wxString line = fehlzeiten_file.GetFirstLine(); !fehlzeiten_file.Eof(); line = fehlzeiten_file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		zr.NextToken(); //Modus
		PMessdiener* m = planer->list_mini.at(wxAtoi(zr.NextToken()));
		wxDateTime datum_beginn = Util::wxString_to_wxDateTime(zr.NextToken());
		wxDateTime datum_ende = Util::wxString_to_wxDateTime(zr.NextToken());
		planer->list_fehlzeit.push_back(new PFehlzeit(m, datum_beginn, datum_ende));
	}
	fehlzeiten_file.Close();
	//load Settings
	wxTextFile settings_file(base + SETTINGSFILE);
	settings_file.Open();
	wxString line_settings = settings_file.GetFirstLine();
	wxStringTokenizer zr(line_settings, D, wxTOKEN_RET_EMPTY_ALL);
	planer->settings.modus_fehlzeiten = wxAtoi(zr.NextToken());
	planer->settings.modus_algorithmus = wxAtoi(zr.NextToken());
	settings_file.Close();
	//load Termine
	std::vector<std::pair<int, std::pair<int, int> > > termin_prev_next;
	planer->list_termin.clear();
	wxTextFile termine_file(base + TERMINEFILE);
	termine_file.Open();
	wxString line = termine_file.GetFirstLine();
	int t_counter = 0;
	while (!termine_file.Eof()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		wxString name = zr.NextToken();
		wxString ort = zr.NextToken();
		wxDateTime datum = Util::wxString_to_wxDateTime(zr.NextToken());
		wxString zeit_beginn = zr.NextToken();
		int prev = wxAtoi(zr.NextToken());
		int next = wxAtoi(zr.NextToken());
		termin_prev_next.push_back(std::make_pair(t_counter++, std::make_pair(prev, next)));
		wxString bem = zr.NextToken();
		line = termine_file.GetNextLine();
		int num_dienste = wxAtoi(line);
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_mini;
		std::vector<std::pair<Dienst*, int> > list_num;
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_poss;
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_avai;
		for (int i = 0; i < num_dienste; i++) {
			line = termine_file.GetNextLine();
			wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
			Dienst* d = planer->list_dienst.at(wxAtoi(zr.NextToken()));
			std::vector<PMessdiener*> mset;
			while (zr.HasMoreTokens()) {
				int m_index = wxAtoi(zr.NextToken());
				mset.push_back(m_index == -1 ? NULL : planer->list_mini.at(m_index));
			}
			list_mini.push_back(std::make_pair(d, mset));
		}
		for (int i = 0; i < num_dienste; i++) {
			line = termine_file.GetNextLine();
			wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
			Dienst* d = planer->list_dienst.at(wxAtoi(zr.NextToken()));
			int num = wxAtoi(zr.NextToken());
			list_num.push_back(std::make_pair(d, num));
		}
		for (int i = 0; i < num_dienste; i++) {
			line = termine_file.GetNextLine();
			wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
			Dienst* d = planer->list_dienst.at(wxAtoi(zr.NextToken()));
			std::vector<PMessdiener*> mset;
			while (zr.HasMoreTokens()) {
				mset.push_back(planer->list_mini.at(wxAtoi(zr.NextToken())));
			}
			list_poss.push_back(std::make_pair(d, mset));
		}
		for (int i = 0; i < num_dienste; i++) {
			line = termine_file.GetNextLine();
			wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
			Dienst* d = planer->list_dienst.at(wxAtoi(zr.NextToken()));
			std::vector<PMessdiener*> mset;
			while (zr.HasMoreTokens()) {
				mset.push_back(planer->list_mini.at(wxAtoi(zr.NextToken())));
			}
			list_avai.push_back(std::make_pair(d, mset));
		}
		PTermin* termin = new PTermin(name, ort, datum, zeit_beginn, bem, list_num);
		termin->list_dienst_minis = list_mini;
		termin->list_dienst_minis_possible = list_poss;
		termin->list_dienst_minis_available = list_avai;

		planer->list_termin.push_back(termin);
		line = termine_file.GetNextLine();
	}
	//set links prev-next
	for (std::vector<std::pair<int, std::pair<int, int> > >::iterator iter_t = termin_prev_next.begin(); iter_t != termin_prev_next.end(); iter_t++) {
		if (iter_t->second.first != -1) {
			planer->list_termin.at(iter_t->first)->prev = planer->list_termin.at(iter_t->second.first);
		}
		if (iter_t->second.second != -1) {
			planer->list_termin.at(iter_t->first)->next = planer->list_termin.at(iter_t->second.second);
		}
	}
	termine_file.Close();
	//prepare ids
	int counter = 0;
	for (std::vector<Dienst*>::iterator iter = planer->list_dienst.begin(); iter != planer->list_dienst.end(); iter++) {
		(**iter)._id = counter++;
	}
	counter = 0;
	for (std::vector<PMessdiener*>::iterator iter = planer->list_mini.begin(); iter != planer->list_mini.end(); iter++) {
		(**iter)._id = counter++;
	}
	counter = 0;
	for (std::vector<PMGruppe*>::iterator iter = planer->list_mgruppe.begin(); iter != planer->list_mgruppe.end(); iter++) {
		(**iter)._id = counter++;
	}
	counter = 0;
	for (std::vector<PTermin*>::iterator iter = planer->list_termin.begin(); iter != planer->list_termin.end(); iter++) {
		(**iter)._id = counter++;
	}
	counter = 0;
	for (std::vector<PFehlzeit*>::iterator iter = planer->list_fehlzeit.begin(); iter != planer->list_fehlzeit.end(); iter++) {
		(**iter)._id = counter++;
	}
}

===== ./src/file/DataFileHandler.cpp =====
/* 
 * File:   DataFileHandler.cpp
 * Author: Yannik
 * 
 * Created on August 11, 2015, 4:44 PM
 */

#include "DataFileHandler.h"
#include <wx/wx.h>
#include <wx/textfile.h>
#include <wx/dir.h>
#include <wx/tokenzr.h>
#include <wx/string.h>
#include <wx/datetime.h>
#include <vector>
#include "../R.h"
#include "../Util.h"

const wxString DataFileHandler::RES = wxT("res");
const wxString DataFileHandler::D = wxT("\t");
const wxString DataFileHandler::SETTINGSFILE = RES + wxT("/settings.dat");
const wxString DataFileHandler::DIENSTEFILE = RES + wxT("/dienste.dat");
const wxString DataFileHandler::MINISFILE = RES + wxT("/minis.dat");
const wxString DataFileHandler::EINZELTERMINEFILE = RES + wxT("/einzeltermine.dat");
const wxString DataFileHandler::SERIENTERMINEFILE = RES + wxT("/serientermine.dat");
const wxString DataFileHandler::MGRUPPENFILE = RES + wxT("/mgruppen.dat");
const wxString DataFileHandler::TGRUPPENFILE = RES + wxT("/tgruppen.dat");
const wxString DataFileHandler::FEHLZEITENFILE = RES + wxT("/fehlzeiten.dat");
const wxString DataFileHandler::PLANERINFOSFILE = RES + wxT("/plaene.dat");

void DataFileHandler::prepareFiles() {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxString filenames[] = {SETTINGSFILE,
		DIENSTEFILE,
		MINISFILE,
		EINZELTERMINEFILE,
		SERIENTERMINEFILE,
		MGRUPPENFILE,
		TGRUPPENFILE,
		FEHLZEITENFILE,
		PLANERINFOSFILE};
	int len = sizeof (filenames) / sizeof (wxString);
	for (int i = 0; i < len; i++) {
		wxTextFile file(filenames[i]);
		if (!file.Exists()) {
			file.Create();
		}
	}
}

void DataFileHandler::implementUpdates() {
	wxTextFile file(MINISFILE);
	file.Open();
	int lines = file.GetLineCount();
	if (lines > 0) {
		wxString line = file.GetFirstLine();
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		bool hasVersion = (zr.CountTokens() == 1) ? true : false;
		//exactly 1 token : is the version line (otherwise 0 or >1 tokens as every mini has > 7 attributes)
		if (!hasVersion) {//implement mini.bem (before there was no version)
			std::vector<std::vector<wxString> > items;
			for (; !file.Eof(); line = file.GetNextLine()) {
				std::vector<wxString> item;
				wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
				for (int i = 0; i < 8; i++) item.push_back(zr.NextToken());
				item.push_back(wxT(""));
				while (zr.HasMoreTokens()) item.push_back(zr.NextToken());
				items.push_back(item);
			}
			file.Clear();
			file.AddLine(wxString::Format(wxT("%i"), R::VERSION_NUMBER));
			int num = items.size();
			for (int i = 0; i < num; i++) {
				std::vector<wxString> item = items.at(i);
				int num2 = item.size();
				wxString line = wxT("");
				for (int j = 0; j < num2 - 1; j++) {
					line += item.at(j) + D;
				}
				line += item.at(num2 - 1);
				file.AddLine(line);
			}
			file.Write();
		}
	} else {//is empty file, insert version
		file.AddLine(wxString::Format(wxT("%i"), R::VERSION_NUMBER));
		file.Write();
	}
	file.Close();
}

void DataFileHandler::saveSettings() {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(SETTINGSFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	file.AddLine(R::window_size);
	file.AddLine(wxString::Format(wxT("%i"), R::lang));
	file.Write();
	file.Close();
}

void DataFileHandler::loadSettings() {
	wxTextFile file(SETTINGSFILE);
	file.Open();
	//depending on version, different file sizes are possible
	int num_lines = file.GetLineCount();
	//main window size
	if (num_lines > 0) {
		R::window_size = file.GetLine(0);
	}
	//language
	if (num_lines > 1) {
		R::lang = wxAtoi(file.GetLine(1));
	} else {
		int lang = wxLocale::GetSystemLanguage();
		if (lang == wxLANGUAGE_GERMAN
				|| lang == wxLANGUAGE_GERMAN_AUSTRIAN
				|| lang == wxLANGUAGE_GERMAN_BELGIUM
				|| lang == wxLANGUAGE_GERMAN_LIECHTENSTEIN
				|| lang == wxLANGUAGE_GERMAN_LUXEMBOURG
				|| lang == wxLANGUAGE_GERMAN_SWISS) {
			R::lang = R::LANG_DE;
		} else {
			R::lang = R::LANG_EN; //until language selectable
		}
	}
	file.Close();

	//set language
	R::setLang();
}

void DataFileHandler::saveDienste(const std::vector<Dienst*>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(DIENSTEFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	for (int i = 0; i < (int) list->size(); i++) {
		Dienst d = *(list->at(i));
		file.AddLine(d.name);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadDienste(std::vector<Dienst*>* list) {
	wxTextFile file(DIENSTEFILE);
	file.Open();
	for (wxString line = file.GetFirstLine(); !file.Eof(); line = file.GetNextLine()) {
		list->push_back(new Dienst(line));
	}
	if (list->empty()) {
		if (R::lang == R::LANG_DE)
			list->push_back(new Dienst(R::ALLGEMEIN));
		else {
			list->push_back(new Dienst(wxT("Altar Server")));
		}
	}
	file.Close();
}

void DataFileHandler::saveMinis(const std::vector<Messdiener*>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(MINISFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	file.AddLine(wxString::Format(wxT("%i"), R::VERSION_NUMBER));
	for (int i = 0; i < (int) list->size(); i++) {
		Messdiener m = *(list->at(i));
		wxString line = m.name + D + m.vorname + D + m.geburtstag + D
				+ m.strasse_nr + D + m.plz_ort + D + m.tel + D + m.mobile + D + m.email + D + m.bem;
		int msize = m.dienste.size();
		for (int j = 0; j < msize; j++) {
			line += D + wxString::Format(wxT("%i"), (*(m.dienste.at(j)))._id);
		}
		file.AddLine(line);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadMinis(std::vector<Dienst*>* dlist, std::vector<Messdiener*>* list) {
	wxTextFile file(MINISFILE);
	file.Open();
	int lines = file.GetLineCount();
	wxString line = file.GetFirstLine();
	if (lines > 1) {
		line = file.GetNextLine(); //first line: version
		for (; !file.Eof(); line = file.GetNextLine()) {
			wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
			wxString name = zr.NextToken();
			wxString vorname = zr.NextToken();
			wxString geburtstag = zr.NextToken();
			wxString strasse_nr = zr.NextToken();
			wxString plz_ort = zr.NextToken();
			wxString tel = zr.NextToken();
			wxString mobile = zr.NextToken();
			wxString email = zr.NextToken();
			wxString bem = zr.NextToken();
			std::vector<Dienst*> mdlist;
			while (zr.HasMoreTokens()) {
				int d = wxAtoi(zr.NextToken());
				mdlist.push_back(dlist->at(d));
			}
			list->push_back(new Messdiener(name, vorname, mdlist, geburtstag, strasse_nr, plz_ort, tel, mobile, email, bem));
		}
	}
	file.Close();
}

void DataFileHandler::saveEinzeltermine(const std::vector<Einzeltermin*>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(EINZELTERMINEFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	for (int i = 0; i < (int) list->size(); i++) {
		Einzeltermin t = *(list->at(i));
		wxString line = t.name + D + t.ort + D + t.datum + D + t.zeit_beginn + D + t.bem;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter = t.dienste.begin(); iter != t.dienste.end(); iter++) {
			line += D + wxString::Format(wxT("%i"), iter->first->_id) + D + wxString::Format(wxT("%i"), iter->second);
		}
		file.AddLine(line);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadEinzeltermine(std::vector<Dienst*>* dlist, std::vector<Einzeltermin*>* list) {
	wxTextFile file(EINZELTERMINEFILE);
	file.Open();
	wxString line = file.GetFirstLine();
	for (; !file.Eof(); line = file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		wxString name = zr.NextToken();
		wxString ort = zr.NextToken();
		wxString datum = zr.NextToken();
		wxString zeit_beginn = zr.NextToken();
		wxString bem = zr.NextToken();
		std::vector< std::pair<Dienst*, int> > tdlist;
		while (zr.HasMoreTokens()) {
			int d = wxAtoi(zr.NextToken());
			tdlist.push_back(std::make_pair(dlist->at(d), wxAtoi(zr.NextToken())));
		}
		list->push_back(new Einzeltermin(name, ort, datum, zeit_beginn, tdlist, bem));
	}
	file.Close();
}

void DataFileHandler::saveSerientermine(const std::vector<Serientermin*>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(SERIENTERMINEFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	for (int i = 0; i < (int) list->size(); i++) {
		Serientermin t = *(list->at(i));
		wxString line = t.name + D + t.ort + D + wxString::Format(wxT("%i"), t.modus)
				+ D + wxString::Format(wxT("%i"), t.wochentag) + D + wxString::Format(wxT("%i"), t.n)
				+ D + t.zeit_beginn + D + t.datum_beginn + D + t.datum_ende + D + t.bem;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter = t.dienste.begin(); iter != t.dienste.end(); iter++) {
			line += D + wxString::Format(wxT("%i"), iter->first->_id) + D + wxString::Format(wxT("%i"), iter->second);
		}
		file.AddLine(line);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadSerientermine(std::vector<Dienst*>* dlist, std::vector<Serientermin*>* list) {
	wxTextFile file(SERIENTERMINEFILE);
	file.Open();
	wxString line = file.GetFirstLine();
	for (; !file.Eof(); line = file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		wxString name = zr.NextToken();
		wxString ort = zr.NextToken();
		int modus = wxAtoi(zr.NextToken());
		int wochentag = wxAtoi(zr.NextToken());
		int n = wxAtoi(zr.NextToken());
		wxString zeit_beginn = zr.NextToken();
		wxString datum_beginn = zr.NextToken();
		wxString datum_ende = zr.NextToken();
		wxString bem = zr.NextToken();
		std::vector< std::pair<Dienst*, int> > tdlist;
		while (zr.HasMoreTokens()) {
			int d = wxAtoi(zr.NextToken());
			tdlist.push_back(std::make_pair(dlist->at(d), wxAtoi(zr.NextToken())));
		}
		list->push_back(new Serientermin(name, ort, tdlist, zeit_beginn, datum_beginn, datum_ende, modus, wochentag, n, bem));
	}
	file.Close();
}

void DataFileHandler::saveMGruppen(const std::vector<MGruppe*>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(MGRUPPENFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	for (int i = 0; i < (int) list->size(); i++) {
		MGruppe mg = *(list->at(i));
		wxString line = wxString::Format(wxT("%i"), mg.modus);
		for (std::vector<Messdiener*>::iterator iter = mg.list.begin(); iter != mg.list.end(); iter++) {
			line += D + wxString::Format(wxT("%i"), (**iter)._id);
		}
		file.AddLine(line);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadMGruppen(std::vector<Messdiener*>* mlist, std::vector<MGruppe*>* list) {
	wxTextFile file(MGRUPPENFILE);
	file.Open();
	wxString line = file.GetFirstLine();
	for (; !file.Eof(); line = file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		int modus = wxAtoi(zr.NextToken());
		//Create MGruppe with correct indices
		std::vector<Messdiener*> gmlist;
		while (zr.HasMoreTokens()) {
			int m = wxAtoi(zr.NextToken());
			gmlist.push_back(mlist->at(m));
		}
		list->push_back(new MGruppe(modus, gmlist));
	}
	file.Close();
}

void DataFileHandler::saveTGruppen(const std::vector<TGruppe*>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(TGRUPPENFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	for (int i = 0; i < (int) list->size(); i++) {
		TGruppe tg = *(list->at(i));
		wxString line = wxString::Format(wxT("%i"), tg.wochentag);
		file.AddLine(line);
		line = wxT("");
		for (std::vector<Einzeltermin*>::iterator iter = tg.list_einzel.begin(); iter != tg.list_einzel.end(); iter++) {
			line += wxString::Format(wxT("%i"), (**iter)._id);
			if ((iter + 1) != tg.list_einzel.end()) {
				line += D;
			}
		}
		file.AddLine(line);
		line = wxT("");
		for (std::vector<Serientermin*>::iterator iter = tg.list_serie.begin(); iter != tg.list_serie.end(); iter++) {
			line += wxString::Format(wxT("%i"), (**iter)._id);
			if ((iter + 1) != tg.list_serie.end()) {
				line += D;
			}
		}
		file.AddLine(line);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadTGruppen(std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist, std::vector<TGruppe*>* list) {
	wxTextFile file(TGRUPPENFILE);
	file.Open();
	wxString line = file.GetFirstLine();
	for (; !file.Eof(); line = file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		int wochentag = wxAtoi(zr.NextToken());
		line = file.GetNextLine();
		std::vector<Einzeltermin*> gelist;
		wxStringTokenizer zr2(line, D, wxTOKEN_RET_EMPTY_ALL);
		while (zr2.HasMoreTokens()) {
			int e = wxAtoi(zr2.NextToken());
			gelist.push_back(elist->at(e));
		}
		line = file.GetNextLine();
		std::vector<Serientermin*> gslist;
		wxStringTokenizer zr3(line, D, wxTOKEN_RET_EMPTY_ALL);
		while (zr3.HasMoreTokens()) {
			int s = wxAtoi(zr3.NextToken());
			gslist.push_back(slist->at(s));
		}
		list->push_back(new TGruppe(wochentag, gelist, gslist));
	}
	file.Close();
}

void DataFileHandler::saveFehlzeiten(const std::vector<Fehlzeit*>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(FEHLZEITENFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	for (int i = 0; i < (int) list->size(); i++) {
		Fehlzeit f = *(list->at(i));
		wxString line = wxString::Format(wxT("%i"), f.modus) + D + wxString::Format(wxT("%i"), f.wochentag)
				+ D + f.beginn + D + f.ende + D + wxString::Format(wxT("%i"), f.mini->_id);
		if (f.modus == Fehlzeit::EINZELTERMIN) {
			line += D + wxString::Format(wxT("%i"), f.einzeltermin->_id);
		} else if (f.modus == Fehlzeit::SERIENTERMIN) {
			line += D + wxString::Format(wxT("%i"), f.serientermin->_id);
		}
		file.AddLine(line);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadFehlzeiten(std::vector<Messdiener*>* mlist, std::vector<Einzeltermin*>* elist, std::vector<Serientermin*>* slist, std::vector<Fehlzeit*>* list) {
	wxTextFile file(FEHLZEITENFILE);
	file.Open();
	wxString line = file.GetFirstLine();
	for (; !file.Eof(); line = file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		int modus = wxAtoi(zr.NextToken());
		int wochentag = wxAtoi(zr.NextToken());
		wxString beginn = zr.NextToken();
		wxString ende = zr.NextToken();
		int m = wxAtoi(zr.NextToken());
		Messdiener* mini = mlist->at(m);
		if (modus == Fehlzeit::EINZELTERMIN) {
			int e = wxAtoi(zr.NextToken());
			Einzeltermin* einzeltermin = elist->at(e);
			list->push_back(new Fehlzeit(mini, einzeltermin));
		} else if (modus == Fehlzeit::SERIENTERMIN) {
			int s = wxAtoi(zr.NextToken());
			Serientermin* serientermin = slist->at(s);
			list->push_back(new Fehlzeit(mini, serientermin));
		} else if (modus == Fehlzeit::WOCHENTAG) {
			list->push_back(new Fehlzeit(mini, wochentag, beginn, ende));
		} else {// Fehlzeit::ZEITRAUM
			list->push_back(new Fehlzeit(mini, beginn, ende));
		}
	}
	file.Close();
}

void DataFileHandler::savePlanerInfos(std::vector<PlanerInfo>* list) {
	if (!wxDir::Exists(RES)) {
		wxDir::Make(RES);
	}
	wxTextFile file(PLANERINFOSFILE);
	if (!file.Exists()) {
		file.Create();
	}
	file.Open();
	file.Clear();
	for (std::vector<PlanerInfo>::iterator iter = list->begin(); iter != list->end(); iter++) {
		wxString line = Util::wxDateTime_to_wxString(iter->datum_beginn) + D + Util::wxDateTime_to_wxString(iter->datum_ende) + D + wxString::Format(wxT("%i"), iter->counter);
		file.AddLine(line);
	}
	file.Write();
	file.Close();
}

void DataFileHandler::loadPlanerInfos(std::vector<PlanerInfo>* list) {
	wxTextFile file(PLANERINFOSFILE);
	file.Open();
	for (wxString line = file.GetFirstLine(); !file.Eof(); line = file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		wxDateTime beginn = Util::wxString_to_wxDateTime(zr.NextToken());
		wxDateTime ende = Util::wxString_to_wxDateTime(zr.NextToken());
		int counter = wxAtoi(zr.NextToken());
		list->push_back(PlanerInfo(beginn, ende, counter));
	}
	file.Close();
}

===== ./src/export/MiniExportDialog.h =====
/* 
 * File:   MiniExportDialog.h
 * Author: Yannik
 *
 * Created on October 2, 2015, 7:46 PM
 */

#ifndef MINIEXPORTDIALOG_H
#define	MINIEXPORTDIALOG_H

#include <wx/wx.h>
#include <vector>
#include "../R.h"
#include "../model-data/Messdiener.h"
#include "../file/DataFileHandler.h"

class MiniExportDialog : public wxDialog {
public:
	MiniExportDialog(wxWindow* parent, std::vector<Messdiener*>* _list_mini);
private:
	const wxString D = DataFileHandler::D;
	const wxString N = wxT("\n");
	std::vector<Messdiener*>* list_mini;
	wxRadioButton* rb_file;
	wxRadioButton* rb_clipboard;
	wxCheckBox* cb_num;
	wxCheckBox* cb_cols[R::MINI_ATTS_NUM];
	
	wxButton* bt_html;
	wxButton* bt_csv;
	wxButton* bt_excel_xml;

	wxString createHTML();
	wxString createCSV();
	wxString createExcelXML();
	DECLARE_EVENT_TABLE();
	void onBtHTML(wxCommandEvent&);
	void onBtCSV(wxCommandEvent&);
	void onBtExcelXML(wxCommandEvent&);
};

#endif	/* MINIEXPORTDIALOG_H */



===== ./src/export/CSVExport.h =====
/* 
 * File:   CSVExport.h
 * Author: Yannik
 *
 * Created on October 1, 2015, 11:01 AM
 */

#ifndef CSVEXPORT_H
#define	CSVEXPORT_H

#include "ExportLayout.h"
#include "../model-plan/Planer.h"
#include "../file/DataFileHandler.h"

namespace CSVExport {
	const wxString D = DataFileHandler::D;
	const wxString N = wxT("\n");
	wxString createCSV(ExportLayout* layout, Planer* planer);
};

#endif	/* CSVEXPORT_H */

===== ./src/export/ExcelXMLExport.h =====
/* 
 * File:   ExcelXMLExport.h
 * Author: Yannik
 *
 * Created on October 1, 2015, 11:01 AM
 */

#ifndef EXCELXMLEXPORT_H
#define	EXCELXMLEXPORT_H

#include "ExportLayout.h"
#include "../model-plan/Planer.h"

namespace ExcelXMLExport {
	wxString createExcelXML(ExportLayout* layout, Planer* planer);
	int getCols(ExportLayout* layout);
};

#endif	/* EXCELXMLEXPORT_H */



===== ./src/export/HTMLExport.cpp =====
/* 
 * File:   HTMLExport.cpp
 * Author: Yannik
 * 
 * Created on October 1, 2015, 10:51 AM
 */

#include "HTMLExport.h"
#include "../R.h"

wxString HTMLExport::createHTML(ExportLayout* layout, Planer* planer, bool pv) {
	wxString page = wxT("<!DOCTYPE html>\n<html>");
	if (!pv) addHead(&page);
	page += wxT("\n	<body>\n		<table>");
	int cols = getCols(layout);

	//add title
	if (!layout->title.IsEmpty()) {
		if (pv) page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\"><h2>") + layout->title + wxT("</h2></td></tr>");
		else page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\" class=\"ptitle\">") + layout->title + wxT("</td></tr>");
	}

	//add termine
	for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end(); iter_t++) {
		//basics
		if (layout->modus_basics == ExportLayout::MODUS_BASICS_ABOVE) {
			if (pv) page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\"><b>") + PTermin::printBasics(*iter_t) + wxT("</b></td></tr>");
			else page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\" class=\"phead\">") + PTermin::printBasics(*iter_t) + wxT("</td></tr>");
			if (!(**iter_t).bem.IsEmpty()) {
				page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\">") + (**iter_t).bem + wxT("</td></tr>");
			}
			int num_dienste = (**iter_t).list_dienst_num.size();
			if (layout->showDienste) {
				for (int j = 0; j < num_dienste; j++) {
					if (pv) page += wxT("\n			<tr><td><i>") + (**iter_t).list_dienst_num.at(j).first->name + wxT("</i></td>");
					else page += wxT("\n			<tr><td class=\"pdienst\">") + (**iter_t).list_dienst_num.at(j).first->name + wxT("</td>");
					int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
					if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += wxT("<td>") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</td>");
							if (k == num_dienst_minis - 1 || k % layout->n == layout->n - 1) {
								for (int l = k % layout->n; l < layout->n - 1; l++) {
									page += wxT("<td></td>");
								}
								page += wxT("</tr>");
								if (k != num_dienst_minis - 1) {
									page += wxT("\n			<tr><td></td>");
								}
							}
						}
					} else {
						page += wxT("<td>");
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (k != num_dienst_minis - 1) page += wxT(", ");
						}
						page += wxT("</td></tr>");
					}
				}
			} else {//do not show dienste
				if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
					int col = 0;
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							if (col == 0) {
								page += wxT("\n			<tr>");
							}
							page += wxT("<td>") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</td>");
							if (col == layout->n - 1 || (j == num_dienste - 1 && k == num_dienst_minis - 1)) {
								for (int l = k % layout->n; l < layout->n - 1; l++) {
									page += wxT("<td></td>");
								}
								page += wxT("</tr>");
							}
							col = (col + 1) % layout->n;
						}
					}
				} else {
					if (num_dienste > 0) {
						page += wxT("\n			<tr><td>");
						int num_dienste = (**iter_t).list_dienst_num.size();
						for (int j = 0; j < num_dienste; j++) {
							int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
							for (int k = 0; k < num_dienst_minis; k++) {
								page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
								if (j != num_dienste - 1 || k != num_dienst_minis - 1) page += wxT(", ");
							}
						}
						page += wxT("</td></tr>");
					}
				}
			}
			page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\"><br/></td></tr>");
		} else {//MODUS_BASICS_LEFT
			bool bemDrawn = false;
			if (pv) page += wxT("\n			<tr><td><b>") + PTermin::printBasics(*iter_t) + wxT("</b></td>");
			else page += wxT("\n			<tr><td class=\"phead\">") + PTermin::printBasics(*iter_t) + wxT("</td>");
			int row = 0;
			int num_dienste = (**iter_t).list_dienst_num.size();
			if (layout->showDienste) {
				for (int j = 0; j < num_dienste; j++) {
					if (row != 0) {
						page += wxT("\n			<tr><td>");
						if (row == 1) {
							page += (**iter_t).bem;
							bemDrawn = true;
						}
						page += wxT("</td>");
					}
					if (pv) page += wxT("<td><i>") + (**iter_t).list_dienst_num.at(j).first->name + wxT("</i></td>");
					else page += wxT("<td class=\"pdienst\">") + (**iter_t).list_dienst_num.at(j).first->name + wxT("</td>");
					int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
					if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += wxT("<td>") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</td>");
							if (k == num_dienst_minis - 1 || k % layout->n == layout->n - 1) {
								for (int l = k % layout->n; l < layout->n - 1; l++) {
									page += wxT("<td></td>");
								}
								page += wxT("</tr>");
								if (k != num_dienst_minis - 1) {
									page += wxT("\n			<tr><td>");
									if (row == 0) {
										page += (**iter_t).bem;
										bemDrawn = true;
									}
									page += wxT("</td><td></td>");
								}
								row++;
							}
						}
					} else {
						page += wxT("<td>");
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (k != num_dienst_minis - 1) page += wxT(", ");
						}
						page += wxT("</td></tr>");
						row++;
					}
				}
			} else {//do not show dienste
				if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
					int col = 0;
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							if (col == 0 && row != 0) {
								page += wxT("\n			<tr><td>");
								if (row == 1) {
									page += (**iter_t).bem;
									bemDrawn = true;
								}
								page += wxT("</td>");
							}
							page += wxT("<td>") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</td>");
							if (col == layout->n - 1 || (j == num_dienste - 1 && k == num_dienst_minis - 1)) {
								for (int l = col; l < layout->n - 1; l++) {
									page += wxT("<td></td>");
								}
								page += wxT("</tr>");
								row++;
							}
							col = (col + 1) % layout->n;
						}
					}
				} else {
					page += wxT("<td>");
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (j != num_dienste - 1 || k != num_dienst_minis - 1) page += wxT(", ");
						}
					}
					page += wxT("</td>");
					if (num_dienste != 0) {
						page += wxT("</tr>");
						if (!(**iter_t).bem.IsEmpty()) {
							page += wxT("\n			<tr><td>") + (**iter_t).bem + wxT("</td></tr>");
							bemDrawn = true;
							row++;
						}
					}
				}
			}
			if (num_dienste == 0) {
				for (int l = 1; l < cols; l++) {
					page += wxT("<td></td>");
				}
				page += wxT("</tr>");
			}
			if (!bemDrawn && !(**iter_t).bem.IsEmpty()) page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\">") + (**iter_t).bem + wxT("</td></tr>");
			page += wxT("\n			<tr><td colspan=\"") + wxString::Format(wxT("%i"), cols) + wxT("\"><br/></td></tr>");
		}
	}
	page += wxT("\n		</table>\n	</body>\n</html>");
	return page;
}

void HTMLExport::addHead(wxString* page) {
	*page += wxT("\n	<head>\n		<title>") + R::MESSDIENERPLAN + wxT("</title>"
			"\n		<meta charset=\"utf-8\"/>"
			"\n		<meta name=\"description\" content=\"MiniPlaner Messdienerplan\"/>"
			"\n		<meta name=\"keywords\" content=\"MiniPlaner, Messdienerplan, Programm\"/>"
			"\n		<meta name=\"author\" content=\"Yannik Schälte\"/>"
			"\n		<style>"
			"\n		td {padding: 3px; vertical-align: top;}"
			"\n		.ptitle {font-size: x-large; font-weight: bold; padding-top:30px; padding-bottom:30px;}"
			"\n		.phead {font-weight: bold;}"
			"\n		.pdienst {font-style: italic;}"
			"\n		</style>"
			"\n	</head>");
}

int HTMLExport::getCols(ExportLayout* layout) {
	int cols = 0;
	if (layout->modus_basics == ExportLayout::MODUS_BASICS_ABOVE) {
		if (layout->showDienste) {
			if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
				cols = 1 + layout->n;
			} else {
				cols = 2;
			}
		} else if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
			cols = layout->n;
		} else {
			cols = 1;
		}
	} else {
		if (layout->showDienste) {
			if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
				cols = 2 + layout->n;
			} else {
				cols = 3;
			}
		} else if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
			cols = 1 + layout->n;
		} else {
			cols = 2;
		}
	}
	return cols;
}

===== ./src/export/ExportLayoutDialog.cpp =====
/* 
 * File:   SettingsDialog.cpp
 * Author: Yannik
 * 
 * Created on September 30, 2015, 4:14 PM
 */

#include "ExportLayoutDialog.h"
#include "../R.h"

ExportLayoutDialog::ExportLayoutDialog(wxWindow* parent, ExportLayout* _layout)
: wxDialog(parent, R::ID_ANY, R::EXPORT_LAYOUT_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER), layout(_layout) {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	sizer_config = new wxFlexGridSizer(5, 2, 0, 0);

	wxStaticText* st_title = new wxStaticText(this, R::ID_ANY, R::TITEL);
	sizer_config->Add(st_title, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_title = new wxTextCtrl(this, R::ID_ANY, layout->title);
	sizer_config->Add(tc_title, 1, wxEXPAND | wxALL, 2);

	wxStaticText* st_showDienste = new wxStaticText(this, R::ID_ANY, R::DIENSTE_ZEIGEN);
	sizer_config->Add(st_showDienste, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	cb_showDienste = new wxCheckBox(this, R::ID_ANY, wxT(""));
	cb_showDienste->SetValue(layout->showDienste);
	sizer_config->Add(cb_showDienste, 1, wxALL | wxEXPAND, 2);

	wxStaticText* st_minis = new wxStaticText(this, R::ID_ANY, R::MINIS_LAYOUT);
	sizer_config->Add(st_minis, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_minis = new wxBoxSizer(wxHORIZONTAL);
	ch_minis = new wxChoice(this, R::ID_CH, wxDefaultPosition, wxDefaultSize, 2, R::MINIS_LAYOUT_MODI);
	ch_minis->Select(layout->modus_minis);
	sizer_minis->Add(ch_minis, 1, wxEXPAND | wxALL, 0);
	sp_minis = new wxSpinCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 1, 1000000000, layout->n);
	sizer_minis->Add(sp_minis, 0, wxALL, 0);
	if (layout->modus_minis != ExportLayout::MODUS_MINIS_CELLS) {
		sp_minis->Hide();
	}
	sizer_config->Add(sizer_minis, 1, wxALL | wxEXPAND, 2);

	wxStaticText* st_basics = new wxStaticText(this, R::ID_ANY, R::BASICS_LAYOUT);
	sizer_config->Add(st_basics, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	ch_basics = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, 2, R::BASICS_LAYOUT_MODI);
	ch_basics->Select(layout->modus_basics);
	sizer_config->Add(ch_basics, 1, wxALL | wxEXPAND, 2);

	wxStaticText* st_namen = new wxStaticText(this, R::ID_ANY, R::NAMEN_LAYOUT);
	sizer_config->Add(st_namen, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	ch_namen = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, 4, R::NAMEN_LAYOUT_MODI);
	ch_namen->Select(layout->modus_namen);
	sizer_config->Add(ch_namen, 1, wxALL | wxEXPAND, 2);

	sizer_config->AddGrowableCol(1, 1);
	sizer->Add(sizer_config, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);

	if (GetSize().GetWidth() < 460) {
		SetSize(460, -1);
	}
}

BEGIN_EVENT_TABLE(ExportLayoutDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, ExportLayoutDialog::onOk)
EVT_BUTTON(R::ID_BT_CANCEL, ExportLayoutDialog::onCancel)
EVT_CHOICE(R::ID_CH, ExportLayoutDialog::onMinis)
END_EVENT_TABLE()

void ExportLayoutDialog::onOk(wxCommandEvent&) {
	layout->title = tc_title->GetValue();
	layout->showDienste = cb_showDienste->GetValue();
	layout->modus_minis = ch_minis->GetSelection();
	if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
		layout->n = sp_minis->GetValue();
	}
	layout->modus_basics = ch_basics->GetSelection();
	layout->modus_namen = ch_namen->GetSelection();
	Close(true);
}

void ExportLayoutDialog::onCancel(wxCommandEvent&) {
	Close(true);
}

void ExportLayoutDialog::onMinis(wxCommandEvent&) {
	if (ch_minis->GetSelection() == ExportLayout::MODUS_MINIS_CELLS) {
		sp_minis->Show();
	} else {
		sp_minis->Hide();
	}
	sizer_config->Layout();
}

===== ./src/export/CSVExport.cpp =====
/* 
 * File:   CSVExport.cpp
 * Author: Yannik
 * 
 * Created on October 1, 2015, 11:01 AM
 */

#include "CSVExport.h"

wxString CSVExport::createCSV(ExportLayout* layout, Planer* planer) {
	wxString page = wxT("sep=") + D + N;

	//add title
	if (!layout->title.IsEmpty()) {
		page += layout->title + N + N;
	}

	//add termine
	for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end(); iter_t++) {
		//basics
		if (layout->modus_basics == ExportLayout::MODUS_BASICS_ABOVE) {
			page += PTermin::printBasics(*iter_t) + N;
			if (!(**iter_t).bem.IsEmpty()) {
				page += (**iter_t).bem + N;
			}
			int num_dienste = (**iter_t).list_dienst_num.size();
			if (layout->showDienste) {
				for (int j = 0; j < num_dienste; j++) {
					page += (**iter_t).list_dienst_num.at(j).first->name + D;
					int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
					if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + D;
							if (k == num_dienst_minis - 1 || k % layout->n == layout->n - 1) {
								page += N;
								if (k != num_dienst_minis - 1) {
									page += D;
								}
							}
						}
						if (num_dienst_minis == 0) page += N;
					} else {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (k != num_dienst_minis - 1) page += wxT(", ");
						}
						page += N;
					}	
				}
			} else {//do not show dienste
				if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
					int col = 0;
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + D;
							if (col == layout->n - 1 || (j == num_dienste - 1 && k == num_dienst_minis - 1)) {
								page += N;
							}
							col = (col + 1) % layout->n;
						}
					}
				} else {
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (j != num_dienste - 1 || k != num_dienst_minis - 1) page += wxT(", ");
						}
					}
					if (num_dienste != 0) page += N;
				}
			}
			page += N;
		} else {//MODUS_BASICS_LEFT
			bool bemDrawn = false;
			page += PTermin::printBasics(*iter_t) + D;
			int row = 0;
			int num_dienste = (**iter_t).list_dienst_num.size();
			if (layout->showDienste) {
				for (int j = 0; j < num_dienste; j++) {
					if (row != 0) {
						if (row == 1) {
							page += (**iter_t).bem;
							bemDrawn = true;
						}
						page += D;
					}
					page += (**iter_t).list_dienst_num.at(j).first->name + D;
					int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
					if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + D;
							if (k == num_dienst_minis - 1 || k % layout->n == layout->n - 1) {
								page += N;
								if (k != num_dienst_minis - 1) {
									if (row == 0) {
										page += (**iter_t).bem;
										bemDrawn = true;
									}
									page += D + D;
								}
								row++;
							}
						}
						if (num_dienst_minis == 0) page += N;
					} else {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (k != num_dienst_minis - 1) page += wxT(", ");
						}
						page += N;
						row++;
					}
				}
			} else {//do not show dienste
				if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
					int col = 0;
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							if (col == 0 && row != 0) {
								if (row == 1) {
									page += (**iter_t).bem;
									bemDrawn = true;
								}
								page += D;
							}
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + D;
							if (col == layout->n - 1 || (j == num_dienste - 1 && k == num_dienst_minis - 1)) {
								page += N;
								row++;
							}
							col = (col + 1) % layout->n;
						}
					}
				} else {
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (j != num_dienste - 1 || k != num_dienst_minis - 1) page += wxT(", ");
						}
					}
					page += N;
					if (!(**iter_t).bem.IsEmpty()) {
						page += (**iter_t).bem;
						if (num_dienste != 0) page += N;
						bemDrawn = true;
						row++;
					}
				}
			}
			if (num_dienste == 0) page += N;
			if (!bemDrawn && !(**iter_t).bem.IsEmpty()) page += (**iter_t).bem + N;
			page += N;
		}
	}
	return page;
}

===== ./src/export/ExportLayoutDialog.h =====
/* 
 * File:   SettingsDialog.h
 * Author: Yannik
 *
 * Created on September 30, 2015, 4:14 PM
 */

#ifndef EXPORTLAYOUTDIALOG_H
#define	EXPORTLAYOUTDIALOG_H

#include <wx/wx.h>
#include <wx/spinctrl.h>
#include "ExportLayout.h"

class ExportLayoutDialog : public wxDialog {
public:
	ExportLayoutDialog(wxWindow* parent, ExportLayout* _layout);
private:
	ExportLayout* layout;
	
	wxFlexGridSizer* sizer_config;
	wxTextCtrl* tc_title;
	wxCheckBox* cb_showDienste;
	wxChoice* ch_minis;
	wxSpinCtrl* sp_minis;
	wxChoice* ch_basics;
	wxChoice* ch_namen;
	
	wxButton* bt_ok;
	wxButton* bt_cancel;
	
	DECLARE_EVENT_TABLE();
	void onMinis(wxCommandEvent&);
	void onOk(wxCommandEvent&);
	void onCancel(wxCommandEvent&);
};

#endif	/* EXPORTLAYOUTDIALOG_H */



===== ./src/export/ExportLayout.cpp =====
#include "ExportLayout.h"

wxString ExportLayout::createName(PMessdiener* mini) {
	if(mini == NULL) return wxT("-");
	switch (modus_namen) {
		case MODUS_NAMEN_VORNAME_N:
			return mini->vorname + wxT(" ") + mini->name.Mid(0, 1) + wxT(".");
		case MODUS_NAMEN_VORNAME_NACHNAME:
			return mini->vorname + wxT(" ") + mini->name;
		case MODUS_NAMEN_V_NACHNAME:
			return mini->vorname.Mid(0, 1) + wxT(". ") + mini->name;
		default:
			return mini->vorname;
	}
}


===== ./src/export/ExportLayout.h =====
/* 
 * File:   ExportLayout.h
 * Author: Yannik
 *
 * Created on October 1, 2015, 10:53 AM
 */

#ifndef EXPORTLAYOUT_H
#define	EXPORTLAYOUT_H

#include <wx/string.h>
#include "../model-plan/PMessdiener.h"

class ExportLayout {
public:
	wxString title;
	bool showDienste;
	int modus_minis;
	int n;
	int modus_basics;
	int modus_namen;

	static const int MODUS_MINIS_CELLS = 0;
	static const int MODUS_MINIS_ROW = 1;
	static const int MODUS_BASICS_LEFT = 0;
	static const int MODUS_BASICS_ABOVE = 1;
	static const int MODUS_NAMEN_VORNAME_NACHNAME = 0;
	static const int MODUS_NAMEN_V_NACHNAME = 1;
	static const int MODUS_NAMEN_VORNAME_N = 2;
	static const int MODUS_NAMEN_VORNAME = 3;

	wxString createName(PMessdiener* mini);
};

#endif	/* EXPORTLAYOUT_H */

===== ./src/export/ExcelXMLExport.cpp =====
/* 
 * File:   ExcelXMLExport.cpp
 * Author: Yannik
 * 
 * Created on October 1, 2015, 11:01 AM
 */

#include "ExcelXMLExport.h"
#include "../R.h"

wxString ExcelXMLExport::createExcelXML(ExportLayout* layout, Planer* planer) {
	wxString page = wxT("<?xml version=\"1.0\" encoding=\"utf-8\"?>"
			"<?mso-application progid=\"Excel.Sheet\"?>"
			"<Workbook"
			" xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\""
			" xmlns:o=\"urn:schemas-microsoft-com:office:office\""
			" xmlns:x=\"urn:schemas-microsoft-com:office:excel\""
			" xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\""
			" xmlns:html=\"http://www.w3.org/TR/REC-html40\">");
	page += wxT("<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">"
			"<Author>Yannik Schälte</Author>"
			"<Version>2.0</Version>"
			"</DocumentProperties>");
	page += wxT("<Styles>"
			"<Style ss:ID=\"Default\" ss:Name=\"Normal\">"
			"<Alignment ss:Vertical=\"Bottom\" />"
			"</Style>"
			"<Style ss:ID=\"s21\">"
			"<Font x:Family=\"Swiss\" ss:Bold=\"1\" />"
			"</Style>"
			"<Style ss:ID=\"s22\">"
			"<Font x:Family=\"Swiss\" ss:Italic=\"1\" />"
			"</Style>"
			"<Style ss:ID=\"s23\">"
			"<Font x:Family=\"Swiss\" ss:Size=\"16\" ss:Bold=\"1\" />"
			"</Style>"
			"</Styles>");
	page += wxT("<Worksheet ss:Name=\"") + R::MESSDIENERPLAN + wxT("\">"
			"<Table>");

	//plan in rows and columns
	int cols = getCols(layout) - 1;

	//add title
	if (!layout->title.IsEmpty()) {
		page += wxT("<Row><Cell ss:MergeAcross=\"") + wxString::Format(wxT("%i"), cols) + wxT("\" ss:StyleID=\"s23\"><Data ss:Type=\"String\">") + layout->title + wxT("</Data></Cell></Row>");
		page += wxT("<Row></Row>");
	}

	//add termine
	for (std::vector<PTermin*>::iterator iter_t = planer->list_termin.begin(); iter_t != planer->list_termin.end(); iter_t++) {
		//basics
		if (layout->modus_basics == ExportLayout::MODUS_BASICS_ABOVE) {
			page += wxT("<Row><Cell ss:MergeAcross=\"") + wxString::Format(wxT("%i"), cols) + wxT("\" ss:StyleID=\"s21\"><Data ss:Type=\"String\">") + PTermin::printBasics(*iter_t) + wxT("</Data></Cell></Row>");
			if (!(**iter_t).bem.IsEmpty()) {
				page += wxT("<Row><Cell ss:MergeAcross=\"") + wxString::Format(wxT("%i"), cols) + wxT("\"><Data ss:Type=\"String\">") + (**iter_t).bem + wxT("</Data></Cell></Row>");
			}
			int num_dienste = (**iter_t).list_dienst_num.size();
			if (layout->showDienste) {
				for (int j = 0; j < num_dienste; j++) {
					page += wxT("<Row><Cell ss:StyleID=\"s22\"><Data ss:Type=\"String\">") + (**iter_t).list_dienst_num.at(j).first->name + wxT("</Data></Cell>");
					int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
					if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += wxT("<Cell><Data ss:Type=\"String\">") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</Data></Cell>");
							if (k == num_dienst_minis - 1 || k % layout->n == layout->n - 1) {
								page += wxT("</Row>");
								if (k != num_dienst_minis - 1) {
									page += wxT("<Row><Cell></Cell>");
								}
							}
						}
					} else {
						page += wxT("<Cell><Data ss:Type=\"String\">");
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (k != num_dienst_minis - 1) page += wxT(", ");
						}
						page += wxT("</Data></Cell></Row>");
					}
				}
			} else {//do not show dienste
				if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
					int col = 0;
					int num_dienste = (**iter_t).list_dienst_num.size();
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							if (col == 0) {
								page += wxT("<Row>");
							}
							page += wxT("<Cell><Data ss:Type=\"String\">") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</Data></Cell>");
							if (col == layout->n - 1 || (j == num_dienste - 1 && k == num_dienst_minis - 1)) {
								page += wxT("</Row>");
							}
							col = (col + 1) % layout->n;
						}
					}
				} else {
					int num_dienste = (**iter_t).list_dienst_num.size();
					if (num_dienste > 0) {
						page += wxT("<Row><Cell><Data ss:Type=\"String\">");
						for (int j = 0; j < num_dienste; j++) {
							int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
							for (int k = 0; k < num_dienst_minis; k++) {
								page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
								if (j != num_dienste - 1 || k != num_dienst_minis - 1) page += wxT(", ");
							}
						}
						page += wxT("</Data></Cell></Row>");
					}
				}
			}
			page += wxT("<Row></Row>");
		} else {//MODUS_BASICS_LEFT
			bool bemDrawn = false;
			page += wxT("<Row><Cell ss:StyleID=\"s21\"><Data ss:Type=\"String\">") + PTermin::printBasics(*iter_t) + wxT("</Data></Cell>");
			int row = 0;
			int num_dienste = (**iter_t).list_dienst_num.size();
			if (layout->showDienste) {
				for (int j = 0; j < num_dienste; j++) {
					if (row != 0) {
						page += wxT("<Row><Cell><Data ss:Type=\"String\">");
						if (row == 1) {
							page += (**iter_t).bem;
							bemDrawn = true;
						}
						page += wxT("</Data></Cell>");
					}
					page += wxT("<Cell ss:StyleID=\"s22\"><Data ss:Type=\"String\">") + (**iter_t).list_dienst_num.at(j).first->name + wxT("</Data></Cell>");
					int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
					if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
						for (int k = 0; k < num_dienst_minis; k++) {
							page += wxT("<Cell><Data ss:Type=\"String\">") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</Data></Cell>");
							if (k == num_dienst_minis - 1 || k % layout->n == layout->n - 1) {
								page += wxT("</Row>");
								if (k != num_dienst_minis - 1) {
									page += wxT("<Row><Cell><Data ss:Type=\"String\">");
									if (row == 0) {
										page += (**iter_t).bem;
										bemDrawn = true;
									}
									page += wxT("</Data></Cell><Cell></Cell>");
								}
								row++;
							}
						}
					} else {
						page += wxT("<Cell><Data ss:Type=\"String\">");
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (k != num_dienst_minis - 1) page += wxT(", ");
						}
						page += wxT("</Data></Cell></Row>");
						row++;
					}
				}
			} else {//do not show dienste
				if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
					int col = 0;
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							if (col == 0 && row != 0) {
								page += wxT("<Row><Cell><Data ss:Type=\"String\">");
								if (row == 1) {
									page += (**iter_t).bem;
									bemDrawn = true;
								}
								page += wxT("</Data></Cell>");
							}
							page += wxT("<Cell><Data ss:Type=\"String\">") + layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k)) + wxT("</Data></Cell>");
							if (col == layout->n - 1 || (j == num_dienste - 1 && k == num_dienst_minis - 1)) {
								page += wxT("</Row>");
								row++;
							}
							col = (col + 1) % layout->n;
						}
					}
				} else {
					page += wxT("<Cell><Data ss:Type=\"String\">");
					for (int j = 0; j < num_dienste; j++) {
						int num_dienst_minis = (**iter_t).list_dienst_num.at(j).second;
						for (int k = 0; k < num_dienst_minis; k++) {
							page += layout->createName((**iter_t).list_dienst_minis.at(j).second.at(k));
							if (j != num_dienste - 1 || k != num_dienst_minis - 1) page += wxT(", ");
						}
					}
					page += wxT("</Data></Cell>");
					if (num_dienste != 0) {
						page += wxT("</Row>");
						if (!(**iter_t).bem.IsEmpty()) {
							page += wxT("<Row><Cell><Data ss:Type=\"String\">") + (**iter_t).bem + wxT("</Data></Cell></Row>");
							bemDrawn = true;
							row++;
						}
					}
				}
			}
			if (num_dienste == 0) page += wxT("</Row>");
			if (!bemDrawn && !(**iter_t).bem.IsEmpty()) page += wxT("<Row><Cell><Data ss:Type=\"String\">") + (**iter_t).bem + wxT("</Data></Cell></Row>");
			page += wxT("<Row><Cell></Cell></Row>");
		}
	}

	page += wxT("</Table>");
	page += wxT("</Worksheet>");
	page += wxT("</Workbook>");
	return page;
}

int ExcelXMLExport::getCols(ExportLayout* layout) {
	int cols = 0;
	if (layout->modus_basics == ExportLayout::MODUS_BASICS_ABOVE) {
		if (layout->showDienste) {
			if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
				cols = 1 + layout->n;
			} else {
				cols = 2;
			}
		} else if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
			cols = layout->n;
		} else {
			cols = 1;
		}
	} else {
		if (layout->showDienste) {
			if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
				cols = 2 + layout->n;
			} else {
				cols = 3;
			}
		} else if (layout->modus_minis == ExportLayout::MODUS_MINIS_CELLS) {
			cols = 1 + layout->n;
		} else {
			cols = 2;
		}
	}
	return cols;
}

===== ./src/export/HTMLExport.h =====
/* 
 * File:   HTMLExport.h
 * Author: Yannik
 *
 * Created on October 1, 2015, 10:51 AM
 */

#ifndef HTMLEXPORT_H
#define	HTMLEXPORT_H

#include "ExportLayout.h"
#include "../model-plan/Planer.h"

namespace HTMLExport {
	wxString createHTML(ExportLayout* layout, Planer* planer, bool pv);
	void addHead(wxString* page);
	int getCols(ExportLayout* layout);
};

#endif	/* HTMLEXPORT_H */



===== ./src/export/PlanerMiniInterfaceDialog.cpp =====
/* 
 * File:   PlanerMiniInterfaceDialog.cpp
 * Author: Yannik
 * 
 * Created on March 22, 2016, 2:54 PM
 */

#include "PlanerMiniInterfaceDialog.h"
#include <algorithm>
#include <wx/clipbrd.h>
#include <wx/filedlg.h>
#include <wx/statline.h>
#include <wx/wfstream.h>
#include <wx/tokenzr.h>
#include "../App.h"
#include "../R.h"
#include "../Util.h"
#include "../view-plan/PTerminDialog.h"
#include "../view-data/DeleteDialog.h"
#include "../file/DataFileHandler.h"

PlanerMiniInterfaceDialog::PlanerMiniInterfaceDialog(wxWindow* parent, App* _app, bool* _edt,
		wxDateTime* _datum_beginn,
		wxDateTime* _datum_ende,
		std::vector<Dienst*>* _list_dienst,
		std::vector<PTermin*>* _list_termin,
		std::vector<PMessdiener*>* _list_mini,
		std::vector<PMGruppe*>* _list_mgruppe,
		std::vector<PFehlzeit*>* _list_fehlzeit)
: wxDialog(parent, R::ID_ANY, wxT("MiniInterface-Dialog"), wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	deleteContents = true;
	edt = _edt;
	datum_beginn = _datum_beginn;
	datum_ende = _datum_ende;
	list_dienst = _list_dienst;
	list_termin = _list_termin;
	list_mini = _list_mini;
	list_mgruppe = _list_mgruppe;
	list_fehlzeit = _list_fehlzeit;
	initComponents();
}

void PlanerMiniInterfaceDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	wxChoicebook* choicebook = new wxChoicebook(this, R::ID_ANY);
	sizer->Add(choicebook, 1, wxEXPAND, 0);
	SetSizer(sizer);
	pl_1 = new wxPanel(choicebook, R::ID_ANY);
	choicebook->AddPage(pl_1, wxT("Daten für MiniInterface-Formular exportieren"));
	pl_2 = new wxPanel(choicebook, R::ID_ANY);
	choicebook->AddPage(pl_2, wxT("Mit Daten aus MiniInterface-Formular Plan erstellen"));

	//Export********************************************************************
	wxBoxSizer* sizer_1 = new wxBoxSizer(wxVERTICAL);
	pl_1->SetSizer(sizer_1);

	//Zeitraum
	pl_zeitraum = new wxPanel(pl_1, R::ID_ANY);
	wxFlexGridSizer* sizer_zeitraum = new wxFlexGridSizer(2, 2, 0, 0);
	st_beginn = new wxStaticText(pl_zeitraum, R::ID_ANY, R::DATUM_BEGINN);
	sizer_zeitraum->Add(st_beginn, 0, wxALIGN_CENTER_VERTICAL | wxALL, 5);
	cl_beginn = new wxCalendarCtrl(pl_zeitraum, R::ID_ANY, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, 0);
	sizer_zeitraum->Add(cl_beginn, 0, wxALL, 5);
	st_ende = new wxStaticText(pl_zeitraum, R::ID_ANY, R::DATUM_ENDE);
	sizer_zeitraum->Add(st_ende, 0, wxALIGN_CENTER_VERTICAL | wxALL, 5);
	cl_ende = new wxCalendarCtrl(pl_zeitraum, R::ID_ANY, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, 0);
	sizer_zeitraum->Add(cl_ende, 0, wxALL, 5);
	pl_zeitraum->SetSizer(sizer_zeitraum);
	pl_zeitraum->Fit();
	sizer_1->Add(pl_zeitraum, 1, wxEXPAND | wxALL, 5);

	//Termine
	nb_termine = new wxNotebook(pl_1, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxNB_TOP);

	nb_pl_termine = new wxPanel(nb_termine, R::ID_ANY);
	nb_termine->InsertPage(0, nb_pl_termine, R::TERMINE);
	wxBoxSizer* sizer_nb_pl_termine = new wxBoxSizer(wxHORIZONTAL);
	lv_termine = new wxListView(nb_pl_termine, R::ID_LC, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[R::TEINZEL_NUM + 1];
	cols[0].SetText(wxT(""));
	lv_termine->InsertColumn(0, cols[0]);
	for (int i = 1; i < R::TEINZEL_NUM + 1; i++) {
		cols[i].SetText(R::TEINZEL_ATTS[i - 1]);
		lv_termine->InsertColumn(i, cols[i]);
	}
	sizer_nb_pl_termine->Add(lv_termine, 1, wxEXPAND | wxALL, 0);
	wxBoxSizer* sizer_nb_pl_termine_r = new wxBoxSizer(wxVERTICAL);
	bt_termine_edt = new wxButton(nb_pl_termine, R::ID_BT_EDT, R::EDT);
	sizer_nb_pl_termine_r->Add(bt_termine_edt, 0, 0, 0);
	bt_termine_del = new wxButton(nb_pl_termine, R::ID_BT_DEL, R::DEL);
	sizer_nb_pl_termine_r->Add(bt_termine_del, 0, 0, 0);
	sizer_nb_pl_termine->Add(sizer_nb_pl_termine_r, 0, 0, 0);
	nb_pl_termine->SetSizer(sizer_nb_pl_termine);

	//TGruppen
	nb_pl_tgruppen = new wxPanel(nb_termine, R::ID_ANY);
	nb_termine->InsertPage(1, nb_pl_tgruppen, R::TGRUPPEN);
	wxBoxSizer* sizer_nb_pl_tgruppen = new wxBoxSizer(wxHORIZONTAL);
	lv_tgruppen = new wxListView(nb_pl_tgruppen, R::ID_LC2, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols2[2];
	cols2[0].SetText(wxT(""));
	cols2[1].SetText(R::TGRUPPE);
	lv_tgruppen->InsertColumn(0, cols2[0]);
	lv_tgruppen->InsertColumn(1, cols2[1]);
	sizer_nb_pl_tgruppen->Add(lv_tgruppen, 1, wxEXPAND | wxALL, 0);
	nb_pl_tgruppen->SetSizer(sizer_nb_pl_tgruppen);

	sizer_1->Add(nb_termine, 1, wxEXPAND | wxALL, 5);

	//Navigation
	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_back = new wxButton(pl_1, R::ID_BT_BACK, R::ZURUECK);
	btsizer->Add(bt_back, 0, 0, 0);
	bt_cont = new wxButton(pl_1, R::ID_BT_CONT, R::WEITER);
	btsizer->Add(bt_cont, 0, wxRIGHT, 5);
	bt_cancel = new wxButton(pl_1, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel, 0, 0, 0);
	sizer_1->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	//Import********************************************************************
	wxBoxSizer* sizer_2 = new wxBoxSizer(wxVERTICAL);
	st_imp_text = new wxStaticText(pl_2, R::ID_ANY, wxT("Kopieren Sie den kompletten Inhalt der Datei \"MiniInterface.dat\" in die Zwischenablage\n(z.B. per Strg+A, Strg+C)."));
	sizer_2->Add(st_imp_text, 0, wxEXPAND | wxALL, 5);
	cb_imp_anw = new wxCheckBox(pl_2, R::ID_ANY, wxT("Bei positiver Rückmeldung (\"Felder mit Häkchen\") Messdiener zufällig eintragen (berücksichtigt keine M.-Gruppen)"));
	cb_imp_anw->SetValue(true);
	sizer_2->Add(cb_imp_anw, 0, wxEXPAND | wxALL, 5);
	bt_imp_pull = new wxButton(pl_2, R::ID_BT_ADD2, wxT("Lade Daten aus Zwischenablage"));
	sizer_2->Add(bt_imp_pull, 0, wxALL, 5);
	sizer_2->Add(new wxPanel(this), 1, wxEXPAND, 0);
	//Navigation
	wxBoxSizer* btsizer_2 = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn_2 = new wxPanel(this);
	pl_nn_2->SetSize(30, -1);
	btsizer_2->Add(pl_nn_2, 1, wxEXPAND);
	bt_imp_cancel = new wxButton(pl_2, R::ID_BT_CANCEL, R::CANCEL);
	btsizer_2->Add(bt_imp_cancel, 0, 0, 0);
	sizer_2->Add(btsizer_2, 0, wxALL | wxEXPAND, 5);

	pl_2->SetSizer(sizer_2);
	setModusZeitraum();
}

void PlanerMiniInterfaceDialog::setModusZeitraum() {
	modus = MODUS_ZEITRAUM;
	pl_zeitraum->Show();
	nb_termine->Hide();
	bt_back->Hide();
	Fit();
}

void PlanerMiniInterfaceDialog::setModusTermine() {
	modus = MODUS_TERMINE;
	pl_zeitraum->Hide();
	nb_termine->Show();
	bt_back->Show();
	Fit();
}

void PlanerMiniInterfaceDialog::notifyTermine(int index) {
	lv_termine->DeleteAllItems();
	for (int i = 0; i < (int) list_termin->size(); i++) {
		wxListItem item;
		item.SetId(i);
		PTermin* t = list_termin->at(i);
		lv_termine->InsertItem(item);
		lv_termine->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_termine->SetItem(i, 1, t->name);
		lv_termine->SetItem(i, 2, t->ort);
		lv_termine->SetItem(i, 3, Util::wxDateTime_to_wxString(t->datum) + wxT(" (") + R::WOCHENTAGE[t->datum.GetWeekDay()] + wxT(")"));
		lv_termine->SetItem(i, 4, t->zeit_beginn);
		lv_termine->SetItem(i, 5, PTermin::printDienste(t));
		lv_termine->SetItem(i, 6, t->bem);
	}
	if (index != -1) lv_termine->Select(index, true);
	for (int i = 0; i < R::TEINZEL_NUM + 1; i++) {
		lv_termine->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

void PlanerMiniInterfaceDialog::notifyTGruppen() {
	lv_tgruppen->DeleteAllItems();
	int counter = 0;
	int gcounter = 1;
	for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
		if ((**iter).prev == (PTermin *) NULL) {
			PTermin* termin = *iter;
			wxListItem item;
			item.SetId(counter);
			lv_tgruppen->InsertItem(item);
			lv_tgruppen->SetItem(counter, 0, wxString::Format(wxT("%i"), gcounter));
			bool ownRow = false;
			while (termin != (PTermin*) NULL) {
				if (ownRow) {
					counter++;
					wxListItem item;
					item.SetId(counter);
					lv_tgruppen->InsertItem(item);
				} else {
					ownRow = true;
				}
				lv_tgruppen->SetItem(counter, 1, PTermin::printShort(termin));
				termin = termin->next;
			}
			counter++;
			gcounter++;
		}
	}
	lv_tgruppen->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_tgruppen->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

wxString PlanerMiniInterfaceDialog::createData() {
	wxString D = DataFileHandler::D;
	//datum, dienste
	wxString text = Util::wxDateTime_to_wxString(*datum_beginn) + D + Util::wxDateTime_to_wxString(*datum_ende) + D + wxString::Format(wxT("%i"), list_dienst->size());
	for (int i = 0; i < (int) list_dienst->size(); i++) {
		text += D + list_dienst->at(i)->name;
	}
	text += wxT("\n");
	//termine
	text += wxString::Format(wxT("%i"), list_termin->size());
	for (int i = 0; i < (int) list_termin->size(); i++) {
		text += wxT("\n");
		PTermin t = *(list_termin->at(i));
		text += t.name + D + t.ort + D + Util::wxDateTime_to_wxString(t.datum) + D + t.zeit_beginn + D
				+ (t.prev == NULL ? wxT("-1") : wxString::Format(wxT("%i"), t.prev->_id)) + D
				+ (t.next == NULL ? wxT("-1") : wxString::Format(wxT("%i"), t.next->_id)) + D
				+ t.bem;
		for (std::vector<std::pair<Dienst*, int> >::iterator iter = t.list_dienst_num.begin(); iter != t.list_dienst_num.end(); iter++) {
			text += D + wxString::Format(wxT("%i"), iter->first->_id) + D + wxString::Format(wxT("%i"), iter->second);
		}
	}
	//minis mit anwesenheiten
	text += wxT("\n") + wxString::Format(wxT("%i"), list_mini->size());
	for (int i = 0; i < (int) list_mini->size(); i++) {
		text += wxT("\n");
		PMessdiener* m = list_mini->at(i);
		text += m->name + D + m->vorname;
		for (int j = 0; j < (int) m->dienste.size(); j++) {
			text += D + wxString::Format(wxT("%i"), m->dienste.at(j)->_id);
		}
		text += wxT("\n");
		for (int j = 0; j < (int) list_termin->size(); j++) {
			bool canPlay = false;
			for (std::vector< std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter = list_termin->at(j)->list_dienst_minis_possible.begin();
					iter != list_termin->at(j)->list_dienst_minis_possible.end() && !canPlay; iter++) {
				if (std::find(iter->second.begin(), iter->second.end(), m) != iter->second.end()) {
					canPlay = true;
				}
			}
			if (canPlay) {
				text += wxString::Format(wxT("%i"), ANW_VIELLEICHT) + D;
			} else {
				text += wxString::Format(wxT("%i"), ANW_NEIN) + D;
			}
		}
	}
	//mgruppen
	text += wxT("\n") + wxString::Format(wxT("%i"), list_mgruppe->size());
	for (int i = 0; i < (int) list_mgruppe->size(); i++) {
		PMGruppe mg = *(list_mgruppe->at(i));
		wxString line = wxString::Format(wxT("%i"), mg.modus);
		for (std::vector<PMessdiener*>::iterator iter_m = mg.list.begin(); iter_m != mg.list.end(); iter_m++) {
			line += D + wxString::Format(wxT("%i"), (**iter_m)._id);
		}
		text += wxT("\n") + line;
	}
	//fehlzeiten
	text += wxT("\n") + wxString::Format(wxT("%i"), list_fehlzeit->size());
	for (int i = 0; i < (int) list_fehlzeit->size(); i++) {
		PFehlzeit* f = list_fehlzeit->at(i);
		wxString line = wxString::Format(wxT("%i"), Fehlzeit::ZEITRAUM) + D + wxString::Format(wxT("%i"), f->mini->_id)
				+ D + Util::wxDateTime_to_wxString(f->datum_beginn)
				+ D + Util::wxDateTime_to_wxString(f->datum_ende);
		text += wxT("\n") + line;
	}
	return text;
}

void PlanerMiniInterfaceDialog::edtTermin(int index) {
	PTermin* termin = list_termin->at(index);
	bool edt_termin = false;
	PTerminDialog* dialog = new PTerminDialog(this, termin, list_termin, list_dienst, list_mini, &edt_termin);
	dialog->ShowModal();
	delete dialog;
	if (edt_termin) {
		int j = 0;
		while (list_termin->at(j) != termin) j++;
		notifyTermine(j);
		notifyTGruppen();
	}
}

void PlanerMiniInterfaceDialog::delTermin(int index) {
	PTermin* t = list_termin->at(index);
	if (t->prev != NULL) {
		t->prev->next = t->next;
	}
	if (t->next != NULL) {
		t->next->prev = t->prev;
	}
	delete t;
	list_termin->erase(list_termin->begin() + index);
	int counter = 0;
	for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
		(**iter)._id = counter++;
	}
	Util::setMiniNums(list_mini, list_termin);
	notifyTermine();
	notifyTGruppen();
}

BEGIN_EVENT_TABLE(PlanerMiniInterfaceDialog, wxDialog)
EVT_BUTTON(R::ID_BT_BACK, PlanerMiniInterfaceDialog::onBtBack)
EVT_BUTTON(R::ID_BT_CONT, PlanerMiniInterfaceDialog::onBtCont)
EVT_BUTTON(R::ID_BT_CANCEL, PlanerMiniInterfaceDialog::onBtCancel)
EVT_BUTTON(R::ID_BT_EDT, PlanerMiniInterfaceDialog::onBtEdt)
EVT_BUTTON(R::ID_BT_DEL, PlanerMiniInterfaceDialog::onBtDel)
EVT_BUTTON(R::ID_BT_ADD2, PlanerMiniInterfaceDialog::onBtImpPull)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, PlanerMiniInterfaceDialog::onLIActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, PlanerMiniInterfaceDialog::onLIKey)
EVT_CLOSE(PlanerMiniInterfaceDialog::onClose)
END_EVENT_TABLE()

void PlanerMiniInterfaceDialog::onBtBack(wxCommandEvent&) {
	if (modus == MODUS_TERMINE) {
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			delete *iter;
		}
		list_dienst->clear();
		list_termin->clear();
		list_mini->clear();
		list_mgruppe->clear();
		list_fehlzeit->clear();

		setModusZeitraum();
	}
}

void PlanerMiniInterfaceDialog::onBtCont(wxCommandEvent&) {
	if (modus == MODUS_ZEITRAUM) {
		*datum_beginn = cl_beginn->GetDate();
		*datum_ende = cl_ende->GetDate();
		if (datum_beginn->IsLaterThan(*datum_ende)) {
			wxMessageDialog dialog(this, R::MSG_DATUM_ORDER);
			dialog.ShowModal();
			return;
		}
		//**Translation of dates************************************************
		std::vector<TerminCreator::PTerminHolder> list_termin_paar;
		TerminCreator::createLists(*datum_beginn, *datum_ende,
				&app->list_dienst,
				&app->list_einzeltermin, &app->list_serientermin, &app->list_tgruppe,
				&app->list_mini, &app->list_mgruppe, &app->list_fehlzeit,
				list_dienst, &list_termin_paar, list_mini, list_mgruppe, list_fehlzeit);
		//reminiscence of old times (division might be useful)
		TerminCreator::fillMLists(&list_termin_paar, list_mini, &app->list_fehlzeit, list_dienst);
		TerminCreator::createTerminList(&list_termin_paar, list_termin);
		//**********************************************************************
		notifyTermine();
		notifyTGruppen();
		setModusTermine();
	} else {
		//prepare ids
		int counter = 0;
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			(**iter)._id = counter++;
		}

		//generate data for file
		wxString text = createData();
		wxFileDialog saveFileDialog(this, wxT("Datei speichern"), wxT("output"), wxT("MiniInterface.dat"), wxT("MiniInterface.dat"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		if (saveFileDialog.ShowModal() == wxID_CANCEL) {
			return;
		}
		wxFileOutputStream output_stream(saveFileDialog.GetPath());
		if (!output_stream.IsOk()) {
			return;
		}
		wxScopedCharBuffer text_utf8 = text.ToUTF8();
		output_stream.Write(text_utf8, text_utf8.length());
		output_stream.Close();

		//closing
		Close(true);
	}
}

void PlanerMiniInterfaceDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

void PlanerMiniInterfaceDialog::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		edtTermin(i);
		break;
	}
}

void PlanerMiniInterfaceDialog::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) delTermin(i);
		break;
	}
}

void PlanerMiniInterfaceDialog::onBtImpPull(wxCommandEvent&) {
	//tidy up from exp
	for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
		delete *iter;
	}
	for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
		delete *iter;
	}
	for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
		delete *iter;
	}
	for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
		delete *iter;
	}
	for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
		delete *iter;
	}
	list_dienst->clear();
	list_termin->clear();
	list_mini->clear();
	list_mgruppe->clear();
	list_fehlzeit->clear();
	setModusZeitraum();
	//done
	if (readData()) {
		*edt = true;
		deleteContents = false;
		wxMessageBox(wxT("Daten erfolgreich verarbeitet!"), wxT("Meldung"), wxICON_EXCLAMATION);
		Close(true);
	} else {
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			delete *iter;
		}
		list_dienst->clear();
		list_termin->clear();
		list_mini->clear();
		list_mgruppe->clear();
		list_fehlzeit->clear();
		wxMessageBox(wxT("Daten aus Zwischenablage konnten nicht korrekt verarbeitet werden!"), wxT("Fehler"), wxICON_ERROR);
	}
}

bool PlanerMiniInterfaceDialog::readData() {
	if (wxTheClipboard->Open()) {
		wxString D = DataFileHandler::D;
		wxTextDataObject data;
		wxTheClipboard->GetData(data);
		wxTheClipboard->Close();
		wxString text = data.GetText();
		wxStringTokenizer zr(text, wxT("\n"), wxTOKEN_RET_EMPTY_ALL);
		//datum
		wxStringTokenizer zr_1(zr.NextToken(), D, wxTOKEN_RET_EMPTY_ALL);
		*datum_beginn = Util::wxString_to_wxDateTime(zr_1.NextToken());
		*datum_ende = Util::wxString_to_wxDateTime(zr_1.NextToken());
		//dienste
		int num_dienste;
		if (!safeAtoi(zr_1.NextToken(), &num_dienste)) return false;
		for (int i = 0; i < num_dienste; i++) {
			list_dienst->push_back(new Dienst(zr_1.NextToken()));
		}
		//termine
		std::vector<std::pair<int, std::pair<int, int> > > termin_prev_next;
		int num_termine;
		if (!safeAtoi(zr.NextToken(), &num_termine)) return false;
		for (int i = 0; i < num_termine; i++) {
			wxStringTokenizer zr_2(zr.NextToken(), D, wxTOKEN_RET_EMPTY_ALL);
			wxString name = zr_2.NextToken();
			wxString ort = zr_2.NextToken();
			wxDateTime datum = Util::wxString_to_wxDateTime(zr_2.NextToken());
			wxString zeit_beginn = zr_2.NextToken();
			int prev;
			if (!safeAtoi(zr_2.NextToken(), &prev)) return false;
			int next;
			if (!safeAtoi(zr_2.NextToken(), &next)) return false;
			termin_prev_next.push_back(std::make_pair(i, std::make_pair(prev, next)));
			wxString bem = zr_2.NextToken();
			std::vector<std::pair<Dienst*, int> > list_num;
			while (zr_2.HasMoreTokens()) {
				int id;
				if (!safeAtoi(zr_2.NextToken(), &id)) return false;
				int num;
				if (!safeAtoi(zr_2.NextToken(), &num)) return false;
				list_num.push_back(std::make_pair(list_dienst->at(id), num));
			}
			PTermin* termin = new PTermin(name, ort, datum, zeit_beginn, bem, list_num);
			list_termin->push_back(termin);
		}
		//set links prev-next
		for (std::vector<std::pair<int, std::pair<int, int> > >::iterator iter_t = termin_prev_next.begin(); iter_t != termin_prev_next.end(); iter_t++) {
			if (iter_t->second.first != -1) {
				list_termin->at(iter_t->first)->prev = list_termin->at(iter_t->second.first);
			}
			if (iter_t->second.second != -1) {
				list_termin->at(iter_t->first)->next = list_termin->at(iter_t->second.second);
			}
		}
		//minis
		int num_minis;
		if (!safeAtoi(zr.NextToken(), &num_minis)) return false;
		std::vector< std::pair<PMessdiener*, std::vector<int> > > list_mini_anw;
		for (int i = 0; i < num_minis; i++) {
			wxStringTokenizer zr_3(zr.NextToken(), D, wxTOKEN_RET_EMPTY_ALL);
			wxString name = zr_3.NextToken();
			wxString vorname = zr_3.NextToken();
			std::vector<Dienst*> dienste;
			while (zr_3.HasMoreTokens()) {
				int id;
				if (!safeAtoi(zr_3.NextToken(), &id)) return false;
				dienste.push_back(list_dienst->at(id));
			}
			PMessdiener* mini = new PMessdiener(name, vorname, dienste);
			list_mini->push_back(mini);
			//anw
			std::vector<int> list_anw;
			wxStringTokenizer zr_3_2(zr.NextToken(), D, wxTOKEN_RET_EMPTY_ALL);
			for (int j = 0; j < num_termine; j++) {
				int id;
				if (!safeAtoi(zr_3_2.NextToken(), &id)) return false;
				list_anw.push_back(id);
			}
			list_mini_anw.push_back(std::make_pair(mini, list_anw));
		}
		//mgruppen
		int num_mgruppen;
		if (!safeAtoi(zr.NextToken(), &num_mgruppen)) return false;
		for (int i = 0; i < num_mgruppen; i++) {
			wxStringTokenizer zr_4(zr.NextToken(), D, wxTOKEN_RET_EMPTY_ALL);
			int modus;
			if (!safeAtoi(zr_4.NextToken(), &modus)) return false;
			std::vector<PMessdiener*> mlist;
			while (zr_4.HasMoreTokens()) {
				int id;
				if (!safeAtoi(zr_4.NextToken(), &id)) return false;
				mlist.push_back(list_mini->at(id));
			}
			list_mgruppe->push_back(new PMGruppe(modus, mlist));
		}
		//set missing links Minis-MGruppen
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			for (std::vector<PMessdiener*>::iterator iter_m = (**iter).list.begin(); iter_m != (**iter).list.end(); iter_m++) {
				(**iter_m).gruppe = *iter;
			}
		}
		//fehlzeiten
		int num_fehlzeiten;
		if (!safeAtoi(zr.NextToken(), &num_fehlzeiten)) return false;
		for (int i = 0; i < num_fehlzeiten; i++) {
			wxStringTokenizer zr_5(zr.NextToken(), D, wxTOKEN_RET_EMPTY_ALL);
			zr_5.NextToken(); //Modus
			int id;
			if (!safeAtoi(zr_5.NextToken(), &id)) return false;
			PMessdiener* m = list_mini->at(id);
			wxDateTime datum_beginn = Util::wxString_to_wxDateTime(zr_5.NextToken());
			wxDateTime datum_ende = Util::wxString_to_wxDateTime(zr_5.NextToken());
			list_fehlzeit->push_back(new PFehlzeit(m, datum_beginn, datum_ende));
		}
		//prepare ids
		int counter = 0;
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			(**iter)._id = counter++;
		}
		////termin lists
		//fill lists according to abilities
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_dienst_minis;
		for (std::vector<Dienst*>::iterator iter_d = list_dienst->begin(); iter_d != list_dienst->end(); iter_d++) {
			std::vector<PMessdiener*> m_liste;
			for (std::vector<PMessdiener*>::iterator iter_m = list_mini->begin(); iter_m != list_mini->end(); iter_m++) {
				if (std::find((**iter_m).dienste.begin(), (**iter_m).dienste.end(), *iter_d) != (**iter_m).dienste.end()) {
					m_liste.push_back(*iter_m);
				}
			}
			list_dienst_minis.push_back(std::make_pair(*iter_d, m_liste));
		}
		//fill list_dienst_minis (with ZEROs) and list_dienst_minis_possible (according to above abilities)
		for (std::vector<PTermin*>::iterator iter_t = list_termin->begin(); iter_t != list_termin->end(); iter_t++) {
			for (std::vector<std::pair<Dienst*, int> >::iterator iter_d = (**iter_t).list_dienst_num.begin(); iter_d != (**iter_t).list_dienst_num.end(); iter_d++) {
				std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_list = list_dienst_minis.begin();
				for (; iter_list->first != iter_d->first; iter_list++) {
				}
				(**iter_t).list_dienst_minis_possible.push_back(*iter_list);
				//fill in same order and initiate with NULL pointers (needed later and for file)
				std::vector<PMessdiener*> mset;
				mset.reserve(iter_d->second);
				for (int i = 0; i < iter_d->second; i++) {
					mset.push_back(NULL);
				}
				(**iter_t).list_dienst_minis.push_back(std::make_pair(iter_list->first, mset));
			}
		}
		//abwesenheiten
		for (int i = 0; i < num_minis; i++) {
			for (int j = 0; j < num_termine; j++) {
				if (list_mini_anw.at(i).second.at(j) == ANW_NEIN) {
					for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_poss = list_termin->at(j)->list_dienst_minis_possible.begin();
							iter_poss != list_termin->at(j)->list_dienst_minis_possible.end(); iter_poss++) {
						Util::erase_from_minivec(&iter_poss->second, list_mini->at(i));
					}
				}
			}
		}
		//fill avai
		for (int j = 0; j < num_termine; j++) {
			for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_poss = list_termin->at(j)->list_dienst_minis_possible.begin();
					iter_poss != list_termin->at(j)->list_dienst_minis_possible.end(); iter_poss++) {
				list_termin->at(j)->list_dienst_minis_available.push_back(*iter_poss);
			}
		}
		//anwesenheiten
		if (cb_imp_anw->IsChecked()) {
			std::random_shuffle(list_mini_anw.begin(), list_mini_anw.end());
			for (int j = 0; j < num_termine; j++) {
				PTermin* termin = list_termin->at(j);
				int num_dienste = termin->list_dienst_num.size();
				std::random_shuffle(list_mini_anw.begin(), list_mini_anw.end());
				for (int i = 0; i < num_minis; i++) {
					if (list_mini_anw.at(i).second.at(j) == ANW_JA) {
						PMessdiener* mini = list_mini_anw.at(i).first;
						for (int k = num_dienste - 1; k >= 0; k--) {
							//calculate req
							int num_req = termin->list_dienst_num.at(k).second;
							for (std::vector<PMessdiener*>::iterator iter = termin->list_dienst_minis.at(k).second.begin(); iter != termin->list_dienst_minis.at(k).second.end(); iter++) {
								if (*iter != NULL) num_req--;
							}
							if (num_req > 0 && std::find(termin->list_dienst_minis_available.at(k).second.begin(), termin->list_dienst_minis_available.at(k).second.end(), mini)
									!= termin->list_dienst_minis_available.at(k).second.end()) {
								std::vector<PMessdiener*>::iterator iter = termin->list_dienst_minis.at(k).second.begin();
								while (*iter != NULL) iter++;
								*iter = mini;
								mini->num++;
								num_req--;
								for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_d = termin->list_dienst_minis_available.begin(); iter_d != termin->list_dienst_minis_available.end(); iter_d++) {
									Util::erase_from_minivec(&iter_d->second, mini);
								}
								break;
							}
						}
					}
				}
			}
		}
	}
	return true;
}

bool PlanerMiniInterfaceDialog::safeAtoi(wxString text, int* var) {
	if (text.IsEmpty() || !text.IsNumber()) return false;
	*var = wxAtoi(text);
	return true;
}

void PlanerMiniInterfaceDialog::onLIActivated(wxListEvent& evt) {
	edtTermin(evt.GetItem().GetId());
}

void PlanerMiniInterfaceDialog::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) delTermin(i);
			break;
		}
	}
}

void PlanerMiniInterfaceDialog::onClose(wxCloseEvent& evt) {
	if (deleteContents) {
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			delete *iter;
		}
	}
	evt.Skip();
}

===== ./src/export/MiniExportDialog.cpp =====
/* 
 * File:   MiniExportDialog.cpp
 * Author: Yannik
 * 
 * Created on October 2, 2015, 7:46 PM
 */

#include "MiniExportDialog.h"
#include <wx/clipbrd.h>
#include <wx/filedlg.h>
#include <wx/statline.h>
#include <wx/wfstream.h>

MiniExportDialog::MiniExportDialog(wxWindow* parent, std::vector<Messdiener*>* _list_mini)
: wxDialog(parent, R::ID_ANY, R::MINI_EXPORT_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	list_mini = _list_mini;
	wxBoxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);

	wxBoxSizer* sizer_l = new wxBoxSizer(wxVERTICAL);
	wxStaticText* st_spalten = new wxStaticText(this, R::ID_ANY, R::SPALTEN);
	sizer_l->Add(st_spalten, 0, wxEXPAND | wxALL, 2);
	cb_num = new wxCheckBox(this, R::ID_ANY, wxT("(") + R::NUM + wxT(")"));
	cb_num->SetValue(false);
	sizer_l->Add(cb_num, 0, wxEXPAND | wxALL, 2);
	for (int i = 0; i < R::MINI_ATTS_NUM; i++) {
		cb_cols[i] = new wxCheckBox(this, R::ID_ANY, R::MINI_ATTS[i]);
		if (i == 2 || i == 9) cb_cols[i]->SetValue(false);
		else cb_cols[i]->SetValue(true);
		sizer_l->Add(cb_cols[i], 0, wxEXPAND | wxALL, 2);
	}
	sizer->Add(sizer_l, 1, wxEXPAND | wxALL, 5);

	sizer->Add(new wxStaticLine(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxLI_VERTICAL), 0, wxEXPAND | wxALL, 5);

	wxBoxSizer* sizer_r = new wxBoxSizer(wxVERTICAL);
	rb_file = new wxRadioButton(this, R::ID_ANY, R::DATEI_AUSGABE, wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
	sizer_r->Add(rb_file, 0, wxEXPAND, 0);
	rb_clipboard = new wxRadioButton(this, R::ID_ANY, R::CLIPBOARD_AUSGABE);
	sizer_r->Add(rb_clipboard, 0, 0, 0);
	sizer_r->AddSpacer(10);
	bt_html = new wxButton(this, R::ID_BT_ADD2, wxT("HTML"));
	sizer_r->Add(bt_html, 0, wxEXPAND, 0);
	bt_csv = new wxButton(this, R::ID_BT_DEL, wxT("Tab-CSV"));
	sizer_r->Add(bt_csv, 0, wxEXPAND, 0);
	bt_excel_xml = new wxButton(this, R::ID_BT_DEL2, wxT("Excel-XML"));
	sizer_r->Add(bt_excel_xml, 0, wxEXPAND, 0);
	sizer->Add(sizer_r, 0, wxEXPAND | wxALL, 5);

	SetSizerAndFit(sizer);
}

wxString MiniExportDialog::createHTML() {
	wxString page = wxT("<!DOCTYPE html>\n<html>\n	<head>\n		<title>") + R::MESSDIENERLISTE + wxT("</title>"
			"\n		<meta charset=\"utf-8\"/>"
			"\n		<meta name=\"description\" content=\"MiniPlaner Messdienerliste\"/>"
			"\n		<meta name=\"keywords\" content=\"MiniPlaner, Messdienerliste\"/>"
			"\n		<meta name=\"author\" content=\"Yannik Schälte\"/>"
			"\n		<style>"
			"\n		td {padding: 3px;}"
			"\n		.phead {font-weight: bold;}"
			"\n		.num {text-align: right;}"
			"\n		</style>"
			"\n	</head>");
	page += wxT("\n	<body>\n		<table>\n			<tr>");
	//header
	if (cb_num->GetValue()) page += wxT("<td class=\"phead\"></td>");
	for (int i = 0; i < R::MINI_ATTS_NUM; i++) {
		if (cb_cols[i]->GetValue()) {
			page += wxT("<td class=\"phead\">") + R::MINI_ATTS[i] + wxT("</td>");
		}
	}
	page += wxT("</tr>");
	//list
	int num_minis = list_mini->size();
	for (int i = 0; i < num_minis; i++) {
		Messdiener* m = list_mini->at(i);
		page += wxT("\n			<tr>");
		if (cb_num->GetValue()) page += wxT("<td class=\"num\">") + wxString::Format(wxT("%i"), i + 1) + wxT("</td>");
		if (cb_cols[0]->GetValue()) page += wxT("<td>") + m->name + wxT("</td>");
		if (cb_cols[1]->GetValue()) page += wxT("<td>") + m->vorname + wxT("</td>");
		if (cb_cols[2]->GetValue()) page += wxT("<td>") + Messdiener::printDienste(m) + wxT("</td>");
		if (cb_cols[3]->GetValue()) page += wxT("<td>&#8203;") + m->geburtstag + wxT("</td>");
		if (cb_cols[4]->GetValue()) page += wxT("<td>") + m->strasse_nr + wxT("</td>");
		if (cb_cols[5]->GetValue()) page += wxT("<td>") + m->plz_ort + wxT("</td>");
		if (cb_cols[6]->GetValue()) page += wxT("<td>&#8203;") + m->tel + wxT("</td>");
		if (cb_cols[7]->GetValue()) page += wxT("<td>&#8203;") + m->mobile + wxT("</td>");
		if (cb_cols[8]->GetValue()) page += wxT("<td>") + m->email + wxT("</td>");
		if (cb_cols[9]->GetValue()) page += wxT("<td>&#8203;") + m->bem + wxT("</td>");
		page += wxT("</tr>");
	}
	page += wxT("\n		</table>\n	</body>\n</html>");
	return page;
}

wxString MiniExportDialog::createCSV() {
	wxString page = wxT("sep=") + D + N;
	//header
	if(cb_num->GetValue()) page += D;
	for (int i = 0; i < R::MINI_ATTS_NUM; i++) {
		if (cb_cols[i]->GetValue()) {
			page += R::MINI_ATTS[i] + D;
		}
	}
	page += N;
	//list
	int num_minis = list_mini->size();
	for (int i = 0; i < num_minis; i++) {
		Messdiener* m = list_mini->at(i);
		if (cb_num->GetValue()) page += wxString::Format(wxT("%i"), i + 1) + D;
		if (cb_cols[0]->GetValue()) page += m->name + D;
		if (cb_cols[1]->GetValue()) page += m->vorname + D;
		if (cb_cols[2]->GetValue()) page += Messdiener::printDienste(m) + D;
		if (cb_cols[3]->GetValue()) page += m->geburtstag + D;
		if (cb_cols[4]->GetValue()) page += m->strasse_nr + D;
		if (cb_cols[5]->GetValue()) page += m->plz_ort + D;
		if (cb_cols[6]->GetValue()) page += m->tel + D;
		if (cb_cols[7]->GetValue()) page += m->mobile + D;
		if (cb_cols[8]->GetValue()) page += m->email + D;
		if (cb_cols[9]->GetValue()) page += m->bem + D;
		page += N;
	}
	return page;
}

wxString MiniExportDialog::createExcelXML() {
	wxString page = wxT("<?xml version=\"1.0\" encoding=\"utf-8\"?>"
			"<?mso-application progid=\"Excel.Sheet\"?>"
			"<Workbook"
			" xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\""
			" xmlns:o=\"urn:schemas-microsoft-com:office:office\""
			" xmlns:x=\"urn:schemas-microsoft-com:office:excel\""
			" xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\""
			" xmlns:html=\"http://www.w3.org/TR/REC-html40\">");
	page += wxT("<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">"
			"<Author>Yannik Schälte</Author>"
			"<Version>2.0</Version>"
			"</DocumentProperties>");
	page += wxT("<Styles>"
			"<Style ss:ID=\"Default\" ss:Name=\"Normal\">"
			"<Alignment ss:Vertical=\"Bottom\" />"
			"</Style>"
			"<Style ss:ID=\"sphead\">"
			"<Font x:Family=\"Swiss\" ss:Bold=\"1\" />"
			"</Style>"
			"</Styles>");
	page += wxT("<Worksheet ss:Name=\"") + R::MESSDIENERLISTE + wxT("\">"
			"<Table>");
	//header
	page += wxT("<Row>");
	if(cb_num->GetValue()) page += wxT("<Cell ss:StyleID=\"sphead\"></Cell>");
	for (int i = 0; i < R::MINI_ATTS_NUM; i++) {
		if (cb_cols[i]->GetValue()) {
			page += wxT("<Cell ss:StyleID=\"sphead\"><Data ss:Type=\"String\">") + R::MINI_ATTS[i] + wxT("</Data></Cell>");
		}
	}
	page += wxT("</Row>");
	//list
	int num_minis = list_mini->size();
	for (int i = 0; i < num_minis; i++) {
		Messdiener* m = list_mini->at(i);
		page += wxT("<Row>");
		if (cb_num->GetValue()) page += wxT("<Cell><Data ss:Type=\"Number\">") + wxString::Format(wxT("%i"), i + 1) + wxT("</Data></Cell>");
		if (cb_cols[0]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">") + m->name + wxT("</Data></Cell>");
		if (cb_cols[1]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">") + m->vorname + wxT("</Data></Cell>");
		if (cb_cols[2]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">") + Messdiener::printDienste(m) + wxT("</Data></Cell>");
		if (cb_cols[3]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">&#8203;") + m->geburtstag + wxT("</Data></Cell>");
		if (cb_cols[4]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">") + m->strasse_nr + wxT("</Data></Cell>");
		if (cb_cols[5]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">") + m->plz_ort + wxT("</Data></Cell>");
		if (cb_cols[6]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">&#8203;") + m->tel + wxT("</Data></Cell>");
		if (cb_cols[7]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">&#8203;") + m->mobile + wxT("</Data></Cell>");
		if (cb_cols[8]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">") + m->email + wxT("</Data></Cell>");
		if (cb_cols[9]->GetValue()) page += wxT("<Cell><Data ss:Type=\"String\">&#8203;") + m->bem + wxT("</Data></Cell>");
		page += wxT("</Row>");
	}
	page += wxT("</Table></Worksheet></Workbook>");
	return page;
}

BEGIN_EVENT_TABLE(MiniExportDialog, wxDialog)
EVT_BUTTON(R::ID_BT_ADD2, MiniExportDialog::onBtHTML)
EVT_BUTTON(R::ID_BT_DEL, MiniExportDialog::onBtCSV)
EVT_BUTTON(R::ID_BT_DEL2, MiniExportDialog::onBtExcelXML)
END_EVENT_TABLE()

void MiniExportDialog::onBtHTML(wxCommandEvent&) {
	wxString text = createHTML();
	if (rb_file->GetValue()) {
		wxFileDialog saveFileDialog(this, R::SPEICHERN_HTML, wxT("output"), R::MESSDIENERLISTE_SH + wxT(".html"), wxT("*.*"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		if (saveFileDialog.ShowModal() == wxID_CANCEL) {
			return;
		}
		wxFileOutputStream output_stream(saveFileDialog.GetPath());
		if (!output_stream.IsOk()) {
			return;
		}
		wxScopedCharBuffer text_utf8 = text.ToUTF8();
		output_stream.Write(text_utf8, text_utf8.length());
		output_stream.Close();
	} else {
		if (wxTheClipboard->Open()) {
			wxTheClipboard->SetData(new wxTextDataObject(text));
			wxTheClipboard->Close();
		}
	}
}

void MiniExportDialog::onBtCSV(wxCommandEvent&) {
	wxString text = createCSV();
	if (rb_file->GetValue()) {
		wxFileDialog saveFileDialog(this, R::SPEICHERN_HTML, wxT("output"), R::MESSDIENERLISTE_SH + wxT(".csv"), wxT("*.*"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		if (saveFileDialog.ShowModal() == wxID_CANCEL) {
			return;
		}
		wxFileOutputStream output_stream(saveFileDialog.GetPath());
		if (!output_stream.IsOk()) {
			return;
		}
		wxScopedCharBuffer text_utf8 = text.ToUTF8();
		output_stream.Write(text_utf8, text_utf8.length());
		output_stream.Close();
	} else {
		if (wxTheClipboard->Open()) {
			wxTheClipboard->SetData(new wxTextDataObject(text));
			wxTheClipboard->Close();
		}
	}
}

void MiniExportDialog::onBtExcelXML(wxCommandEvent&) {
	wxString text = createExcelXML();
	if (rb_file->GetValue()) {
		wxFileDialog saveFileDialog(this, R::SPEICHERN_HTML, wxT("output"), R::MESSDIENERLISTE_SH + wxT(".xml"), wxT("*.*"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		if (saveFileDialog.ShowModal() == wxID_CANCEL) {
			return;
		}
		wxFileOutputStream output_stream(saveFileDialog.GetPath());
		if (!output_stream.IsOk()) {
			return;
		}
		wxScopedCharBuffer text_utf8 = text.ToUTF8();
		output_stream.Write(text_utf8, text_utf8.length());
		output_stream.Close();
	} else {
		if (wxTheClipboard->Open()) {
			wxTheClipboard->SetData(new wxTextDataObject(text));
			wxTheClipboard->Close();
		}
	}
}

===== ./src/export/PlanerMiniInterfaceDialog.h =====
/* 
 * File:   PlanerMiniInterfaceDialog.h
 * Author: Yannik
 *
 * Created on March 22, 2016, 2:54 PM
 */

#ifndef PLANERMINIINTERFACEDIALOG_H
#define	PLANERMINIINTERFACEDIALOG_H

#include <wx/wx.h>
#include <wx/calctrl.h>
#include <wx/notebook.h>
#include <wx/listctrl.h>
#include <wx/datetime.h>
#include <vector>
#include "../model-data/Dienst.h"
#include "../controller-plan/TerminCreator.h"
#include "../model-plan/PTermin.h"
#include "../model-plan/PMessdiener.h"
#include "../model-plan/PFehlzeit.h"
#include <wx/choicebk.h>
class App;

class PlanerMiniInterfaceDialog : public wxDialog {
public:
	static const int ANW_VIELLEICHT = 0;
	static const int ANW_JA = 1;
	static const int ANW_NEIN = 2;
	static const int MODUS_ZEITRAUM = 0;
	static const int MODUS_TERMINE = 1;
	PlanerMiniInterfaceDialog(wxWindow* parent, App* _app, bool* _edt,
			wxDateTime* _datum_beginn,
			wxDateTime* _datum_ende,
			std::vector<Dienst*>* _list_dienst,
			std::vector<PTermin*>* _list_termin,
			std::vector<PMessdiener*>* _list_mini,
			std::vector<PMGruppe*>* _list_mgruppe,
			std::vector<PFehlzeit*>* _list_fehlzeit);
private:
	App* app;
	int modus;
	wxDateTime* datum_beginn;
	wxDateTime* datum_ende;
	bool* edt;
	std::vector<Dienst*>* list_dienst;
	std::vector<PTermin*>* list_termin;
	std::vector<PMessdiener*>* list_mini;
	std::vector<PMGruppe*>* list_mgruppe;
	std::vector<PFehlzeit*>* list_fehlzeit;
	bool deleteContents;
	
	wxPanel* pl_1;
	wxPanel* pl_2;

	//Zeitraum
	wxPanel* pl_zeitraum;
	wxStaticText* st_beginn;
	wxCalendarCtrl* cl_beginn;
	wxStaticText* st_ende;
	wxCalendarCtrl* cl_ende;

	//Termine
	wxNotebook* nb_termine;
	wxPanel* nb_pl_termine;
	wxPanel* nb_pl_tgruppen;
	wxListView* lv_termine;
	wxButton* bt_termine_edt;
	wxButton* bt_termine_del;
	wxListView* lv_tgruppen;

	wxButton* bt_back;
	wxButton* bt_cont;
	wxButton* bt_cancel;
	
	//Import
	wxStaticText* st_imp_text;
	wxButton* bt_imp_pull;
	wxCheckBox* cb_imp_anw;
	wxButton* bt_imp_cancel;

	void initComponents();
	void setModusZeitraum();
	void setModusTermine();
	void notifyTermine(int index = -1);
	void notifyTGruppen();
	void edtTermin(int index);
	void delTermin(int index);
	wxString createData();
	bool readData();
	bool safeAtoi(wxString text, int* var);
	DECLARE_EVENT_TABLE();
	void onBtBack(wxCommandEvent&);
	void onBtCont(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtImpPull(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
	void onClose(wxCloseEvent& evt);
};

#endif	/* PLANERMINIINTERFACEDIALOG_H */

===== ./src/App.cpp =====
/* 
 * File:   App.cpp
 * Author: Yannik
 * 
 * Created on August 11, 2015, 4:00 PM
 */

#include "App.h"
#include "file/DataFileHandler.h"
#include "file/PlanFileHandler.h"
#include "model-plan/Planer.h"
#include "view-plan/PlanPlanerDialog.h"
#include <algorithm>
#include <set>
#include "update/UpdateChecker.h"
#include "Util.h"

bool App::OnInit() {
	//limited access
	/**wxDateTime today = wxDateTime::Today();
	wxDateTime maximum_date(31, wxDateTime::Dec, 2015);
	if (today.IsLaterThan(maximum_date)) {
		wxMessageDialog dialog(NULL, wxT("Diese Test-Version war nur zeitlich begrenzt verfügbar."), wxMessageBoxCaptionStr, wxOK | wxCENTRE | wxICON_ERROR);
		dialog.ShowModal();
		return false;
	}**/

	single_instance_checker = new wxSingleInstanceChecker;
	if (single_instance_checker->IsAnotherRunning()) {
		delete single_instance_checker;
		return false;
	}

	DataFileHandler::prepareFiles();
	DataFileHandler::implementUpdates();
	DataFileHandler::loadSettings();
	DataFileHandler::loadDienste(&list_dienst);
	updateIntNumDienste();
	DataFileHandler::loadMinis(&list_dienst, &list_mini);
	updateIntNumMinis();
	DataFileHandler::loadEinzeltermine(&list_dienst, &list_einzeltermin);
	updateIntNumEinzeltermine();
	DataFileHandler::loadSerientermine(&list_dienst, &list_serientermin);
	updateIntNumSerientermine();
	DataFileHandler::loadMGruppen(&list_mini, &list_mgruppe);
	DataFileHandler::loadTGruppen(&list_einzeltermin, &list_serientermin, &list_tgruppe);
	DataFileHandler::loadFehlzeiten(&list_mini, &list_einzeltermin, &list_serientermin, &list_fehlzeit);
	DataFileHandler::loadPlanerInfos(&list_planer);
	initOrte();
	initPLZOrte();
	wxDialog::EnableLayoutAdaptation(true);
	frame = new MainFrame(this);
	UpdateChecker::checkUpdate(frame);
	return true;
}

int App::OnExit() {
	for (std::vector<Dienst*>::iterator iter = list_dienst.begin(); iter != list_dienst.end(); iter++) {
		delete *iter;
	}
	for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		delete *iter;
	}
	for (std::vector<MGruppe*>::iterator iter = list_mgruppe.begin(); iter != list_mgruppe.end(); iter++) {
		delete *iter;
	}
	for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end(); iter++) {
		delete *iter;
	}
	for (std::vector<Serientermin*>::iterator iter = list_serientermin.begin(); iter != list_serientermin.end(); iter++) {
		delete *iter;
	}
	for (std::vector<TGruppe*>::iterator iter = list_tgruppe.begin(); iter != list_tgruppe.end(); iter++) {
		delete *iter;
	}
	for (std::vector<Fehlzeit*>::iterator iter = list_fehlzeit.begin(); iter != list_fehlzeit.end(); iter++) {
		delete *iter;
	}
	DataFileHandler::saveSettings();
	delete single_instance_checker;
	single_instance_checker = 0;
	return 0;
}

bool App::addDienst(Dienst* dienst) {
	for (std::vector<Dienst*>::iterator iter = list_dienst.begin(); iter != list_dienst.end(); iter++) {
		if (Dienst::equal(*iter, dienst)) {
			return false;
		}
	}
	list_dienst.push_back(dienst);

	sortDienste();
	updateIntNumDienste();

	frame->notifyDienste(dienst->_id);

	DataFileHandler::saveDienste(&list_dienst);
	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveSerientermine(&list_serientermin);
	return true;
}

void App::delDienst(int index) {
	Dienst* d = list_dienst.at(index);
	//handle Minis
	for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		for (std::vector<Dienst*>::iterator iter_d = (**iter).dienste.begin(); iter_d != (**iter).dienste.end(); iter_d++) {
			if (*iter_d == d) {
				(**iter).dienste.erase(iter_d);
				break;
			}
		}
	}
	//handle Termine
	for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end(); iter++) {
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_d = (**iter).dienste.begin(); iter_d != (**iter).dienste.end(); iter_d++) {
			if (iter_d->first == d) {
				(**iter).dienste.erase(iter_d);
				break;
			}
		}
	}
	for (std::vector<Serientermin*>::iterator iter = list_serientermin.begin(); iter != list_serientermin.end(); iter++) {
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_d = (**iter).dienste.begin(); iter_d != (**iter).dienste.end(); iter_d++) {
			if (iter_d->first == d) {
				(**iter).dienste.erase(iter_d);
				break;
			}
		}
	}
	delete d;
	list_dienst.erase(list_dienst.begin() + index);

	frame->notifyDienste();
	frame->notifyMinis();
	frame->notifyEinzeltermine();
	frame->notifySerientermine();
	frame->notifyTGruppen();
	frame->notifyFehlzeiten();

	updateIntNumDienste();

	DataFileHandler::saveDienste(&list_dienst);
	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveSerientermine(&list_serientermin);
}

bool App::edtDienst(int index, const Dienst* d_to) {
	Dienst* d_from = list_dienst.at(index);
	for (std::vector<Dienst*>::iterator iter = list_dienst.begin(); iter != list_dienst.end(); iter++) {
		if (Dienst::equal(*iter, d_to) && *iter != d_from) {
			return false;
		}
	}
	*d_from = *d_to;

	sortDienste();
	updateIntNumDienste();

	frame->notifyDienste(d_from->_id);

	frame->notifyMinis();
	frame->notifyEinzeltermine();
	frame->notifySerientermine();
	frame->notifyTGruppen();
	frame->notifyFehlzeiten();

	DataFileHandler::saveDienste(&list_dienst);
	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveSerientermine(&list_serientermin);
	return true;
}

bool App::addMini(Messdiener* mini) {
	for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		if (Messdiener::equal(*iter, mini)) {
			return false;
		}
	}
	list_mini.push_back(mini);

	sortMinis();
	updateIntNumMinis();

	frame->notifyMinis(mini->_id);

	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveMGruppen(&list_mgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	addPLZOrt(mini->plz_ort);
	return true;
}

void App::delMini(int index) {
	//handle MGruppen
	Messdiener* m = list_mini.at(index);
	for (std::vector<MGruppe*>::iterator iter = list_mgruppe.begin(); iter != list_mgruppe.end();) {
		for (std::vector<Messdiener*>::iterator iter_m = (**iter).list.begin(); iter_m != (**iter).list.end(); iter_m++) {
			if (m == *iter_m) {
				(**iter).list.erase(iter_m);
				break;
			}
		}
		if ((**iter).list.size() < 2) {
			delete *iter;
			iter = list_mgruppe.erase(iter);
		} else {
			iter++;
		}
	}
	//handle Fehlzeiten
	for (std::vector<Fehlzeit*>::iterator iter = list_fehlzeit.begin(); iter != list_fehlzeit.end();) {
		if (m == (**iter).mini) {
			delete *iter;
			iter = list_fehlzeit.erase(iter);
		} else {
			iter++;
		}
	}
	//erase and show
	delete m;
	list_mini.erase(list_mini.begin() + index);

	frame->notifyMinis();
	frame->notifyMGruppen();
	frame->notifyFehlzeiten();

	updateIntNumMinis();

	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveMGruppen(&list_mgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
}

bool App::edtMini(int index, const Messdiener* m_to) {
	Messdiener* m_from = list_mini.at(index);
	for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		if (Messdiener::equal(*iter, m_to) && *iter != m_from) {
			return false;
		}
	}
	*m_from = *m_to;

	sortMinis();
	updateIntNumMinis();

	frame->notifyMinis(m_from->_id);

	//handle MGruppen
	int mgruppe_size = list_mgruppe.size();
	for (int i = 0; i < mgruppe_size; i++) {
		MGruppe mc = *(list_mgruppe.at(i));
		std::sort(mc.list.begin(), mc.list.end(), Messdiener::cmp);
	}
	sortMGruppen();
	frame->notifyMGruppen();
	sortFehlzeiten();
	frame->notifyFehlzeiten();

	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveMGruppen(&list_mgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	addPLZOrt(m_from->plz_ort);
	return true;
}

bool App::addEinzeltermin(Einzeltermin* termin) {
	for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end(); iter++) {
		if (Einzeltermin::equal(*iter, termin)) {
			return false;
		}
	}
	list_einzeltermin.push_back(termin);

	sortEinzeltermine();
	updateIntNumEinzeltermine();

	frame->notifyEinzeltermine(termin->_id);

	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveTGruppen(&list_tgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	addOrt(termin->ort);
	return true;
}

void App::delEinzeltermin(int index) {
	//handle TGruppen
	Einzeltermin* t = list_einzeltermin.at(index);
	for (std::vector<TGruppe*>::iterator iter_tg = list_tgruppe.begin(); iter_tg != list_tgruppe.end();) {
		for (std::vector<Einzeltermin*>::iterator iter_t = (**iter_tg).list_einzel.begin(); iter_t != (**iter_tg).list_einzel.end(); iter_t++) {
			if (t == *iter_t) {
				(**iter_tg).list_einzel.erase(iter_t);
				break;
			}
		}
		if ((**iter_tg).list_einzel.size() + (**iter_tg).list_serie.size() < 2) {
			delete *iter_tg;
			iter_tg = list_tgruppe.erase(iter_tg);
		} else {
			iter_tg++;
		}
	}
	//handle Fehlzeiten
	for (std::vector<Fehlzeit*>::iterator iter_f = list_fehlzeit.begin(); iter_f != list_fehlzeit.end();) {
		if ((**iter_f).modus == Fehlzeit::EINZELTERMIN && t == (**iter_f).einzeltermin) {
			delete *iter_f;
			iter_f = list_fehlzeit.erase(iter_f);
		} else {
			iter_f++;
		}
	}
	delete t;
	list_einzeltermin.erase(list_einzeltermin.begin() + index);

	frame->notifyEinzeltermine();
	frame->notifyTGruppen();
	frame->notifyFehlzeiten();

	updateIntNumEinzeltermine();

	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveTGruppen(&list_tgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
}

bool App::edtEinzeltermin(int index, const Einzeltermin* t_to) {
	Einzeltermin* t_from = list_einzeltermin.at(index);
	for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end(); iter++) {
		if (Einzeltermin::equal(*iter, t_to) && *iter != t_from) {
			return false;
		}
	}
	*t_from = *t_to;

	sortEinzeltermine();
	updateIntNumEinzeltermine();

	frame->notifyEinzeltermine(t_from->_id);

	for (int i = 0; i < (int) list_tgruppe.size(); i++) {
		TGruppe tc = *(list_tgruppe.at(i));
		std::sort(tc.list_einzel.begin(), tc.list_einzel.end(), Einzeltermin::cmp);
	}
	frame->notifyTGruppen();
	frame->notifyFehlzeiten();


	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveTGruppen(&list_tgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	addOrt(t_from->ort);
	return true;
}

bool App::addSerientermin(Serientermin* termin) {
	for (std::vector<Serientermin*>::iterator iter = list_serientermin.begin(); iter != list_serientermin.end(); iter++) {
		if (Serientermin::equal(*iter, termin)) {
			return false;
		}
	}
	list_serientermin.push_back(termin);

	sortSerientermine();
	updateIntNumSerientermine();

	frame->notifySerientermine(termin->_id);

	DataFileHandler::saveSerientermine(&list_serientermin);
	DataFileHandler::saveTGruppen(&list_tgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	addOrt(termin->ort);
	return true;
}

void App::delSerientermin(int index) {
	//handle TGruppen
	Serientermin* t = list_serientermin.at(index);
	for (std::vector<TGruppe*>::iterator iter_tg = list_tgruppe.begin(); iter_tg != list_tgruppe.end();) {
		for (std::vector<Serientermin*>::iterator iter_t = (**iter_tg).list_serie.begin(); iter_t != (**iter_tg).list_serie.end(); iter_t++) {
			if (t == *iter_t) {
				(**iter_tg).list_serie.erase(iter_t);
				break;
			}
		}
		if ((**iter_tg).list_einzel.size() + (**iter_tg).list_serie.size() < 2) {
			delete *iter_tg;
			iter_tg = list_tgruppe.erase(iter_tg);
		} else {
			iter_tg++;
		}
	}
	//handle Fehlzeiten
	for (std::vector<Fehlzeit*>::iterator iter_f = list_fehlzeit.begin(); iter_f != list_fehlzeit.end();) {
		if ((**iter_f).modus == Fehlzeit::SERIENTERMIN && t == (**iter_f).serientermin) {
			delete *iter_f;
			iter_f = list_fehlzeit.erase(iter_f);
		} else {
			iter_f++;
		}
	}
	delete t;
	list_serientermin.erase(list_serientermin.begin() + index);

	frame->notifySerientermine();
	frame->notifyTGruppen();
	frame->notifyFehlzeiten();

	updateIntNumSerientermine();

	DataFileHandler::saveSerientermine(&list_serientermin);
	DataFileHandler::saveTGruppen(&list_tgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
}

bool App::edtSerientermin(int index, const Serientermin* t_to) {
	Serientermin* t_from = list_serientermin.at(index);
	for (std::vector<Serientermin*>::iterator iter = list_serientermin.begin(); iter != list_serientermin.end(); iter++) {
		if (Serientermin::equal(*iter, t_to) && *iter != t_from) {
			return false;
		}
	}
	*t_from = *t_to;

	sortSerientermine();
	updateIntNumSerientermine();

	frame->notifySerientermine(t_from->_id);

	for (int i = 0; i < (int) list_tgruppe.size(); i++) {
		TGruppe tc = *(list_tgruppe.at(i));
		std::sort(tc.list_serie.begin(), tc.list_serie.end(), Serientermin::cmp);
	}
	frame->notifyTGruppen();
	frame->notifyFehlzeiten();

	DataFileHandler::saveSerientermine(&list_serientermin);
	DataFileHandler::saveTGruppen(&list_tgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	addOrt(t_from->ort);
	return true;
}

void App::addMGruppe(MGruppe* mgruppe) {
	list_mgruppe.push_back(mgruppe);
	sortMGruppen();

	int i = 0;
	while (list_mgruppe.at(i) != mgruppe) i++;

	frame->notifyMGruppen(i);
	DataFileHandler::saveMGruppen(&list_mgruppe);
}

void App::delMGruppe(int index) {
	delete list_mgruppe.at(index);
	list_mgruppe.erase(list_mgruppe.begin() + index);
	frame->notifyMGruppen();
	DataFileHandler::saveMGruppen(&list_mgruppe);
}

void App::edtMGruppe(int index, MGruppe* mg_to) {
	MGruppe* mg_from = list_mgruppe.at(index);
	*mg_from = *mg_to;
	sortMGruppen();

	int i = 0;
	while (list_mgruppe.at(i) != mg_from) i++;

	frame->notifyMGruppen(i);
	DataFileHandler::saveMGruppen(&list_mgruppe);
}

void App::addTGruppe(TGruppe* tgruppe) {
	list_tgruppe.push_back(tgruppe);

	int i = 0;
	while (list_tgruppe.at(i) != tgruppe) i++;

	frame->notifyTGruppen(i);
	DataFileHandler::saveTGruppen(&list_tgruppe);
}

void App::delTGruppe(int index) {
	delete list_tgruppe.at(index);
	list_tgruppe.erase(list_tgruppe.begin() + index);
	frame->notifyTGruppen();
	DataFileHandler::saveTGruppen(&list_tgruppe);
}

void App::edtTGruppe(int index, const TGruppe* tg_to) {
	TGruppe* tg_from = list_tgruppe.at(index);
	*tg_from = *tg_to;

	int i = 0;
	while (list_tgruppe.at(i) != tg_from) i++;

	frame->notifyTGruppen(i);
	DataFileHandler::saveTGruppen(&list_tgruppe);
}

bool App::addFehlzeit(Fehlzeit* fehlzeit) {
	for (std::vector<Fehlzeit*>::iterator iter = list_fehlzeit.begin(); iter != list_fehlzeit.end(); iter++) {
		if (Fehlzeit::equal(*iter, fehlzeit)) {
			return false;
		}
	}
	list_fehlzeit.push_back(fehlzeit);
	sortFehlzeiten();

	int i = 0;
	while (list_fehlzeit.at(i) != fehlzeit) i++;

	frame->notifyFehlzeiten(i);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	return true;
}

void App::delFehlzeit(int index) {
	delete list_fehlzeit.at(index);
	list_fehlzeit.erase(list_fehlzeit.begin() + index);
	frame->notifyFehlzeiten();
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
}

bool App::edtFehlzeit(int index, Fehlzeit* f_to) {
	Fehlzeit* f_from = list_fehlzeit.at(index);
	for (std::vector<Fehlzeit*>::iterator iter = list_fehlzeit.begin(); iter != list_fehlzeit.end(); iter++) {
		if (Fehlzeit::equal(*iter, f_to) && *iter != f_from) {
			return false;
		}
	}
	*f_from = *f_to;
	sortFehlzeiten();

	int i = 0;
	while (list_fehlzeit.at(i) != f_from) i++;

	frame->notifyFehlzeiten(i);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	return true;
}

void App::createAndOpenPlanPlaner(wxDateTime datum_beginn, wxDateTime datum_ende, std::vector<Dienst*> list_dienst,
		std::vector<PTermin*> list_termin, std::vector<PMessdiener*> list_mini,
		std::vector<PMGruppe*> list_pmgruppe, std::vector<PFehlzeit*> list_pfehlzeit) {
	PlanerInfo info = PlanFileHandler::createDir(datum_beginn, datum_ende);
	list_planer.push_back(info);
	sortPlaene();

	int i = 0;
	while (!list_planer.at(i).datum_beginn.IsSameDate(info.datum_beginn)
			|| !list_planer.at(i).datum_ende.IsSameDate(info.datum_ende)
			|| list_planer.at(i).counter != info.counter) i++;

	frame->notifyPlaene(i);
	wxWindowDisabler disabler;
	DataFileHandler::savePlanerInfos(&list_planer);
	Planer* planer = new Planer(datum_beginn, datum_ende, list_dienst, list_termin, list_mini, list_pmgruppe, list_pfehlzeit, info.counter);
	PlanFileHandler::savePlaner(planer);
	new PlanPlanerDialog(NULL, planer);
}

void App::delPlanPlaner(int index) {
	PlanerInfo info = list_planer.at(index);
	list_planer.erase(list_planer.begin() + index);
	frame->notifyPlaene();
	DataFileHandler::savePlanerInfos(&list_planer);
	PlanFileHandler::deleteDir(info);
}

void App::edtPlanPlaner(int index) {
	wxWindowDisabler disabler;
	PlanerInfo info = list_planer.at(index);
	Planer* planer = new Planer(info.datum_beginn, info.datum_ende, info.counter);
	PlanFileHandler::loadPlaner(planer);
	new PlanPlanerDialog(NULL, planer);
}

void App::importMinis(std::vector<Messdiener*> list_import) {
	int num_import = list_import.size();
	wxString st_contained;
	for (int i = 0; i < num_import; i++) {
		Messdiener* m = list_import.at(i);
		bool contained = false;
		for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end() && !contained; iter++) {
			if (Messdiener::equal(*iter, m)) {
				contained = true;
			}
		}
		if (contained) {
			st_contained += m->name + wxT(", ") + m->vorname + wxT("\n");
			delete m;
		} else {
			m->dienste = list_dienst;
			list_mini.push_back(m);
		}
	}
	sortMinis();
	frame->notifyMinis();

	updateIntNumMinis();

	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveMGruppen(&list_mgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	if (st_contained.length() > 0) {
		wxMessageDialog dialog(frame, R::MSG_IMPORT_NOT_POSSIBLE + wxT("\n") + st_contained, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
		dialog.ShowModal();
	}
	initPLZOrte();
}

void App::importEinzeltermine(std::vector<Einzeltermin*> list_import) {
	int num_import = list_import.size();
	wxString st_contained;
	for (int i = 0; i < num_import; i++) {
		Einzeltermin* t = list_import.at(i);
		bool contained = false;
		for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end() && !contained; iter++) {
			if (Einzeltermin::equal(*iter, t)) {
				contained = true;
			}
		}
		if (contained) {
			st_contained += Einzeltermin::printShort(t) + wxT("\n");
			delete t;
		} else {
			list_einzeltermin.push_back(t);
		}
	}

	sortEinzeltermine();
	updateIntNumEinzeltermine();

	frame->notifyEinzeltermine();

	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveTGruppen(&list_tgruppe);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
	if (st_contained.length() > 0) {
		wxMessageDialog dialog(frame, R::MSG_IMPORT_NOT_POSSIBLE + wxT("\n") + st_contained, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
		dialog.ShowModal();
	}
	initOrte();
}

void App::initOrte() {
	list_ort.clear();
	std::set<wxString> set_ort;
	for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end(); iter++) {
		set_ort.insert((**iter).ort);
	}
	for (std::vector<Serientermin*>::iterator iter = list_serientermin.begin(); iter != list_serientermin.end(); iter++) {
		set_ort.insert((**iter).ort);
	}
	for (std::set<wxString>::iterator iter = set_ort.begin(); iter != set_ort.end(); iter++) {
		list_ort.push_back(*iter);
	}
	std::sort(list_ort.begin(), list_ort.end());
}

void App::addOrt(wxString ort) {
	if (std::find(list_ort.begin(), list_ort.end(), ort) == list_ort.end()) list_ort.push_back(ort);
	std::sort(list_ort.begin(), list_ort.end());
}

void App::initPLZOrte() {
	list_plzort.clear();
	std::set<wxString> set_plzort;
	for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		set_plzort.insert((**iter).plz_ort);
	}
	for (std::set<wxString>::iterator iter = set_plzort.begin(); iter != set_plzort.end(); iter++) {
		list_plzort.push_back(*iter);
	}
	std::sort(list_plzort.begin(), list_plzort.end());
}

void App::addPLZOrt(wxString plzort) {
	if (std::find(list_plzort.begin(), list_plzort.end(), plzort) == list_plzort.end()) list_plzort.push_back(plzort);
	std::sort(list_plzort.begin(), list_plzort.end());
}

void App::onLanguageChange() {
	for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		if (!(**iter).geburtstag.IsEmpty()) {
			(**iter).geburtstag = Util::wxDateTime_to_wxString(Util::wxString_to_wxDateTime((**iter).geburtstag));
		}
	}
	for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end(); iter++) {
		if (!(**iter).datum.IsEmpty()) {
			(**iter).datum = Util::wxDateTime_to_wxString(Util::wxString_to_wxDateTime((**iter).datum));
		}
	}
	for (std::vector<Serientermin*>::iterator iter = list_serientermin.begin(); iter != list_serientermin.end(); iter++) {
		if (!(**iter).datum_beginn.IsEmpty()) {
			(**iter).datum_beginn = Util::wxDateTime_to_wxString(Util::wxString_to_wxDateTime((**iter).datum_beginn));
		}
		if (!(**iter).datum_ende.IsEmpty()) {
			(**iter).datum_ende = Util::wxDateTime_to_wxString(Util::wxString_to_wxDateTime((**iter).datum_ende));
		}
	}
	for (std::vector<Fehlzeit*>::iterator iter = list_fehlzeit.begin(); iter != list_fehlzeit.end(); iter++) {
		if ((**iter).modus == Fehlzeit::ZEITRAUM) {
			if (!(**iter).beginn.IsEmpty()) {
				(**iter).beginn = Util::wxDateTime_to_wxString(Util::wxString_to_wxDateTime((**iter).beginn));
			}
			if (!(**iter).ende.IsEmpty()) {
				(**iter).ende = Util::wxDateTime_to_wxString(Util::wxString_to_wxDateTime((**iter).ende));
			}
		}
	}
	frame->notifyMinis();
	frame->notifyMGruppen();
	frame->notifyEinzeltermine();
	frame->notifySerientermine();
	frame->notifyTGruppen();
	frame->notifyFehlzeiten();
	frame->notifyPlaene();
	DataFileHandler::saveMinis(&list_mini);
	DataFileHandler::saveEinzeltermine(&list_einzeltermin);
	DataFileHandler::saveSerientermine(&list_serientermin);
	DataFileHandler::saveFehlzeiten(&list_fehlzeit);
}

void App::sortDienste() {
	std::sort(list_dienst.begin(), list_dienst.end(), Dienst::cmp);
}

void App::sortMinis() {
	std::sort(list_mini.begin(), list_mini.end(), Messdiener::cmp);
}

void App::sortEinzeltermine() {
	std::sort(list_einzeltermin.begin(), list_einzeltermin.end(), Einzeltermin::cmp);
}

void App::sortSerientermine() {
	std::sort(list_serientermin.begin(), list_serientermin.end(), Serientermin::cmp);
}

void App::sortMGruppen() {
	std::sort(list_mgruppe.begin(), list_mgruppe.end(), MGruppe::cmp);
}

void App::sortFehlzeiten() {
	std::sort(list_fehlzeit.begin(), list_fehlzeit.end(), Fehlzeit::cmp);
}

void App::sortPlaene() {
	std::sort(list_planer.begin(), list_planer.end(), PlanerInfo::cmp);
}

void App::updateIntNumDienste() {
	int counter = 0;
	for (std::vector<Dienst*>::iterator iter = list_dienst.begin(); iter != list_dienst.end(); iter++) {
		(**iter)._id = counter++;
	}
}

void App::updateIntNumMinis() {
	int counter = 0;
	for (std::vector<Messdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		(**iter)._id = counter++;
	}
}

void App::updateIntNumEinzeltermine() {
	int counter = 0;
	for (std::vector<Einzeltermin*>::iterator iter = list_einzeltermin.begin(); iter != list_einzeltermin.end(); iter++) {
		(**iter)._id = counter++;
	}
}

void App::updateIntNumSerientermine() {
	int counter = 0;
	for (std::vector<Serientermin*>::iterator iter = list_serientermin.begin(); iter != list_serientermin.end(); iter++) {
		(**iter)._id = counter++;
	}
}

===== ./src/R.h =====
/* 
 * File:   R.h
 * Author: Yannik
 *
 * Created on August 11, 2015, 4:18 PM
 */

#ifndef R_H
#define	R_H

#include <wx/wx.h>

namespace R {
	//Allgemein
	extern wxString MINI_PLANER;
	extern wxString DIENST_DIALOG;
	extern wxString MINI_DIALOG;
	extern wxString EINZELTERMIN_DIALOG;
	extern wxString SERIENTERMIN_DIALOG;
	extern wxString TERMIN_DIENST_DIALOG;
	extern wxString MGRUPPE_DIALOG;
	extern wxString TGRUPPE_DIALOG;
	extern wxString FEHLZEIT_DIALOG;
	extern wxString PLAN_DIALOG;
	extern wxString TERMIN_DIALOG;
	extern wxString EXPORT_LAYOUT_DIALOG;
	extern wxString MINI_EXPORT_DIALOG;
	extern wxString MINI_IMPORT_DIALOG;
	extern wxString MINI_EXTRAS_DIALOG;
	extern wxString EINZELTERMIN_IMPORT_DIALOG;
	extern wxString SPEICHERN_DIALOG;
	extern wxString LOESCHEN_DIALOG;
	extern wxString PLANER_SETTINGS_DIALOG;

	extern wxString HILFE;
	extern wxString UEBER;
	extern wxString SPRACHE;
	extern wxString KONTAKT_MSG;
	extern wxString EXTRAS;
	extern wxString SEMIKOLON;
	extern wxString KOMMA;
	extern wxString LEERZEICHEN;
	extern wxString ANDERES;

	extern wxString OK;
	extern wxString CANCEL;
	extern wxString ADD;
	extern wxString DEL;
	extern wxString EDT;
	extern wxString JA;
	extern wxString NEIN;

	extern wxString DIENSTE;
	extern wxString MINI;
	extern wxString MINIS;
	extern wxString MGRUPPEN;
	extern wxString TERMINE;
	extern wxString TGRUPPEN;
	extern wxString URLAUB;
	extern wxString FEHLZEITEN;
	extern wxString PLAENE;
	//Adresse
	extern wxString STRASSE_NR;
	extern wxString PLZ_ORT;
	extern wxString TEL;
	extern wxString MOBILE;
	extern wxString EMAIL;
	//Messdiener
	extern wxString NAME;
	extern wxString NACHNAME;
	extern wxString VORNAME;
	extern wxString GEBURTSTAG;
	extern wxString BEM;
	const int MINI_ATTS_NUM = 10;
	extern wxString MINI_ATTS[MINI_ATTS_NUM];
	//Termine
	extern wxString EINZELTERMINE;
	extern wxString SERIENTERMINE;
	extern wxString ANZAHL;
	extern wxString ORT;
	extern wxString DATUM;
	extern wxString ZEIT;
	extern wxString MODUS;
	extern wxString DATUM_BEGINN;
	extern wxString DATUM_ENDE;
	const int TEINZEL_NUM = 6;
	const int TSERIE_NUM = 8;
	extern wxString TEINZEL_ATTS[TEINZEL_NUM];
	extern wxString TSERIE_ATTS[TSERIE_NUM];

	extern wxString SONNTAG;
	extern wxString MONTAG;
	extern wxString DIENSTAG;
	extern wxString MITTWOCH;
	extern wxString DONNERSTAG;
	extern wxString FREITAG;
	extern wxString SAMSTAG;
	extern wxString WOCHENTAGE[7];
	//TModus
	extern wxString TAEGLICH;
	extern wxString WOECHENTLICH;
	extern wxString GERADE_KW;
	extern wxString UNGERADE_KW;
	extern wxString N_WOECHENTLICH;
	extern wxString W_IM_MONAT;
	extern wxString MONATLICH;
	const int TMODI_NUM = 7;
	extern wxString TMODI[TMODI_NUM];
	extern wxString LETZTER;
	extern wxString VORLETZTER;
	extern wxString WOCHENTAG;
	extern wxString TAG;
	extern wxString DATUM_AB;
	extern wxString DATUM_BIS;
	//Gruppen (MGruppe, TGruppe)
	extern wxString GRUPPE;
	extern wxString RESTLISTE;
	extern wxString BEV_GEM;
	extern wxString NUR_GEM;
	extern wxString MGMODI[2];
	extern wxString RESTTERMINE;
	extern wxString TGRUPPE;
	extern wxString PERIODISCH;
	extern wxString NICHT_PERIODISCH;
	const int TGMODI_NUM = 2;
	extern wxString TGMODI[TGMODI_NUM];
	//Dienste
	extern wxString DIENST;
	extern wxString ALLGEMEIN;
	//Fehlzeiten
	extern wxString FEHLZEIT;
	extern wxString ZEITRAUM;
	extern wxString TERMIN;
	extern wxString FEHLZEIT_MODI[3];
	extern wxString VON;
	extern wxString BIS;
	//Pläne
	extern wxString OEFFNEN;
	extern wxString ZURUECK;
	extern wxString WEITER;
	extern wxString EINSAETZE;
	extern wxString MASKE;
	extern wxString AUTOMATISCH;
	extern wxString STOPPEN;
	extern wxString LEEREN;
	extern wxString EXPORT;
	extern wxString SPEICHERN;
	extern wxString DATEN;
	extern wxString EINSTELLUNGEN;
	extern wxString FEHLZEITEN_ANRECHNEN;
	extern wxString FEHLZEITEN_KOMPENSIEREN;
	extern wxString ALG_MINIMUM;
	extern wxString ALG_CHRONO;
	//Export
	extern wxString MESSDIENERPLAN;
	extern wxString MESSDIENERPLAN_SH;
	extern wxString LAYOUT;
	extern wxString VORSCHAU;
	extern wxString MINIS_LAYOUT;
	extern wxString MINIS_LAYOUT_MODI[2];
	extern wxString BASICS_LAYOUT;
	extern wxString BASICS_LAYOUT_MODI[2];
	extern wxString NAMEN_LAYOUT;
	extern wxString NAMEN_LAYOUT_MODI[4];
	extern wxString DATEI_AUSGABE;
	extern wxString CLIPBOARD_AUSGABE;
	extern wxString TITEL;
	extern wxString DIENSTE_ZEIGEN;
	extern wxString SPEICHERN_HTML;
	extern wxString SPEICHERN_CSV;
	extern wxString SPEICHERN_EXCEL_XML;
	extern wxString SPALTEN;
	extern wxString NUM;
	extern wxString MESSDIENERLISTE;
	extern wxString MESSDIENERLISTE_SH;
	//Import
	extern wxString IMPORT;
	extern wxString IMPORTIEREN;
	extern wxString SEPARATOR;
	extern wxString CSV_DATEI_WAEHLEN;
	extern wxString MINI_CSV_MSG;
	extern wxString MINI_IMPORT_MSG;
	extern wxString EINZELTERMIN_CSV_MSG;
	extern wxString EINZELTERMIN_IMPORT_MSG;
	//Extras
	extern wxString EMAILS;
	extern wxString KOPIERTEMAILS;
	extern wxString ADRESSEN;
	extern wxString KOPIERTADRESSEN;
	extern wxString KOPIERTEMAILSFERTIG;
	extern wxString KOPIERTADRESSENFERTIG;
	extern wxString KOPIERTWARNICHTMOEGLICH;
	//Über
	extern wxString HEADLINE;
	extern wxString AUTOR;
	extern wxString BEITRAGENDE;
	extern wxString KOMPILIERTMIT;
	extern wxString BIBLIOTHEKEN;
	extern wxString INSTALLATIONSVERZEICHNIS;
	//Einstellungen
	extern wxString MSG_LANG_CHANGE_EN;
	extern wxString MSG_LANG_CHANGE_DE;
	//Nachrichten
	extern wxString MSG_MINI_UNIQUE;
	extern wxString MSG_FEHLZEIT_UNIQUE;
	extern wxString MSG_TIME_ERR;
	extern wxString MSG_TIME_BEGINN_ERR;
	extern wxString MSG_TIME_ENDE_ERR;
	extern wxString MSG_WEEK_NUM_ERR;
	extern wxString MSG_WEEK_COUNT_START;
	extern wxString MSG_GROUP_NUM;
	extern wxString MSG_TGROUP_NUM;
	extern wxString MSG_EINZEL_UNIQUE;
	extern wxString MSG_SERIE_UNIQUE;
	extern wxString MSG_DIENST_UNIQUE;
	extern wxString MSG_MINI_SEL_ERR;
	extern wxString MSG_TERMIN_SEL_ERR;
	extern wxString MSG_DIENST_SEL_ERR;
	extern wxString MSG_DATUM_ORDER;
	extern wxString MSG_PLAN_CREATE_IMPOSSIBLE;
	extern wxString MSG_MANUAL_NOT_OPENED;
	extern wxString MSG_FILE_NOT_FOUND;
	extern wxString MSG_RETRIEVE_NOT_POSSIBLE;
	extern wxString MSG_IMPORT_NOT_POSSIBLE;
	extern wxString Q_SPEICHERN;
	extern wxString Q_LOESCHEN;

	void setLangDE();
	void setLangEN();
	void setLang();

	const int LANG_DE = 0;
	const int LANG_EN = 1;
	extern int lang;

	enum {
		ID_ANY,
		ID_LB,
		ID_LC,
		ID_BT_ADD,
		ID_BT_DEL,
		ID_BT_EDT,
		ID_LC2,
		ID_BT_ADD2,
		ID_BT_DEL2,
		ID_BT_EDT2,
		ID_BT_OK,
		ID_BT_CANCEL,
		ID_CH,
		ID_BT_BACK,
		ID_BT_CONT,
		ID_BT_COMPUTE,
		ID_BT_STOP,
		ID_EXPORT,
		ID_IMPORT,
		ID_UNDO,
		ID_REDO
	};

	void setSubWindowPosition(wxWindow* parent, wxDialog* self);

	extern const int VERSION_NUMBER;//need number for comparison

	extern wxString window_size;
};

#endif	/* R_H */

===== ./src/Util.cpp =====
/* 
 * File:   Util.cpp
 * Author: Yannik
 * 
 * Created on August 12, 2015, 11:36 AM
 */

#include "Util.h"
#include "R.h"
#include <wx/tokenzr.h>
#include "file/DataFileHandler.h"

wxDateTime Util::wxString_to_wxDateTime(const wxString& s) {
	wxStringTokenizer zr(s, wxT("./"));
	if (zr.CountTokens() != 3) {
		return wxDateTime::Today();
	}
	int day, month, year;
	day = wxAtoi(zr.NextToken());
	month = wxAtoi(zr.NextToken());
	year = wxAtoi(zr.NextToken());
	return wxDateTime(day, wxDateTime::Month(month - 1), year);
}

wxString Util::wxDateTime_to_wxString(const wxDateTime& d) {
	if (R::lang == R::LANG_DE)
		return d.Format(wxT("%d.%m.%Y"));
	else
		return d.Format(wxT("%d/%m/%Y"));
}

bool Util::formatDate(const wxString& s, wxString* target) {
	*target = wxT("");
	wxStringTokenizer date_zr(s, wxT("."), wxTOKEN_RET_EMPTY_ALL);
	if (date_zr.CountTokens() != 3) return false;
	else {
		long day, month_i, year;
		bool day_b = date_zr.NextToken().ToLong(&day, 10);
		bool month_b = date_zr.NextToken().ToLong(&month_i, 10);
		bool year_b = date_zr.NextToken().ToLong(&year, 10);
		if (!day_b || !month_b || !year_b || day < 1 || month_i < 1 || year < 0 || day > 31 || month_i > 12) return false;
		else {
			wxDateTime::Month month = wxDateTime::Month(month_i - 1);
			if (day > wxDateTime::GetNumberOfDays(month, year)) return false;
			else {
				wxDateTime date(day, month, year);
				if (!date.IsValid()) return false;
				else *target = Util::wxDateTime_to_wxString(date);
			}
		}
	}
	return true;
}

bool Util::formatTime(const wxString& s, wxString* target) {
	wxStringTokenizer zr(s, ":");
	if (zr.CountTokens() != 2) {
		zr = wxStringTokenizer(s, ".");
		if (zr.CountTokens() != 2) return false;
	}
	long hour, minute;
	if (!zr.NextToken().ToLong(&hour, 10) || hour > 23 || hour < 0) {
		return false;
	}
	if (!zr.NextToken().ToLong(&minute, 10) || minute > 59 || minute < 0) {
		return false;
	}
	*target = wxT("");
	*target << wxString::Format(wxT("%02i"), hour) << wxT(":") << wxString::Format(wxT("%02i"), minute);

	return true;
}

/**
 * In every user input: Replace FileHandler::D, which is used as a divider in the
 * files, by a blank space character. Furthermore remove undesirable characters.
 * @param s user input string
 * @return transferred string
 */
wxString Util::rmD(const wxString& s) {
	wxString s2 = s;
	s2.Replace(wxT("\n"), wxT(" "));
	//other handling for html / xml / <-csv-output possible but not implemented
	s2.Replace(wxT("<"), wxT("&lt;"));
	s2.Replace(wxT(">"), wxT("&gt;"));

	s2.Replace(DataFileHandler::D, wxT(" "));
	return s2;
}

void Util::erase_from_minivec(std::vector<PMessdiener*>* list, PMessdiener* mini) {
	for (std::vector<PMessdiener*>::iterator iter = list->begin(); iter != list->end(); iter++) {
		if (*iter == mini) {
			list->erase(iter);
			return;
		}
	}
}

void Util::setMiniNums(std::vector<PMessdiener*>* mlist, std::vector<PTermin*>* tlist) {
	for (std::vector<PMessdiener*>::iterator iter_m = mlist->begin(); iter_m != mlist->end(); iter_m++) {
		(**iter_m).num = 0;
	}
	for (std::vector<PTermin*>::iterator iter_t = tlist->begin(); iter_t != tlist->end(); iter_t++) {
		for (std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >::iterator iter_d = (**iter_t).list_dienst_minis.begin();
				iter_d != (**iter_t).list_dienst_minis.end(); iter_d++) {
			for (std::vector<PMessdiener*>::iterator iter_m = iter_d->second.begin(); iter_m != iter_d->second.end(); iter_m++) {
				if (*iter_m != NULL) (**iter_m).num++;
			}
		}
	}
}

===== ./src/App.h =====
/* 
 * File:   App.h
 * Author: Yannik
 *
 * Created on August 11, 2015, 4:00 PM
 */

#ifndef APP_H
#define	APP_H

#include <wx/wx.h>
#include <wx/snglinst.h>
#include <vector>
#include "view/MainFrame.h"
#include "model-data/Dienst.h"
#include "model-data/Messdiener.h"
#include "model-data/Einzeltermin.h"
#include "model-data/Serientermin.h"
#include "model-data/MGruppe.h"
#include "model-data/TGruppe.h"
#include "model-data/Fehlzeit.h"
#include "model-plan/PTermin.h"
#include "model-plan/PMessdiener.h"
#include "model-plan/PMGruppe.h"
#include "model-plan/PFehlzeit.h"
#include "model-plan/PlanerInfo.h"

/*
 * Zentrale Vewaltung: nimmt Änderungen an den Daten zur Kenntnis und übergibt 
 * sie an View und File System.
 */

class App : public wxApp {
public:
	std::vector<Dienst*> list_dienst;
	std::vector<Messdiener*> list_mini;
	std::vector<Einzeltermin*> list_einzeltermin;
	std::vector<Serientermin*> list_serientermin;
	std::vector<MGruppe*> list_mgruppe;
	std::vector<TGruppe*> list_tgruppe;
	std::vector<Fehlzeit*> list_fehlzeit;
	std::vector<PlanerInfo> list_planer;
	std::vector<wxString> list_ort;
	std::vector<wxString> list_plzort;
	virtual bool OnInit();
	virtual int OnExit();

	bool addDienst(Dienst* dienst);
	void delDienst(int index);
	bool edtDienst(int index, const Dienst* d_to);
	bool addMini(Messdiener* mini);
	void delMini(int index);
	bool edtMini(int index, const Messdiener* m_to);
	bool addEinzeltermin(Einzeltermin* termin);
	void delEinzeltermin(int index);
	bool edtEinzeltermin(int index, const Einzeltermin* t_to);
	bool addSerientermin(Serientermin* termin);
	void delSerientermin(int index);
	bool edtSerientermin(int index, const Serientermin* t_to);
	void addMGruppe(MGruppe* mgruppe);
	void delMGruppe(int index);
	void edtMGruppe(int index, MGruppe* mg_to);
	void addTGruppe(TGruppe* tgruppe);
	void delTGruppe(int index);
	void edtTGruppe(int index, const TGruppe* tg_to);
	bool addFehlzeit(Fehlzeit* fehlzeit);
	void delFehlzeit(int index);
	bool edtFehlzeit(int index, Fehlzeit* f_to);

	void createAndOpenPlanPlaner(wxDateTime datum_beginn, wxDateTime datum_ende, std::vector<Dienst*> list_dienst,
			std::vector<PTermin*> list_termin, std::vector<PMessdiener*> list_mini,
			std::vector<PMGruppe*> list_pmgruppe, std::vector<PFehlzeit*> list_pfehlzeit);
	void delPlanPlaner(int index);
	void edtPlanPlaner(int index);
	
	void initOrte();
	void addOrt(wxString ort);
	void initPLZOrte();
	void addPLZOrt(wxString plzort);

	void importMinis(std::vector<Messdiener*> list_import);
	void importEinzeltermine(std::vector<Einzeltermin*> list_import);
	void onLanguageChange();
private:
	wxSingleInstanceChecker* single_instance_checker;
	MainFrame* frame;
	void sortDienste();
	void sortMinis();
	void sortEinzeltermine();
	void sortSerientermine();
	void sortMGruppen();
	void sortFehlzeiten();
	void sortPlaene();
	void updateIntNumDienste();
	void updateIntNumMinis();
	void updateIntNumEinzeltermine();
	void updateIntNumSerientermine();
};

#endif	/* APP_H */

===== ./src/model-plan/Planer.cpp =====
/* 
 * File:   Planer.cpp
 * Author: Yannik
 * 
 * Created on September 11, 2015, 10:32 AM
 */

#include "Planer.h"
#include "../Util.h"

Planer::Planer(wxDateTime _datum_beginn, wxDateTime _datum_ende, int _counter)
: datum_beginn(_datum_beginn), datum_ende(_datum_ende), counter(_counter) {

}

Planer::Planer(wxDateTime _datum_beginn, wxDateTime _datum_ende, std::vector<Dienst*> _list_dienst,
		std::vector<PTermin*> _list_termin, std::vector<PMessdiener*> _list_mini, std::vector<PMGruppe*> _list_mgruppe, std::vector<PFehlzeit*> _list_fehlzeit,
		int _counter)
: datum_beginn(_datum_beginn), datum_ende(_datum_ende), list_dienst(_list_dienst), list_termin(_list_termin), list_mini(_list_mini),
list_mgruppe(_list_mgruppe), list_fehlzeit(_list_fehlzeit), counter(_counter) {

}

Planer::~Planer() {
	for (std::vector<Dienst*>::iterator iter = list_dienst.begin(); iter != list_dienst.end(); iter++) {
		delete *iter;
	}
	for (std::vector<PTermin*>::iterator iter = list_termin.begin(); iter != list_termin.end(); iter++) {
		delete *iter;
	}
	for (std::vector<PMessdiener*>::iterator iter = list_mini.begin(); iter != list_mini.end(); iter++) {
		delete *iter;
	}
	for (std::vector<PMGruppe*>::iterator iter = list_mgruppe.begin(); iter != list_mgruppe.end(); iter++) {
		delete *iter;
	}
	for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit.begin(); iter != list_fehlzeit.end(); iter++) {
		delete *iter;
	}
}

wxString Planer::printShort() {
	wxString s = Util::wxDateTime_to_wxString(datum_beginn) + wxT(" - ") + Util::wxDateTime_to_wxString(datum_ende);
	if (counter != 1) {
		s += wxString::Format(wxT(" (%i)"), counter);
	}
	return s;
}

wxString Planer::getDir() {
	if (counter == 1) {
		return datum_beginn.Format(wxT("%Y-%m-%d")) + wxT("_") + datum_ende.Format(wxT("%Y-%m-%d"));
	} else {
		return datum_beginn.Format(wxT("%Y-%m-%d")) + wxT("_") + datum_ende.Format(wxT("%Y-%m-%d") + wxString::Format(wxT("(%i)"), counter));
	}
}


===== ./src/model-plan/CTermin.cpp =====
/* 
 * File:   CTermin.cpp
 * Author: Yannik
 * 
 * Created on September 26, 2015, 10:40 PM
 */

#include "CTermin.h"

CTermin::CTermin() {
	prev = NULL;
	next = NULL;
}


===== ./src/model-plan/PlanerInfo.h =====
/* 
 * File:   PlanerInfo.h
 * Author: Yannik
 *
 * Created on September 12, 2015, 7:20 PM
 */

#ifndef PLANERINFO_H
#define	PLANERINFO_H

#include <wx/datetime.h>
#include <wx/string.h>

class PlanerInfo {
public:
	wxDateTime datum_beginn;
	wxDateTime datum_ende;
	int counter;
	PlanerInfo(wxDateTime _datum_beginn, wxDateTime _datum_ende, int _counter);
	wxString getDir();
	wxString printShort();
	static bool cmp(const PlanerInfo& p1, const PlanerInfo& p2);
private:

};

#endif	/* PLANERINFO_H */



===== ./src/model-plan/PlanerInfo.cpp =====
/* 
 * File:   PlanerInfo.cpp
 * Author: Yannik
 * 
 * Created on September 12, 2015, 7:20 PM
 */

#include "PlanerInfo.h"
#include "../Util.h"

PlanerInfo::PlanerInfo(wxDateTime _datum_beginn, wxDateTime _datum_ende, int _counter)
: datum_beginn(_datum_beginn), datum_ende(_datum_ende), counter(_counter) {

}

wxString PlanerInfo::getDir() {
	if (counter == 1) {
		return datum_beginn.Format(wxT("%Y-%m-%d")) + wxT("_") + datum_ende.Format(wxT("%Y-%m-%d"));
	} else {
		return datum_beginn.Format(wxT("%Y-%m-%d")) + wxT("_") + datum_ende.Format(wxT("%Y-%m-%d") + wxString::Format(wxT("(%i)"), counter));
	}
}

wxString PlanerInfo::printShort() {
	wxString s = Util::wxDateTime_to_wxString(datum_beginn) + wxT(" - ") + Util::wxDateTime_to_wxString(datum_ende);
	if (counter != 1) {
		s += wxString::Format(wxT(" (%i)"), counter);
	}
	return s;
}

bool PlanerInfo::cmp(const PlanerInfo& p1, const PlanerInfo& p2) {
	if (p1.datum_beginn.IsSameDate(p2.datum_beginn)) {
		return p1.datum_ende.IsEarlierThan(p2.datum_ende);
	}
	return p1.datum_beginn.IsEarlierThan(p2.datum_beginn);
}


===== ./src/model-plan/PMGruppe.cpp =====
/* 
 * File:   PMGruppe.cpp
 * Author: Yannik
 * 
 * Created on September 7, 2015, 9:33 PM
 */

#include "PMGruppe.h"

PMGruppe::PMGruppe(int _modus, std::vector<PMessdiener*> _list)
: modus(_modus), list(_list) {

}

wxString PMGruppe::printShort(PMGruppe* mg) {
	PMessdiener m = *(mg->list.at(0));
	wxString s = m.vorname + wxT(" ") + m.name;
	std::vector<PMessdiener*>::iterator iter = mg->list.begin();
	iter++;
	for (; iter != mg->list.end(); iter++) {
		s += wxT(", ") + (**iter).vorname + wxT(" ") + (**iter).name;
	}
	return s;
}

===== ./src/model-plan/PMGruppe.h =====
/* 
 * File:   PMGruppe.h
 * Author: Yannik
 *
 * Created on September 7, 2015, 9:33 PM
 */

#ifndef PMGRUPPE_H
#define	PMGRUPPE_H

#include "PMessdiener.h"
#include <vector>

class PMGruppe {
public:
	int modus;
	std::vector<PMessdiener*> list;
	
	int _id;
	
	PMGruppe(int _modus, std::vector<PMessdiener*> _list);
	static wxString printShort(PMGruppe* m);
private:

};

#endif	/* PMGRUPPE_H */



===== ./src/model-plan/PTermin.h =====
/* 
 * File:   PTermin.h
 * Author: Yannik
 *
 * Created on August 27, 2015, 2:45 PM
 */

#ifndef PTERMIN_H
#define	PTERMIN_H

#include <wx/string.h>
#include <wx/datetime.h>
#include <vector>
#include "PMessdiener.h"
#include "../model-data/Dienst.h"

class PTermin {
public:
	wxString name;
	wxString ort;
	wxDateTime datum;
	wxString zeit_beginn;
	wxString bem;
	
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_dienst_minis;
	std::vector<std::pair<Dienst*, int> > list_dienst_num;
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_dienst_minis_possible; //in total
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_dienst_minis_available; //can still be distributed
	
	PTermin* next;
	PTermin* prev;
	
	int _id;

	PTermin(wxString _name, wxString _ort, wxDateTime _datum, wxString _zeit_beginn, wxString _bem, std::vector<std::pair<Dienst*, int> > _list_dienst_num);
	static wxString printDienste(const PTermin* t);
	static wxString printShort(const PTermin* t);
	static wxString printBasics(const PTermin* t);
	static bool cmp(const PTermin* t1, const PTermin* t2);
	static void sortGruppe(PTermin* t);
private:

};

#endif	/* PTERMIN_H */



===== ./src/model-plan/PTermin.cpp =====
/* 
 * File:   PTermin.cpp
 * Author: Yannik
 * 
 * Created on August 27, 2015, 2:45 PM
 */

#include "PTermin.h"
#include "../Util.h"
#include "../R.h"

PTermin::PTermin(wxString _name, wxString _ort, wxDateTime _datum, wxString _zeit_beginn, wxString _bem, std::vector<std::pair<Dienst*, int> > _list_dienst_num)
: name(_name), ort(_ort), datum(_datum), zeit_beginn(_zeit_beginn), bem(_bem), list_dienst_num(_list_dienst_num) {
	next = (PTermin*) NULL;
	prev = (PTermin*) NULL;
}

wxString PTermin::printDienste(const PTermin* t) {
	int num_dienste = t->list_dienst_num.size();
	wxString s_dienste;
	for (int i = 0; i < num_dienste; i++) {
		s_dienste += wxString::Format(wxT("%i"), t->list_dienst_num.at(i).second) + wxT(" ") + t->list_dienst_num.at(i).first->name;
		if (i < num_dienste - 1) {
			s_dienste += wxT(", ");
		}
	}
	return s_dienste;
}

wxString PTermin::printShort(const PTermin* t) {
	wxString ss;
	if (!t->name.IsEmpty()) {
		ss += t->name + wxT(": ");
	}
	if (!t->ort.IsEmpty()) {
		ss += t->ort + wxT(", ");
	}
	ss += Util::wxDateTime_to_wxString(t->datum) + wxT(" (") + R::WOCHENTAGE[t->datum.GetWeekDay()] + wxT("), ") + t->zeit_beginn
			+ wxT(", ") + printDienste(t);
	return ss;
}

wxString PTermin::printBasics(const PTermin* t) {
	wxString ss = R::WOCHENTAGE[t->datum.GetWeekDay()] + wxT(" ") + Util::wxDateTime_to_wxString(t->datum) + wxT(" ") + t->zeit_beginn;
	if (!t->name.IsEmpty()) {
		ss += wxT(" (") + t->name + wxT(")");
	}
	if (!t->ort.IsEmpty()) {
		ss += wxT(", ") + t->ort;
	}
	return ss;
}

bool PTermin::cmp(const PTermin* t1, const PTermin* t2) {
	if (t1->datum.IsSameDate(t2->datum)) {
		return t1->zeit_beginn.Cmp(t2->zeit_beginn) < 0;
	}
	return t1->datum.IsEarlierThan(t2->datum);
}

void PTermin::sortGruppe(PTermin* t) {
	while(t->next != NULL && !PTermin::cmp(t, t->next)) {
		PTermin* t3 = t->next;
		t->next = t3->next;
		t3->next = t;
		t3->prev = t->prev;
		t->prev = t3;
	}
	while(t->prev != NULL && !PTermin::cmp(t->prev, t)) {
		PTermin* t3 = t->prev;
		t3->next = t->next;
		t->next = t3;
		t->prev = t3->prev;
		t3->prev = t;
	}
}

===== ./src/model-plan/CTermin.h =====
/* 
 * File:   CTermin.h
 * Author: Yannik
 *
 * Created on September 26, 2015, 10:40 PM
 */

#ifndef CTERMIN_H
#define	CTERMIN_H

#include <vector>
#include <unordered_set>
#include <wx/datetime.h>
#include "../model-plan/PMessdiener.h"
#include "../model-data/Dienst.h"

/**
 * Termin for computation.
 */
class CTermin {
public:
	std::vector<std::pair<Dienst*, std::unordered_set<PMessdiener*> > > list_dienst_minis;
	std::vector<std::pair<Dienst*, int> > list_dienst_req;
	std::vector<std::pair<Dienst*, std::unordered_set<PMessdiener*> > > list_dienst_minis_available;
	
	wxDateTime datum;

	CTermin* next;
	CTermin* prev;
	int _id;
	
	CTermin();
private:

};

#endif	/* CTERMIN_H */



===== ./src/model-plan/PMessdiener.h =====
/* 
 * File:   PMessdiener.h
 * Author: Yannik
 *
 * Created on August 27, 2015, 2:45 PM
 */

#ifndef PMESSDIENER_H
#define	PMESSDIENER_H

#include <wx/string.h>
#include <vector>
#include "../model-data/Dienst.h"
class PMGruppe;

class PMessdiener {
public:
	wxString name;
	wxString vorname;
	std::vector<Dienst*> dienste;
	PMGruppe* gruppe;
	int num;
	
	int _id;
	
	PMessdiener(wxString _name, wxString _vorname, std::vector<Dienst*> _dienste);
	PMessdiener(wxString _name, wxString _vorname, std::vector<Dienst*> _dienste, int _num);
	static bool cmp(const PMessdiener* m1, const PMessdiener* m2);
	static wxString printDienste(const PMessdiener* m);
private:

};

#endif	/* PMESSDIENER_H */



===== ./src/model-plan/PFehlzeit.cpp =====
/* 
 * File:   PFehlzeit.cpp
 * Author: Yannik
 * 
 * Created on October 6, 2015, 11:14 PM
 */

#include "PFehlzeit.h"

PFehlzeit::PFehlzeit(PMessdiener* _mini, wxDateTime _datum_beginn, wxDateTime _datum_ende)
: mini(_mini), datum_beginn(_datum_beginn), datum_ende(_datum_ende) {

}

===== ./src/model-plan/Planer.h =====
/* 
 * File:   Planer.h
 * Author: Yannik
 *
 * Created on September 11, 2015, 10:32 AM
 */

#ifndef PLANER_H
#define	PLANER_H

#include <wx/string.h>
#include <wx/datetime.h>
#include <vector>
#include "../model-data/Dienst.h"
#include "PTermin.h"
#include "PMessdiener.h"
#include "PMGruppe.h"
#include "PFehlzeit.h"

class Planer {
public:
	wxDateTime datum_beginn;
	wxDateTime datum_ende;
	std::vector<Dienst*> list_dienst;
	std::vector<PTermin*> list_termin;
	std::vector<PMessdiener*> list_mini;
	std::vector<PMGruppe*> list_mgruppe;
	std::vector<PFehlzeit*> list_fehlzeit;

	class Settings {
	public:
		const static int MODUS_FEHLZEITEN_ANRECHNEN = 0;
		const static int MODUS_FEHLZEITEN_KOMPENSIEREN = 1;
		const static int MODUS_ALGORITHMUS_MINIMUM = 0;
		const static int MODUS_ALGORITHMUS_CHRONOLOGISCH = 1;
		int modus_fehlzeiten = MODUS_FEHLZEITEN_KOMPENSIEREN;
		int modus_algorithmus = MODUS_ALGORITHMUS_CHRONOLOGISCH;
	} settings;

	int counter;
	Planer(wxDateTime _datum_beginn, wxDateTime _datum_ende, int _counter);
	Planer(wxDateTime _datum_beginn, wxDateTime _datum_ende, std::vector<Dienst*> _list_dienst,
			std::vector<PTermin*> _list_termin, std::vector<PMessdiener*> _list_mini, std::vector<PMGruppe*> _list_mgruppe, std::vector<PFehlzeit*> _list_fehlzeit,
			int _counter);
	~Planer();
	wxString printShort();
	wxString getDir();
private:
};

#endif	/* PLANER_H */



===== ./src/model-plan/PFehlzeit.h =====
/* 
 * File:   PFehlzeit.h
 * Author: Yannik
 *
 * Created on October 6, 2015, 11:14 PM
 */

#ifndef PFEHLZEIT_H
#define	PFEHLZEIT_H

#include <wx/datetime.h>
#include "PMessdiener.h"

class PFehlzeit {
public:
	PFehlzeit(PMessdiener* _mini, wxDateTime _datum_beginn, wxDateTime _datum_ende);
	PMessdiener* mini;
	wxDateTime datum_beginn;
	wxDateTime datum_ende;
	
	int _id;
private:

};

#endif	/* PFEHLZEIT_H */



===== ./src/model-plan/PMessdiener.cpp =====
/* 
 * File:   PMessdiener.cpp
 * Author: Yannik
 * 
 * Created on August 27, 2015, 2:45 PM
 */

#include "PMessdiener.h"
#include "PMGruppe.h"

PMessdiener::PMessdiener(wxString _name, wxString _vorname, std::vector<Dienst*> _dienste)
: name(_name), vorname(_vorname), dienste(_dienste) {
	num = 0;
	gruppe = NULL;
}

PMessdiener::PMessdiener(wxString _name, wxString _vorname, std::vector<Dienst*> _dienste, int _num)
: name(_name), vorname(_vorname), dienste(_dienste), num(_num) {
	gruppe = NULL;
}

bool PMessdiener::cmp(const PMessdiener* m1, const PMessdiener* m2) {
	if (m1->name.IsSameAs(m2->name)) {
		return m1->vorname.Cmp(m2->vorname) < 0;
	}
	return m1->name.Cmp(m2->name) < 0;
}

wxString PMessdiener::printDienste(const PMessdiener* m) {
	int num_dienste = m->dienste.size();
	wxString s_dienste;
	for (int i = 0; i < num_dienste; i++) {
		s_dienste += m->dienste.at(i)->name;
		if (i < num_dienste - 1) {
			s_dienste += wxT(", ");
		}
	}
	return s_dienste;
}

===== ./src/view-plan/PlanPlanerDialog.h =====
/* 
 * File:   PlanPlanerDialog.h
 * Author: Yannik
 *
 * Created on September 11, 2015, 9:38 AM
 */

#ifndef PLANPLANERDIALOG_H
#define	PLANPLANERDIALOG_H

#include <wx/wx.h>
#include <wx/snglinst.h>
#include <wx/splitter.h>
#include <wx/listctrl.h>
#include <wx/display.h>
#include <wx/scrolwin.h>
#include <wx/gbsizer.h>
#include <wx/event.h>
#include <wx/colour.h>
#include <wx/arrstr.h>
#include <wx/notebook.h>
#include <wx/thread.h>
#include <wx/notebook.h>
#include <wx/html/htmlwin.h>
#include <vector>
#include "../model-plan/Planer.h"
#include "../export/ExportLayout.h"
#include "PMiniChoiceDialog.h"
class PlanerController;

class PlanPlanerDialog : public wxFrame, wxThreadHelper {
public:
	PlanPlanerDialog(wxWindow* parent, Planer* planer);

	void notifyMinis();
	void notifyMGruppen();
	void notifyTermine(int index = -1);
	void notifyTGruppen();
	void notifyMaskeAndPreview();
	void notifyMaske();
	void notifyPreview();
	void notifySave(bool canSave);
	void notifyHistory(bool enabled);
	void notifyFuture(bool enabled);
	void highlightPMiniChoiceDialog(PTermin* termin, int dienst, int mini_i);
	void unHighlightPMiniChoiceDialog(PTermin* termin, int dienst, int mini_i);
	void unHighlight();
	void redrawMaske();
protected:
	virtual wxThread::ExitCode Entry();
private:
	wxSingleInstanceChecker* single_instance_checker;

	PlanerController* controller;

	std::vector<std::vector<std::vector<wxStaticText*> > > tview_choices;
	std::vector<std::vector<std::vector<wxPanel*> > > tview_pls;
	PMessdiener* tview_mini_high = NULL;
	bool continueComputation = false;
	const wxColour colour_default = wxNullColour;
	const wxColour colour_highlight = wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHT);
	const wxColour colour_highlighttext = wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHTTEXT);
	const wxColour colour_selection = wxSystemSettings::GetColour(wxSYS_COLOUR_GRAYTEXT);

	wxListView* lv_minis;
	wxListView* lv_mgruppen;
	wxListView* lv_termine;
	wxButton* bt_termine_edt;
	wxButton* bt_termine_del;
	wxListView* lv_tgruppen;

	wxNotebook* nb_termine;
	wxScrolled<wxPanel>* pl_maske;
	wxGridBagSizer* sizer_maske;
	bool maskeShown = false;
	bool maskeUpToDate = true;
	bool previewUpToDate = true;
	wxHtmlWindow* html_preview;
	ExportLayout layout;
	const static int MODUS_MASKE = 0;
	const static int MODUS_PREVIEW = 1;
	int modus = MODUS_PREVIEW;

	wxButton* bt_options;
	wxButton* bt_compute;
	wxButton* bt_stop;
	wxButton* bt_undo;
	wxButton* bt_redo;
	wxButton* bt_clear;
	wxButton* bt_save;

	wxButton* bt_settings;
	wxRadioButton* rb_file;
	wxRadioButton* rb_clipboard;
	wxButton* bt_html;
	wxButton* bt_csv;
	wxButton* bt_excel_xml;

	void initComponents();
	void initPreview();
	void initMaske();
	void highlight(PMessdiener* mini);
	
	DECLARE_EVENT_TABLE();

	void onClose(wxCloseEvent& evt);
	void onOptions(wxCommandEvent&);
	void onCompute(wxCommandEvent&);
	void onThreadDone(wxThreadEvent& evt);
	void onStop(wxCommandEvent&);
	void onUndo(wxCommandEvent&);
	void onRedo(wxCommandEvent&);
	void onClear(wxCommandEvent&);
	void onShowPMiniChoiceDialog(wxMouseEvent& evt);
	void onHighlight(wxMouseEvent& evt);
	void onMinisViewHighlight(wxListEvent& evt);
	void onSave(wxCommandEvent&);
	void onNBPageChange(wxBookCtrlEvent& evt);

	void onBtTermineEdt(wxCommandEvent&);
	void onBtTermineDel(wxCommandEvent&);
	void onLITermineActivated(wxListEvent& evt);
	void onBtLayout(wxCommandEvent&);
	void onBtHTML(wxCommandEvent&);
	void onBtCSV(wxCommandEvent&);
	void onBtExcelXML(wxCommandEvent&);
};

#endif	/* PLANPLANERDIALOG_H */

===== ./src/view-plan/PMiniChoiceDialog.h =====
/* 
 * File:   PMiniChoiceDialog.h
 * Author: Yannik
 *
 * Created on September 26, 2015, 10:24 AM
 */

#ifndef PMINICHOICEDIALOG_H
#define	PMINICHOICEDIALOG_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include "../model-plan/PTermin.h"
#include "../model-plan/PMessdiener.h"
class PlanerController;
class PlanPlanerDialog;

class PMiniChoiceDialog : public wxDialog {
public:
	PMiniChoiceDialog(PlanPlanerDialog* _parent, PlanerController* _controller, PTermin* _termin, int _dienst, int _mini);
private:
	PlanPlanerDialog* parent;
	PlanerController* controller;
	PTermin* termin;
	int dienst;
	int mini;
	std::vector<PMessdiener*> tmp_list;

	wxListView* lv_minis;
	DECLARE_EVENT_TABLE();
	void onKillFocus(wxFocusEvent&);
	void onLISelected(wxListEvent& evt);
	void onClose(wxCloseEvent& evt);
};

#endif	/* PMINICHOICEDIALOG_H */



===== ./src/view-plan/TerminePlanerDialog.cpp =====
/* 
 * File:   TerminePlanerDialog.cpp
 * Author: Yannik
 * 
 * Created on August 25, 2015, 7:56 PM
 */

#include "TerminePlanerDialog.h"
#include <algorithm>
#include "../App.h"
#include "../R.h"
#include "../Util.h"
#include "PTerminDialog.h"
#include "../view-data/DeleteDialog.h"

TerminePlanerDialog::TerminePlanerDialog(wxWindow* parent, App* _app, bool* _edt,
		wxDateTime* _datum_beginn,
		wxDateTime* _datum_ende,
		std::vector<Dienst*>* _list_dienst,
		std::vector<PTermin*>* _list_termin,
		std::vector<PMessdiener*>* _list_mini,
		std::vector<PMGruppe*>* _list_mgruppe,
		std::vector<PFehlzeit*>* _list_fehlzeit)
: wxDialog(parent, R::ID_ANY, R::PLAN_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	deleteContents = true;
	edt = _edt;
	datum_beginn = _datum_beginn;
	datum_ende = _datum_ende;
	list_dienst = _list_dienst;
	list_termin = _list_termin;
	list_mini = _list_mini;
	list_mgruppe = _list_mgruppe;
	list_fehlzeit = _list_fehlzeit;
	initComponents();
}

void TerminePlanerDialog::initComponents() {
	pl_zeitraum = new wxPanel(this, R::ID_ANY);
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	SetSizer(sizer);

	//Zeitraum
	wxFlexGridSizer* sizer_zeitraum = new wxFlexGridSizer(2, 2, 0, 0);
	st_beginn = new wxStaticText(pl_zeitraum, R::ID_ANY, R::DATUM_BEGINN);
	sizer_zeitraum->Add(st_beginn, 0, wxALIGN_CENTER_VERTICAL | wxALL, 5);
	cl_beginn = new wxCalendarCtrl(pl_zeitraum, R::ID_ANY, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, 0);
	sizer_zeitraum->Add(cl_beginn, 0, wxALL, 5);
	st_ende = new wxStaticText(pl_zeitraum, R::ID_ANY, R::DATUM_ENDE);
	sizer_zeitraum->Add(st_ende, 0, wxALIGN_CENTER_VERTICAL | wxALL, 5);
	cl_ende = new wxCalendarCtrl(pl_zeitraum, R::ID_ANY, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, 0);
	sizer_zeitraum->Add(cl_ende, 0, wxALL, 5);
	pl_zeitraum->SetSizer(sizer_zeitraum);
	pl_zeitraum->Fit();
	sizer->Add(pl_zeitraum, 1, wxEXPAND | wxALL, 5);

	//Termine
	nb_termine = new wxNotebook(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxNB_TOP);

	nb_pl_termine = new wxPanel(nb_termine, R::ID_ANY);
	nb_termine->InsertPage(0, nb_pl_termine, R::TERMINE);
	wxBoxSizer* sizer_nb_pl_termine = new wxBoxSizer(wxHORIZONTAL);
	lv_termine = new wxListView(nb_pl_termine, R::ID_LC, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[R::TEINZEL_NUM + 1];
	cols[0].SetText(wxT(""));
	lv_termine->InsertColumn(0, cols[0]);
	for (int i = 1; i < R::TEINZEL_NUM + 1; i++) {
		cols[i].SetText(R::TEINZEL_ATTS[i - 1]);
		lv_termine->InsertColumn(i, cols[i]);
	}
	sizer_nb_pl_termine->Add(lv_termine, 1, wxEXPAND | wxALL, 0);
	wxBoxSizer* sizer_nb_pl_termine_r = new wxBoxSizer(wxVERTICAL);
	bt_termine_edt = new wxButton(nb_pl_termine, R::ID_BT_EDT, R::EDT);
	sizer_nb_pl_termine_r->Add(bt_termine_edt, 0, 0, 0);
	bt_termine_del = new wxButton(nb_pl_termine, R::ID_BT_DEL, R::DEL);
	sizer_nb_pl_termine_r->Add(bt_termine_del, 0, 0, 0);
	sizer_nb_pl_termine->Add(sizer_nb_pl_termine_r, 0, 0, 0);
	nb_pl_termine->SetSizer(sizer_nb_pl_termine);

	//TGruppen
	nb_pl_tgruppen = new wxPanel(nb_termine, R::ID_ANY);
	nb_termine->InsertPage(1, nb_pl_tgruppen, R::TGRUPPEN);
	wxBoxSizer* sizer_nb_pl_tgruppen = new wxBoxSizer(wxHORIZONTAL);
	lv_tgruppen = new wxListView(nb_pl_tgruppen, R::ID_LC2, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols2[2];
	cols2[0].SetText(wxT(""));
	cols2[1].SetText(R::TGRUPPE);
	lv_tgruppen->InsertColumn(0, cols2[0]);
	lv_tgruppen->InsertColumn(1, cols2[1]);
	sizer_nb_pl_tgruppen->Add(lv_tgruppen, 1, wxEXPAND | wxALL, 0);
	nb_pl_tgruppen->SetSizer(sizer_nb_pl_tgruppen);

	sizer->Add(nb_termine, 1, wxEXPAND | wxALL, 5);

	//Navigation
	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_back = new wxButton(this, R::ID_BT_BACK, R::ZURUECK);
	btsizer->Add(bt_back, 0, 0, 0);
	bt_cont = new wxButton(this, R::ID_BT_CONT, R::WEITER);
	btsizer->Add(bt_cont, 0, wxRIGHT, 5);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel, 0, 0, 0);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	setModusZeitraum();
}

void TerminePlanerDialog::setModusZeitraum() {
	modus = MODUS_ZEITRAUM;
	pl_zeitraum->Show();
	nb_termine->Hide();
	bt_back->Hide();
	Fit();
}

void TerminePlanerDialog::setModusTermine() {
	modus = MODUS_TERMINE;
	pl_zeitraum->Hide();
	nb_termine->Show();
	bt_back->Show();
	Fit();
}

void TerminePlanerDialog::notifyTermine(int index) {
	lv_termine->DeleteAllItems();
	for (int i = 0; i < (int) list_termin->size(); i++) {
		wxListItem item;
		item.SetId(i);
		PTermin* t = list_termin->at(i);
		lv_termine->InsertItem(item);
		lv_termine->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_termine->SetItem(i, 1, t->name);
		lv_termine->SetItem(i, 2, t->ort);
		lv_termine->SetItem(i, 3, Util::wxDateTime_to_wxString(t->datum) + wxT(" (") + R::WOCHENTAGE[t->datum.GetWeekDay()] + wxT(")"));
		lv_termine->SetItem(i, 4, t->zeit_beginn);
		lv_termine->SetItem(i, 5, PTermin::printDienste(t));
		lv_termine->SetItem(i, 6, t->bem);
	}
	if (index != -1) lv_termine->Select(index, true);
	for (int i = 0; i < R::TEINZEL_NUM + 1; i++) {
		lv_termine->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

void TerminePlanerDialog::notifyTGruppen() {
	lv_tgruppen->DeleteAllItems();
	int counter = 0;
	int gcounter = 1;
	for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
		if ((**iter).prev == (PTermin *) NULL) {
			PTermin* termin = *iter;
			wxListItem item;
			item.SetId(counter);
			lv_tgruppen->InsertItem(item);
			lv_tgruppen->SetItem(counter, 0, wxString::Format(wxT("%i"), gcounter));
			bool ownRow = false;
			while (termin != (PTermin*) NULL) {
				if (ownRow) {
					counter++;
					wxListItem item;
					item.SetId(counter);
					lv_tgruppen->InsertItem(item);
				} else {
					ownRow = true;
				}
				lv_tgruppen->SetItem(counter, 1, PTermin::printShort(termin));
				termin = termin->next;
			}
			counter++;
			gcounter++;
		}
	}
	lv_tgruppen->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_tgruppen->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

BEGIN_EVENT_TABLE(TerminePlanerDialog, wxDialog)
EVT_BUTTON(R::ID_BT_BACK, TerminePlanerDialog::onBtBack)
EVT_BUTTON(R::ID_BT_CONT, TerminePlanerDialog::onBtCont)
EVT_BUTTON(R::ID_BT_CANCEL, TerminePlanerDialog::onBtCancel)
EVT_BUTTON(R::ID_BT_EDT, TerminePlanerDialog::onBtEdt)
EVT_BUTTON(R::ID_BT_DEL, TerminePlanerDialog::onBtDel)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, TerminePlanerDialog::onLIActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, TerminePlanerDialog::onLIKey)
EVT_CLOSE(TerminePlanerDialog::onClose)
END_EVENT_TABLE()

void TerminePlanerDialog::onBtBack(wxCommandEvent&) {
	if (modus == MODUS_TERMINE) {
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			delete *iter;
		}
		list_dienst->clear();
		list_termin->clear();
		list_mini->clear();
		list_mgruppe->clear();
		list_fehlzeit->clear();

		setModusZeitraum();
	}
}

void TerminePlanerDialog::onBtCont(wxCommandEvent&) {
	if (modus == MODUS_ZEITRAUM) {
		*datum_beginn = cl_beginn->GetDate();
		*datum_ende = cl_ende->GetDate();
		if (datum_beginn->IsLaterThan(*datum_ende)) {
			wxMessageDialog dialog(this, R::MSG_DATUM_ORDER);
			dialog.ShowModal();
			return;
		}
		//**Translation of dates************************************************
		std::vector<TerminCreator::PTerminHolder> list_termin_paar;
		TerminCreator::createLists(*datum_beginn, *datum_ende,
				&app->list_dienst,
				&app->list_einzeltermin, &app->list_serientermin, &app->list_tgruppe,
				&app->list_mini, &app->list_mgruppe, &app->list_fehlzeit,
				list_dienst, &list_termin_paar, list_mini, list_mgruppe, list_fehlzeit);
		//reminiscence of old times (division might be useful)
		TerminCreator::fillMLists(&list_termin_paar, list_mini, &app->list_fehlzeit, list_dienst);
		TerminCreator::createTerminList(&list_termin_paar, list_termin);
		//**********************************************************************
		notifyTermine();
		notifyTGruppen();
		setModusTermine();
	} else {
		deleteContents = false;
		*edt = true;

		//prepare ids
		int counter = 0;
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			(**iter)._id = counter++;
		}
		counter = 0;
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			(**iter)._id = counter++;
		}
		Close(true);
	}
}

void TerminePlanerDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

void TerminePlanerDialog::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		edtTermin(i);
		break;
	}
}

void TerminePlanerDialog::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) delTermin(i);
		break;
	}
}

void TerminePlanerDialog::onLIActivated(wxListEvent& evt) {
	edtTermin(evt.GetItem().GetId());
}

void TerminePlanerDialog::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) delTermin(i);
			break;
		}
	}
}

void TerminePlanerDialog::edtTermin(int index) {
	PTermin* termin = list_termin->at(index);
	bool edt_termin = false;
	PTerminDialog* dialog = new PTerminDialog(this, termin, list_termin, list_dienst, list_mini, &edt_termin);
	dialog->ShowModal();
	delete dialog;
	if (edt_termin) {
		int j = 0;
		while (list_termin->at(j) != termin) j++;
		notifyTermine(j);
		notifyTGruppen();
	}
}

void TerminePlanerDialog::delTermin(int index) {
	PTermin* t = list_termin->at(index);
	if (t->prev != NULL) {
		t->prev->next = t->next;
	}
	if (t->next != NULL) {
		t->next->prev = t->prev;
	}
	delete t;
	list_termin->erase(list_termin->begin() + index);
	int counter = 0;
	for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
		(**iter)._id = counter++;
	}
	Util::setMiniNums(list_mini, list_termin);
	notifyTermine();
	notifyTGruppen();
}

void TerminePlanerDialog::onClose(wxCloseEvent& evt) {
	if (deleteContents) {
		for (std::vector<Dienst*>::iterator iter = list_dienst->begin(); iter != list_dienst->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PTermin*>::iterator iter = list_termin->begin(); iter != list_termin->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMessdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PMGruppe*>::iterator iter = list_mgruppe->begin(); iter != list_mgruppe->end(); iter++) {
			delete *iter;
		}
		for (std::vector<PFehlzeit*>::iterator iter = list_fehlzeit->begin(); iter != list_fehlzeit->end(); iter++) {
			delete *iter;
		}
	}
	evt.Skip();
}

===== ./src/view-plan/PlanerSettingsDialog.h =====
/* 
 * File:   PlanerSettingsDialog.h
 * Author: Yannik
 *
 * Created on October 7, 2015, 4:16 PM
 */

#ifndef PLANERSETTINGSDIALOG_H
#define	PLANERSETTINGSDIALOG_H

#include <wx/wx.h>
#include "../model-plan/Planer.h"

class PlanerSettingsDialog : public wxDialog {
public:
	PlanerSettingsDialog(wxWindow* parent, Planer::Settings* _settings, bool* _edt);
private:
	Planer::Settings* settings;
	bool* edt;

	wxRadioButton* rb_anrechnen;
	wxRadioButton* rb_kompensieren;

	wxRadioButton* rb_alg_minimum;
	wxRadioButton* rb_alg_chrono;

	wxButton* bt_ok;
	wxButton* bt_cancel;

	DECLARE_EVENT_TABLE();
	void onBtOk(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};

#endif	/* PLANERSETTINGSDIALOG_H */

===== ./src/view-plan/TerminePlanerDialog.h =====
/* 
 * File:   PlanerDialog.h
 * Author: Yannik
 *
 * Created on August 25, 2015, 7:56 PM
 */

#ifndef TERMINEPLANERDIALOG_H
#define	TERMINEPLANERDIALOG_H

#include <wx/wx.h>
#include <wx/calctrl.h>
#include <wx/notebook.h>
#include <wx/listctrl.h>
#include <wx/datetime.h>
#include <vector>
#include "../model-data/Dienst.h"
#include "../controller-plan/TerminCreator.h"
#include "../model-plan/PTermin.h"
#include "../model-plan/PMessdiener.h"
#include "../model-plan/PFehlzeit.h"
class App;

class TerminePlanerDialog : public wxDialog {
public:
	static const int MODUS_ZEITRAUM = 0;
	static const int MODUS_TERMINE = 1;
	TerminePlanerDialog(wxWindow* parent, App* _app, bool* _edt,
			wxDateTime* _datum_beginn,
			wxDateTime* _datum_ende,
			std::vector<Dienst*>* _list_dienst,
			std::vector<PTermin*>* _list_termin,
			std::vector<PMessdiener*>* _list_mini,
			std::vector<PMGruppe*>* _list_mgruppe,
			std::vector<PFehlzeit*>* _list_fehlzeit);
private:
	App* app;
	int modus;
	wxDateTime* datum_beginn;
	wxDateTime* datum_ende;
	bool* edt;
	std::vector<Dienst*>* list_dienst;
	std::vector<PTermin*>* list_termin;
	std::vector<PMessdiener*>* list_mini;
	std::vector<PMGruppe*>* list_mgruppe;
	std::vector<PFehlzeit*>* list_fehlzeit;
	bool deleteContents;

	//Zeitraum
	wxPanel* pl_zeitraum;
	wxStaticText* st_beginn;
	wxCalendarCtrl* cl_beginn;
	wxStaticText* st_ende;
	wxCalendarCtrl* cl_ende;

	//Termine
	wxNotebook* nb_termine;
	wxPanel* nb_pl_termine;
	wxPanel* nb_pl_tgruppen;
	wxListView* lv_termine;
	wxButton* bt_termine_edt;
	wxButton* bt_termine_del;
	wxListView* lv_tgruppen;

	wxButton* bt_back;
	wxButton* bt_cont;
	wxButton* bt_cancel;

	void initComponents();
	void setModusZeitraum();
	void setModusTermine();
	void notifyTermine(int index = -1);
	void notifyTGruppen();
	void edtTermin(int index);
	void delTermin(int index);
	DECLARE_EVENT_TABLE();
	void onBtBack(wxCommandEvent&);
	void onBtCont(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
	void onClose(wxCloseEvent& evt);
};

#endif	/* TERMINEPLANERDIALOG_H */

===== ./src/view-plan/PlanerSettingsDialog.cpp =====
/* 
 * File:   PlanerSettingsDialog.cpp
 * Author: Yannik
 * 
 * Created on October 7, 2015, 4:16 PM
 */

#include "PlanerSettingsDialog.h"
#include "../R.h"

PlanerSettingsDialog::PlanerSettingsDialog(wxWindow* parent, Planer::Settings* _settings, bool* _edt)
: wxDialog(parent, R::ID_ANY, R::PLANER_SETTINGS_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER), settings(_settings), edt(_edt) {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxBoxSizer* sizer_t = new wxBoxSizer(wxVERTICAL);
	rb_anrechnen = new wxRadioButton(this, R::ID_ANY, R::FEHLZEITEN_ANRECHNEN, wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
	sizer_t->Add(rb_anrechnen, 0, wxEXPAND | wxALL, 2);
	rb_kompensieren = new wxRadioButton(this, R::ID_ANY, R::FEHLZEITEN_KOMPENSIEREN);
	sizer_t->Add(rb_kompensieren, 0, wxEXPAND | wxALL, 2);
	sizer_t->AddSpacer(10);
	rb_alg_minimum = new wxRadioButton(this, R::ID_ANY, R::ALG_MINIMUM, wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
	sizer_t->Add(rb_alg_minimum, 0, wxEXPAND | wxALL, 2);
	rb_alg_chrono = new wxRadioButton(this, R::ID_ANY, R::ALG_CHRONO);
	sizer_t->Add(rb_alg_chrono, 0, wxEXPAND | wxALL, 2);
	sizer->Add(sizer_t, 1, wxALL | wxEXPAND, 5);
	if (settings->modus_fehlzeiten == Planer::Settings::MODUS_FEHLZEITEN_ANRECHNEN) {
		rb_anrechnen->SetValue(true);
	} else {
		rb_kompensieren->SetValue(true);
	}
	if (settings->modus_algorithmus == Planer::Settings::MODUS_ALGORITHMUS_MINIMUM) {
		rb_alg_minimum->SetValue(true);
	} else {
		rb_alg_chrono->SetValue(true);
	}

	sizer->AddSpacer(20);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
}

BEGIN_EVENT_TABLE(PlanerSettingsDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, PlanerSettingsDialog::onBtOk)
EVT_BUTTON(R::ID_BT_CANCEL, PlanerSettingsDialog::onBtCancel)
END_EVENT_TABLE()


void PlanerSettingsDialog::onBtOk(wxCommandEvent&) {
	settings->modus_fehlzeiten = rb_anrechnen->GetValue() ? Planer::Settings::MODUS_FEHLZEITEN_ANRECHNEN : Planer::Settings::MODUS_FEHLZEITEN_KOMPENSIEREN;
	settings->modus_algorithmus = rb_alg_minimum->GetValue() ? Planer::Settings::MODUS_ALGORITHMUS_MINIMUM : Planer::Settings::MODUS_ALGORITHMUS_CHRONOLOGISCH;
	*edt = true;
	Close(true);
}

void PlanerSettingsDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

===== ./src/view-plan/PTerminDienstDialog.h =====
/* 
 * File:   PTerminDienstDialog.h
 * Author: Yannik
 *
 * Created on March 22, 2016, 1:03 PM
 */

#ifndef PTERMINDIENSTDIALOG_H
#define	PTERMINDIENSTDIALOG_H

#include <wx/wx.h>
#include <wx/spinctrl.h>
#include <vector>
#include "../model-data/Dienst.h"
#include "../R.h"
#include "../model-plan/PMessdiener.h"

/**
 * Pass list of missing services. Case edt: service to edit at(0).
 */
class PTerminDienstDialog : public wxDialog {
public:
	PTerminDienstDialog(wxWindow* parent,
			std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis,
			std::vector<std::pair<Dienst*, int> >* _list_dienst_num,
			std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis_possible, //in total
			std::vector<Dienst*>* _missing_dienste,
			std::vector<PMessdiener*>* _global_minis);
	PTerminDienstDialog(wxWindow* parent,
			std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis,
			std::vector<std::pair<Dienst*, int> >* _list_dienst_num,
			std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis_possible, //in total
			int _index,
			std::vector<PMessdiener*>* _global_minis);
private:
	bool edt;
	int index;
	std::vector<Dienst*> missing_dienste;
	
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* list_dienst_minis;
	std::vector<std::pair<Dienst*, int> >* list_dienst_num;
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* list_dienst_minis_possible; //in total	

	std::vector<PMessdiener*>* global_minis;
	wxStaticText* st_dienst;
	wxStaticText* st_anzahl;
	wxChoice* ch_dienst;
	wxSpinCtrl* sp_anzahl;
	wxButton* bt_ok;
	wxButton* bt_cancel;
	void initComponents();
	DECLARE_EVENT_TABLE();
	void onBtOK(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};

#endif	/* PTERMINDIENSTDIALOG_H */



===== ./src/view-plan/PTerminDialog.h =====
/* 
 * File:   PTerminDialog.h
 * Author: Yannik
 *
 * Created on September 7, 2015, 4:34 PM
 */

#ifndef PTERMINDIALOG_H
#define	PTERMINDIALOG_H

#include <wx/wx.h>
#include <wx/datectrl.h>
#include <wx/dateevt.h>
#include <wx/listctrl.h>
#include <vector>
#include "../model-data/Dienst.h"
#include "../model-plan/PTermin.h"

class PTerminDialog : public wxDialog {
public:
	PTerminDialog(wxWindow* parent, 
			PTermin* _termin, 
			std::vector<PTermin*>* _global_termine,//for correct mini nums
			std::vector<Dienst*>* _global_dienste, 
			std::vector<PMessdiener*>* _global_minis, 
			bool* _edt);
private:
	PTermin* termin;
	
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_dienst_minis;
	std::vector<std::pair<Dienst*, int> > list_dienst_num;
	std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > > list_dienst_minis_possible; //in total
	
	std::vector<PTermin*>* global_termine;
	std::vector<Dienst*>* global_dienste;
	std::vector<PMessdiener*>* global_minis;
	bool* edt;

	wxStaticText* st_name;
	wxTextCtrl* tc_name;
	wxStaticText* st_ort;
	wxTextCtrl* tc_ort;
	wxStaticText* st_datum;
	wxDatePickerCtrl* dc_datum;
	wxStaticText* st_datum_wday;
	wxStaticText* st_zeit;
	wxTextCtrl* tc_zeit;
	wxStaticText* st_dienste;
	wxListView* lv_dienste;
	wxButton* bt_add_dienst;
	wxButton* bt_edt_dienst;
	wxButton* bt_del_dienst;
	wxStaticText* st_bem;
	wxTextCtrl* tc_bem;

	wxButton* bt_ok;
	wxButton* bt_cancel;

	void notifyDienste();
	void initComponents();
	DECLARE_EVENT_TABLE();
	void onBtOK(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
	void onBtAddDienst(wxCommandEvent&);
	void onBtEdtDienst(wxCommandEvent&);
	void onBtDelDienst(wxCommandEvent&);
	void onLIDienstActivated(wxListEvent& evt);
	void onDateChanged(wxDateEvent&);
};

#endif	/* PTERMINDIALOG_H */



===== ./src/view-plan/PTerminDialog.cpp =====
/* 
 * File:   PTerminDialog.cpp
 * Author: Yannik
 * 
 * Created on September 7, 2015, 4:34 PM
 */

#include "PTerminDialog.h"
#include <algorithm>
#include "../R.h"
#include "../Util.h"
#include "../model-plan/PTermin.h"
#include "../view-plan/PTerminDienstDialog.h"
#include "../controller-plan/PlanerController.h"

PTerminDialog::PTerminDialog(wxWindow* parent,
		PTermin* _termin,
		std::vector<PTermin*>* _global_termine,
		std::vector<Dienst*>* _global_dienste,
		std::vector<PMessdiener*>* _global_minis,
		bool* _edt)
: wxDialog(parent, R::ID_ANY, R::TERMIN_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	termin = _termin;
	global_termine = _global_termine;
	global_dienste = _global_dienste;
	global_minis = _global_minis;
	edt = _edt;

	list_dienst_minis = termin->list_dienst_minis;
	list_dienst_num = termin->list_dienst_num;
	list_dienst_minis_possible = termin->list_dienst_minis_possible;

	initComponents();
}

void PTerminDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxFlexGridSizer* gridsizer = new wxFlexGridSizer(R::TEINZEL_NUM, 2, 0, 0);

	st_name = new wxStaticText(this, R::ID_ANY, R::NAME);
	gridsizer->Add(st_name, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_name = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_name, 1, wxEXPAND | wxALL, 2);

	st_ort = new wxStaticText(this, R::ID_ANY, R::ORT);
	gridsizer->Add(st_ort, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_ort = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_ort, 1, wxEXPAND | wxALL, 2);

	st_datum = new wxStaticText(this, R::ID_ANY, R::DATUM);
	gridsizer->Add(st_datum, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_datum = new wxBoxSizer(wxHORIZONTAL);
	dc_datum = new wxDatePickerCtrl(this, R::ID_CH, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, wxDP_DEFAULT | wxDP_SHOWCENTURY);
	sizer_datum->Add(dc_datum, 1, wxEXPAND | wxALL, 2);
	st_datum_wday = new wxStaticText(this, R::ID_ANY, wxT("(") + R::WOCHENTAGE[dc_datum->GetValue().GetWeekDay()] + wxT(")"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT | wxST_NO_AUTORESIZE);
	sizer_datum->Add(st_datum_wday, 1, wxALL | wxALIGN_CENTER_VERTICAL | wxALIGN_RIGHT, 2);
	gridsizer->Add(sizer_datum, 1, wxEXPAND | wxALL, 2);

	st_zeit = new wxStaticText(this, R::ID_ANY, R::ZEIT);
	gridsizer->Add(st_zeit, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_zeit = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	tc_zeit->SetHint(wxT("hh:mm"));
	gridsizer->Add(tc_zeit, 1, wxEXPAND | wxALL, 2);

	st_dienste = new wxStaticText(this, R::ID_ANY, R::DIENSTE);
	gridsizer->Add(st_dienste, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_dienste = new wxBoxSizer(wxHORIZONTAL);
	lv_dienste = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[2];
	cols[0].SetText(R::DIENST);
	lv_dienste->InsertColumn(0, cols[0]);
	cols[1].SetText(R::ANZAHL);
	lv_dienste->InsertColumn(1, cols[1]);
	sizer_dienste->Add(lv_dienste, 1, wxEXPAND, 0);
	wxBoxSizer* sizer_dienste_r = new wxBoxSizer(wxVERTICAL);
	bt_add_dienst = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_dienste_r->Add(bt_add_dienst, 0, 0, 0);
	bt_edt_dienst = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_dienste_r->Add(bt_edt_dienst, 0, 0, 0);
	bt_del_dienst = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_dienste_r->Add(bt_del_dienst, 0, 0, 0);
	sizer_dienste->Add(sizer_dienste_r, 0, 0, 0);
	gridsizer->Add(sizer_dienste, 1, wxEXPAND | wxALL, 2);

	st_bem = new wxStaticText(this, R::ID_ANY, R::BEM);
	gridsizer->Add(st_bem, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_bem = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_bem, 1, wxEXPAND | wxALL, 2);

	gridsizer->AddGrowableCol(1, 1);
	gridsizer->AddGrowableRow(4, 1);
	sizer->Add(gridsizer, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
	if (GetSize().GetWidth() < 260) {
		SetSize(260, -1);
	}

	//always edit
	tc_name->SetValue(termin->name);
	notifyDienste();
	tc_ort->SetValue(termin->ort);
	dc_datum->SetValue(termin->datum);
	tc_zeit->SetValue(termin->zeit_beginn);
	tc_bem->SetValue(termin->bem);
	st_datum_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum->GetValue().GetWeekDay()] + wxT(")"));
}

void PTerminDialog::notifyDienste() {
	lv_dienste->DeleteAllItems();
	for (int i = 0; i < (int) list_dienst_num.size(); i++) {
		wxListItem item;
		item.SetId(i);
		lv_dienste->InsertItem(item);
		lv_dienste->SetItem(i, 0, list_dienst_num.at(i).first->name);
		lv_dienste->SetItem(i, 1, wxString::Format(wxT("%i"), list_dienst_num.at(i).second));
	}
	lv_dienste->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_dienste->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

BEGIN_EVENT_TABLE(PTerminDialog, wxDialog)
EVT_BUTTON(R::ID_BT_ADD, PTerminDialog::onBtAddDienst)
EVT_BUTTON(R::ID_BT_EDT, PTerminDialog::onBtEdtDienst)
EVT_BUTTON(R::ID_BT_DEL, PTerminDialog::onBtDelDienst)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, PTerminDialog::onLIDienstActivated)
EVT_BUTTON(R::ID_BT_OK, PTerminDialog::onBtOK)
EVT_BUTTON(R::ID_BT_CANCEL, PTerminDialog::onBtCancel)
EVT_DATE_CHANGED(R::ID_CH, PTerminDialog::onDateChanged)
END_EVENT_TABLE()

void PTerminDialog::onBtAddDienst(wxCommandEvent&) {
	std::vector<Dienst*> missing_dienste;
	for (std::vector<Dienst*>::iterator iter = global_dienste->begin(); iter != global_dienste->end(); iter++) {
		bool contains = false;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = list_dienst_num.begin(); iter_t != list_dienst_num.end(); iter_t++) {
			if (*iter == iter_t->first) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			missing_dienste.push_back(*iter);
		}
	}
	PTerminDienstDialog* dialog = new PTerminDienstDialog(this, &list_dienst_minis, &list_dienst_num, &list_dienst_minis_possible, &missing_dienste, global_minis);
	dialog->ShowModal();
	delete dialog;
	notifyDienste();
}

void PTerminDialog::onBtEdtDienst(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		PTerminDienstDialog* dialog = new PTerminDienstDialog(this, &list_dienst_minis, &list_dienst_num, &list_dienst_minis_possible, i, global_minis);
		dialog->ShowModal();
		delete dialog;
	}
	notifyDienste();
}

void PTerminDialog::onBtDelDienst(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		list_dienst_minis.erase(list_dienst_minis.begin() + i);
		list_dienst_num.erase(list_dienst_num.begin() + i);
		list_dienst_minis_possible.erase(list_dienst_minis_possible.begin() + i);
	}
	notifyDienste();
}

void PTerminDialog::onLIDienstActivated(wxListEvent& evt) {
	std::vector<Dienst*> missing_dienste;
	missing_dienste.insert(missing_dienste.begin(), list_dienst_num.at(evt.GetItem().GetId()).first);
	for (std::vector<Dienst*>::iterator iter = global_dienste->begin(); iter != global_dienste->end(); iter++) {
		bool contains = false;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = list_dienst_num.begin(); iter_t != list_dienst_num.end(); iter_t++) {
			if (*iter == iter_t->first) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			missing_dienste.push_back(*iter);
		}
	}
	PTerminDienstDialog* dialog = new PTerminDienstDialog(this, &list_dienst_minis, &list_dienst_num, &list_dienst_minis_possible, evt.GetItem().GetId(), global_minis);
	dialog->ShowModal();
	delete dialog;
	notifyDienste();
}

void PTerminDialog::onBtOK(wxCommandEvent&) {
	wxString t_zeit_beginn;
	if (!Util::formatTime(tc_zeit->GetValue(), &t_zeit_beginn)) {
		wxMessageDialog dialog(this, R::MSG_TIME_ERR);
		dialog.ShowModal();
		return;
	}
	//directly change object, controlling view has to update
	termin->name = Util::rmD(tc_name->GetValue());
	termin->ort = Util::rmD(tc_ort->GetValue());
	termin->datum = dc_datum->GetValue();
	termin->zeit_beginn = t_zeit_beginn;

	termin->list_dienst_minis = list_dienst_minis;
	termin->list_dienst_num = list_dienst_num;
	termin->list_dienst_minis_possible = list_dienst_minis_possible;

	//handle connections and reset available lists in tgruppe!!!!
	PlanerController::recalculateAvailableListsInTGruppe(termin);
	//put correct mini nums!!
	Util::setMiniNums(global_minis, global_termine);
	//sort termine (by date))
	std::sort(global_termine->begin(), global_termine->end(), PTermin::cmp);
	//put correct termin indices
	int counter = 0;
	for (std::vector<PTermin*>::iterator iter = global_termine->begin(); iter != global_termine->end(); iter++) {
		(**iter)._id = counter++;
	}
	
	termin->bem = Util::rmD(tc_bem->GetValue());
	//sort own tgruppe
	PTermin::sortGruppe(termin);
	*edt = true;
	Close(true);
}

void PTerminDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

void PTerminDialog::onDateChanged(wxDateEvent&) {
	st_datum_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum->GetValue().GetWeekDay()] + wxT(")"));
}

===== ./src/view-plan/PlaenePanel.h =====
/* 
 * File:   PlaenePanel.h
 * Author: Yannik
 *
 * Created on August 25, 2015, 12:40 PM
 */

#ifndef PLAENEPANEL_H
#define	PLAENEPANEL_H

#include <wx/wx.h>
#include <wx/listctrl.h>
class App;

class PlaenePanel : public wxPanel {
public:
	PlaenePanel(wxWindow* parent, App* _app);
	void notifyPlaene(int index = -1);
private:
	App* app;
	wxBoxSizer* sizer;
	wxBoxSizer* sizer_r;
	wxListView* lv_plaene;
	wxButton* bt_add;
	wxButton* bt_edt;
	wxButton* bt_del;
	wxButton* bt_extras;
	DECLARE_EVENT_TABLE();
	void onBtAdd(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
	void onBtExtras(wxCommandEvent&);
};

#endif	/* PLAENEPANEL_H */

===== ./src/view-plan/CloseDialog.cpp =====
/* 
 * File:   CloseDialog.cpp
 * Author: Yannik
 * 
 * Created on October 2, 2015, 3:31 PM
 */

#include "CloseDialog.h"
#include "../R.h"

CloseDialog::CloseDialog(wxWindow* parent, bool* _save, bool* _close) 
: wxDialog(parent, R::ID_ANY, R::SPEICHERN_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	save = _save;
	close = _close;
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	
	wxStaticText* st_q = new wxStaticText(this, R::ID_ANY, R::Q_SPEICHERN);
	sizer->Add(st_q, 1, wxEXPAND | wxALL, 5);
	
	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_yes = new wxButton(this, R::ID_BT_OK, R::JA);
	btsizer->Add(bt_yes);
	bt_no = new wxButton(this, R::ID_BT_CANCEL, R::NEIN);
	btsizer->Add(bt_no);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
}

BEGIN_EVENT_TABLE(CloseDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, CloseDialog::onBtYes)
EVT_BUTTON(R::ID_BT_CANCEL, CloseDialog::onBtNo)
END_EVENT_TABLE()
		

void CloseDialog::onBtYes(wxCommandEvent&) {
	*save = true;
	*close = true;
	Close(true);
}

void CloseDialog::onBtNo(wxCommandEvent&) {
	*close = true;
	Close(true);
}

===== ./src/view-plan/CloseDialog.h =====
/* 
 * File:   CloseDialog.h
 * Author: Yannik
 *
 * Created on October 2, 2015, 3:31 PM
 */

#ifndef CLOSEDIALOG_H
#define	CLOSEDIALOG_H

#include <wx/wx.h>

class CloseDialog : public wxDialog {
public:
	CloseDialog(wxWindow* parent, bool* _save, bool* _close);
private:
	bool* save;
	bool* close;
	
	wxButton* bt_yes;
	wxButton* bt_no;
	
	DECLARE_EVENT_TABLE();
	void onBtYes(wxCommandEvent&);
	void onBtNo(wxCommandEvent&);
};

#endif	/* CLOSEDIALOG_H */

===== ./src/view-plan/PTerminDienstDialog.cpp =====
/* 
 * File:   PTerminDienstDialog.cpp
 * Author: Yannik
 * 
 * Created on March 22, 2016, 1:03 PM
 */

#include "PTerminDienstDialog.h"
#include <algorithm>

PTerminDienstDialog::PTerminDienstDialog(wxWindow* parent,
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis,
		std::vector<std::pair<Dienst*, int> >* _list_dienst_num,
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis_possible, //in total
		std::vector<Dienst*>* _missing_dienste,
		std::vector<PMessdiener*>* _global_minis)
: wxDialog(parent, R::ID_ANY, R::TERMIN_DIENST_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	edt = false;
	missing_dienste = *_missing_dienste;
	list_dienst_minis = _list_dienst_minis;
	list_dienst_num = _list_dienst_num;
	list_dienst_minis_possible = _list_dienst_minis_possible;
	global_minis = _global_minis;
	initComponents();
}

PTerminDienstDialog::PTerminDienstDialog(wxWindow* parent,
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis,
		std::vector<std::pair<Dienst*, int> >* _list_dienst_num,
		std::vector<std::pair<Dienst*, std::vector<PMessdiener*> > >* _list_dienst_minis_possible, //in total
		int _index,
		std::vector<PMessdiener*>* _global_minis)
: wxDialog(parent, R::ID_ANY, R::TERMIN_DIENST_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	edt = true;
	index = _index;
	missing_dienste.push_back(_list_dienst_num->at(index).first);
	list_dienst_minis = _list_dienst_minis;
	list_dienst_num = _list_dienst_num;
	list_dienst_minis_possible = _list_dienst_minis_possible;
	global_minis = _global_minis;
	initComponents();
	sp_anzahl->SetValue(list_dienst_num->at(index).second);
	ch_dienst->Enable(false);
}

void PTerminDienstDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	wxFlexGridSizer* gridsizer = new wxFlexGridSizer(2, 2, 0, 0);

	st_dienst = new wxStaticText(this, R::ID_ANY, R::DIENST);
	gridsizer->Add(st_dienst, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int num = missing_dienste.size();
	wxString dienste_s[num];
	for (int i = 0; i < num; i++) {
		dienste_s[i] = missing_dienste.at(i)->name;
	}
	ch_dienst = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, num, dienste_s);
	ch_dienst->SetSelection(0); //seems to work with empty lists
	gridsizer->Add(ch_dienst, 1, wxEXPAND | wxALL, 2);
	st_anzahl = new wxStaticText(this, R::ID_ANY, R::ANZAHL);
	gridsizer->Add(st_anzahl, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	sp_anzahl = new wxSpinCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 1, 1000000000, 1);
	gridsizer->Add(sp_anzahl, 1, wxEXPAND | wxALL, 2);

	sizer->Add(gridsizer, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
}

BEGIN_EVENT_TABLE(PTerminDienstDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, PTerminDienstDialog::onBtOK)
EVT_BUTTON(R::ID_BT_CANCEL, PTerminDienstDialog::onBtCancel)
END_EVENT_TABLE()

void PTerminDienstDialog::onBtOK(wxCommandEvent&) {
	int dienst_i = ch_dienst->GetSelection();
	if (dienst_i == wxNOT_FOUND) {
		wxMessageDialog dialog(this, R::MSG_DIENST_SEL_ERR);
		dialog.ShowModal();
		return;
	}
	int num_now = sp_anzahl->GetValue();
	if (edt) {
		int num_bef = list_dienst_num->at(index).second;
		list_dienst_num->at(index).second = num_now;
		std::vector<PMessdiener*>* list_minis = &list_dienst_minis->at(index).second;
		for (int i = 0; i < num_now - num_bef; i++) {
			list_minis->push_back(NULL);
		}
		for (int i = 0; i < num_bef - num_now; i++) {
			list_minis->erase(list_minis->begin() + num_bef - 1 - i);
		}
	} else {
		Dienst* dienst = missing_dienste.at(dienst_i);
		list_dienst_num->push_back(std::make_pair(dienst, num_now));
		std::vector<PMessdiener*> vec;
		for (int i = 0; i < num_now; i++) {
			vec.push_back(NULL);
		}
		list_dienst_minis->push_back(std::make_pair(dienst, vec));
		vec.clear();
		for (std::vector<PMessdiener*>::iterator iter_m = global_minis->begin(); iter_m != global_minis->end(); iter_m++) {
			if (std::find((**iter_m).dienste.begin(), (**iter_m).dienste.end(), dienst) != (**iter_m).dienste.end()) vec.push_back(*iter_m);
		}
		list_dienst_minis_possible->push_back(std::make_pair(dienst, vec));
	}
	Close(true);
}

void PTerminDienstDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

===== ./src/view-plan/PMiniChoiceDialog.cpp =====
/* 
 * File:   PMiniChoiceDialog.cpp
 * Author: Yannik
 * 
 * Created on September 26, 2015, 10:24 AM
 */

#include "PMiniChoiceDialog.h"
#include <wx/event.h>
#include <algorithm>
#include "../controller-plan/PlanerController.h"
#include "PlanPlanerDialog.h"
#include "../R.h"

PMiniChoiceDialog::PMiniChoiceDialog(PlanPlanerDialog* _parent, PlanerController* _controller, PTermin* _termin, int _dienst, int _mini)
: wxDialog(_parent, R::ID_ANY, wxT(""), wxDefaultPosition, wxDefaultSize, 0), parent(_parent), controller(_controller), termin(_termin), dienst(_dienst), mini(_mini) {
	//DONE: _parent instead of parent !!!
	lv_minis = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem col;
	col.SetText(wxString::Format(wxT("%i  "), termin->_id + 1) + PTermin::printBasics(termin) + wxT(": ") + termin->list_dienst_num.at(dienst).first->name);
	lv_minis->InsertColumn(0, col);

	tmp_list = termin->list_dienst_minis_available.at(dienst).second;
	int num_minis = tmp_list.size();
	PMessdiener* m = termin->list_dienst_minis.at(dienst).second.at(mini);
	if (m != (PMessdiener*) NULL) {
		tmp_list.push_back(m);
		std::sort(tmp_list.begin(), tmp_list.end(), PMessdiener::cmp);
		num_minis++;
	}
	tmp_list.push_back((PMessdiener*) NULL);

	for (int i = 0; i < num_minis; i++) {
		wxListItem item;
		item.SetId(i);
		lv_minis->InsertItem(item);
		lv_minis->SetItem(i, 0, tmp_list.at(i)->vorname + wxT(" ") + tmp_list.at(i)->name);
	}
	wxListItem item;
	item.SetId(num_minis);
	lv_minis->InsertItem(item);
	lv_minis->SetItem(num_minis, 0, wxT("-"));

	lv_minis->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);

	//make selection
	if (m != (PMessdiener*) NULL) {
		int index = 0;
		while (tmp_list.at(index) != m) index++;
		lv_minis->Select(index, true);
	} else {
		lv_minis->Select(num_minis, true);
	}

	//set location
	wxPoint parent_point = parent->GetPosition();
	wxSize parent_size = parent->GetSize();
	wxSize own_size = GetSize();
	SetPosition(wxPoint(parent_point.x + 20, parent_point.y + parent_size.y - own_size.y - 20));

	lv_minis->Bind(wxEVT_KILL_FOCUS, &PMiniChoiceDialog::onKillFocus, this);
}

BEGIN_EVENT_TABLE(PMiniChoiceDialog, wxDialog)
EVT_LIST_ITEM_SELECTED(R::ID_LC, PMiniChoiceDialog::onLISelected)
EVT_CLOSE(PMiniChoiceDialog::onClose)
END_EVENT_TABLE()

void PMiniChoiceDialog::onKillFocus(wxFocusEvent&) {
	parent->unHighlightPMiniChoiceDialog(termin, dienst, mini);
	delete this;
}

void PMiniChoiceDialog::onClose(wxCloseEvent& evt) {
	evt.Veto();
}

void PMiniChoiceDialog::onLISelected(wxListEvent& evt) {
	int i = -1;
	for (;;) {
		i = lv_minis->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		controller->onEntryChanged(termin, dienst, mini, tmp_list.at(i));
	}
}


===== ./src/view-plan/PlanPlanerDialog.cpp =====
/* 
 * File:   PlanPlanerDialog.cpp
 * Author: Yannik
 * 
 * Created on September 11, 2015, 9:38 AM
 */

#include "PlanPlanerDialog.h"
#include <wx/clipbrd.h>
#include <wx/filedlg.h>
#include <wx/wfstream.h>
#include <wx/statline.h>
#include <algorithm>
#include "../controller-plan/PlanerController.h"
#include "../R.h"
#include "../Util.h"
#include "CloseDialog.h"
#include "../view-data/DeleteDialog.h"
#include "PlanerSettingsDialog.h"
#include "../export/ExportLayoutDialog.h"
#include "../export/HTMLExport.h"
#include "../export/CSVExport.h"
#include "../export/ExcelXMLExport.h"
#include "../img/minis.xpm"

PlanPlanerDialog::PlanPlanerDialog(wxWindow* parent, Planer* planer)
: wxFrame(parent, R::ID_ANY, R::PLAN_DIALOG + wxT(": ") + planer->printShort(), wxDefaultPosition, wxDefaultSize,
wxCAPTION | wxMAXIMIZE_BOX | wxRESIZE_BORDER | wxCLOSE_BOX) {
	single_instance_checker = new wxSingleInstanceChecker;
	single_instance_checker->Create(planer->getDir());
	if (single_instance_checker->IsAnotherRunning()) {
		delete single_instance_checker;
		Destroy();
		return;
	}
	controller = new PlanerController(planer, this);
	wxFrame::SetIcon(wxICON(minis));
	initComponents();
	wxDisplay display;
	wxRect screen = display.GetGeometry();
	int screen_width = screen.GetWidth();
	int screen_height = screen.GetHeight();
	int width = screen_width * 4 / 5;
	int height = screen_height * 4 / 5;
	wxFrame::SetSize(screen_width - width, 0, width, height);
	Show(true);
}

void PlanPlanerDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);

	wxSplitterWindow* splitter_window = new wxSplitterWindow(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D);
	splitter_window->SetSashGravity(0.25);
	splitter_window->SetMinimumPaneSize(20);

	//LINKS
	wxNotebook* nb_l = new wxNotebook(splitter_window, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxNB_TOP);
	//Minis
	lv_minis = new wxListView(nb_l, R::ID_LC, wxDefaultPosition, wxDefaultSize, wxLC_REPORT);
	nb_l->InsertPage(0, lv_minis, R::MINIS);
	wxString mini_cols_s[5] = {wxT(""), R::NACHNAME, R::VORNAME, R::DIENSTE, R::EINSAETZE};
	for (int i = 0; i < 5; i++) {
		if (i == 0 || i == 4) {
			lv_minis->InsertColumn(i, mini_cols_s[i], wxLIST_FORMAT_RIGHT);
		} else {
			lv_minis->InsertColumn(i, mini_cols_s[i], wxLIST_FORMAT_LEFT);
		}
	}
	notifyMinis();
	//MGruppen
	lv_mgruppen = new wxListView(nb_l, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT);
	nb_l->InsertPage(1, lv_mgruppen, R::MGRUPPEN);
	wxListItem cols_mg[3];
	cols_mg[0].SetText(wxT(""));
	cols_mg[1].SetText(R::MODUS);
	cols_mg[2].SetText(R::GRUPPE);
	lv_mgruppen->InsertColumn(0, cols_mg[0]);
	lv_mgruppen->InsertColumn(1, cols_mg[1]);
	lv_mgruppen->InsertColumn(2, cols_mg[2]);
	notifyMGruppen();
	//Termine
	wxPanel* pl_termine = new wxPanel(nb_l, R::ID_ANY);
	wxBoxSizer* sizer_termine = new wxBoxSizer(wxVERTICAL);
	lv_termine = new wxListView(pl_termine, R::ID_CH, wxDefaultPosition, wxDefaultSize, wxLC_REPORT);
	wxListItem cols[R::TEINZEL_NUM + 1];
	cols[0].SetText(wxT(""));
	lv_termine->InsertColumn(0, cols[0]);
	for (int i = 1; i < R::TEINZEL_NUM + 1; i++) {
		cols[i].SetText(R::TEINZEL_ATTS[i - 1]);
		lv_termine->InsertColumn(i, cols[i]);
	}
	sizer_termine->Add(lv_termine, 1, wxEXPAND | wxALL, 0);
	wxBoxSizer* sizer_termine_bts = new wxBoxSizer(wxHORIZONTAL);
	sizer_termine_bts->Add(new wxPanel(this), 1, wxEXPAND, 0);
	bt_termine_edt = new wxButton(pl_termine, R::ID_EXPORT, R::EDT);
	sizer_termine_bts->Add(bt_termine_edt, 0, 0, 0);
	bt_termine_del = new wxButton(pl_termine, R::ID_IMPORT, R::DEL);
	sizer_termine_bts->Add(bt_termine_del, 0, 0, 0);
	sizer_termine->Add(sizer_termine_bts, 0, wxEXPAND, 0);
	pl_termine->SetSizer(sizer_termine);
	nb_l->InsertPage(2, pl_termine, R::TERMINE);
	notifyTermine();
	//TGruppen
	lv_tgruppen = new wxListView(nb_l, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT);
	nb_l->InsertPage(3, lv_tgruppen, R::TGRUPPEN);
	wxListItem cols_pg[2];
	cols_pg[0].SetText(wxT(""));
	cols_pg[1].SetText(R::TGRUPPE);
	lv_tgruppen->InsertColumn(0, cols_pg[0]);
	lv_tgruppen->InsertColumn(1, cols_pg[1]);
	notifyTGruppen();

	//MITTE
	nb_termine = new wxNotebook(splitter_window, R::ID_LB, wxDefaultPosition, wxDefaultSize, wxNB_TOP);

	//Eingabemaske
	pl_maske = new wxScrolled<wxPanel>(nb_termine, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxHSCROLL | wxVSCROLL);
	sizer_maske = new wxGridBagSizer(5, 5);
	wxBoxSizer* sizer_maske_wrap = new wxBoxSizer(wxVERTICAL);
	sizer_maske_wrap->Add(sizer_maske, 1, wxEXPAND | wxALL, 10);
	pl_maske->SetSizer(sizer_maske_wrap);
	nb_termine->InsertPage(0, pl_maske, R::MASKE);

	//Vorschau
	html_preview = new wxHtmlWindow(nb_termine, R::ID_ANY);
	initPreview();
	notifyMaskeAndPreview();
	nb_termine->InsertPage(1, html_preview, R::VORSCHAU);

	nb_termine->SetSelection(1);

	splitter_window->SplitVertically(nb_l, nb_termine);
	sizer->Add(splitter_window, 1, wxEXPAND | wxALL, 0);

	//RECHTS
	wxPanel* pl_r = new wxPanel(this, R::ID_ANY);
	wxBoxSizer* sizer_r = new wxBoxSizer(wxVERTICAL);
	sizer_r->Add(new wxStaticText(pl_r, R::ID_ANY, R::DATEN), 0, wxEXPAND | wxTOP | wxBOTTOM, 5);
	bt_options = new wxButton(pl_r, R::ID_BT_EDT2, R::EINSTELLUNGEN);
	sizer_r->Add(bt_options, 0, wxEXPAND, 0);
	bt_compute = new wxButton(pl_r, R::ID_BT_COMPUTE, R::AUTOMATISCH);
	sizer_r->Add(bt_compute, 0, wxEXPAND, 0);
	bt_stop = new wxButton(pl_r, R::ID_BT_STOP, R::STOPPEN);
	bt_stop->Disable();
	sizer_r->Add(bt_stop, 0, wxEXPAND, 0);
	wxBoxSizer* sz_unredo = new wxBoxSizer(wxHORIZONTAL);
	bt_undo = new wxButton(pl_r, R::ID_UNDO, wxT("\x21A9"));
	bt_undo->Disable();
	sz_unredo->Add(bt_undo, 1, wxEXPAND | wxALL, 0);
	bt_redo = new wxButton(pl_r, R::ID_REDO, wxT("\x21AA"));
	bt_redo->Disable();
	sz_unredo->Add(bt_redo, 1, wxEXPAND | wxALL, 0);
	sizer_r->Add(sz_unredo, 0, wxEXPAND, 0);
	bt_clear = new wxButton(pl_r, R::ID_BT_DEL, R::LEEREN);
	sizer_r->Add(bt_clear, 0, wxEXPAND, 0);
	bt_save = new wxButton(pl_r, R::ID_BT_OK, R::SPEICHERN);
	bt_save->Disable();
	sizer_r->Add(bt_save, 0, wxEXPAND, 0);

	sizer_r->AddSpacer(10);
	sizer_r->Add(new wxStaticLine(pl_r, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxLI_HORIZONTAL), 0, wxEXPAND | wxALL, 5);
	sizer_r->AddSpacer(10);

	sizer_r->Add(new wxStaticText(pl_r, R::ID_ANY, R::EXPORT), 0, wxEXPAND | wxTOP | wxBOTTOM, 5);
	bt_settings = new wxButton(pl_r, R::ID_BT_ADD, R::LAYOUT);
	sizer_r->Add(bt_settings, 0, wxEXPAND, 0);
	sizer_r->AddSpacer(10);
	rb_file = new wxRadioButton(pl_r, R::ID_ANY, R::DATEI_AUSGABE, wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
	sizer_r->Add(rb_file, 0, wxEXPAND, 0);
	rb_clipboard = new wxRadioButton(pl_r, R::ID_ANY, R::CLIPBOARD_AUSGABE);
	sizer_r->Add(rb_clipboard, 0, 0, 0);
	sizer_r->AddSpacer(10);
	bt_html = new wxButton(pl_r, R::ID_BT_ADD2, wxT("HTML"));
	sizer_r->Add(bt_html, 0, wxEXPAND, 0);
	bt_csv = new wxButton(pl_r, R::ID_BT_EDT, wxT("Tab-CSV"));
	sizer_r->Add(bt_csv, 0, wxEXPAND, 0);
	bt_excel_xml = new wxButton(pl_r, R::ID_BT_DEL2, wxT("Excel-XML"));
	sizer_r->Add(bt_excel_xml, 0, wxEXPAND, 0);

	pl_r->SetSizer(sizer_r);

	sizer->Add(pl_r, 0, wxEXPAND, 0);

	SetSizerAndFit(sizer);

	//Threads
	Bind(wxEVT_THREAD, &PlanPlanerDialog::onThreadDone, this);
}

void PlanPlanerDialog::initPreview() {
	layout.title = R::MESSDIENERPLAN + wxT(" ") + Util::wxDateTime_to_wxString(controller->planer->datum_beginn) + wxT(" - ")
			+ Util::wxDateTime_to_wxString(controller->planer->datum_ende);
	layout.showDienste = true;
	layout.modus_minis = ExportLayout::MODUS_MINIS_CELLS;
	layout.n = 2;
	layout.modus_basics = ExportLayout::MODUS_BASICS_LEFT;
	layout.modus_namen = ExportLayout::MODUS_NAMEN_VORNAME_NACHNAME;
}

void PlanPlanerDialog::initMaske() {
	pl_maske->Hide();
	int col = 0;
	for (std::vector<PTermin*>::iterator iter_t = controller->planer->list_termin.begin(); iter_t != controller->planer->list_termin.end(); iter_t++) {
		std::vector<std::vector<wxStaticText*> > tview_list_termin;
		std::vector<std::vector<wxPanel*> > tview_list_termin_pl;
		sizer_maske->Add(new wxStaticText(pl_maske, R::ID_ANY, wxString::Format(wxT("%i  "), (**iter_t)._id + 1)), wxGBPosition(col, 0), wxDefaultSpan, wxALIGN_CENTER_VERTICAL);
		wxStaticText* st_name = new wxStaticText(pl_maske, R::ID_ANY, PTermin::printBasics(*iter_t));
		st_name->SetFont(st_name->GetFont().Bold());
		sizer_maske->Add(st_name, wxGBPosition(col, 1), wxDefaultSpan, wxALIGN_CENTER_VERTICAL);
		if (!(**iter_t).bem.IsSameAs(wxT(""))) {
			wxStaticText* st_bem = new wxStaticText(pl_maske, R::ID_ANY, (**iter_t).bem);
			sizer_maske->Add(st_bem, wxGBPosition(col + 1, 1), wxDefaultSpan, wxALIGN_CENTER_VERTICAL);
		}
		int num_dienste = (**iter_t).list_dienst_num.size();
		tview_list_termin.reserve(num_dienste);
		tview_list_termin_pl.reserve(num_dienste);
		int col_start = col; //Erinnerung an Anfang
		for (int i = 0; i < num_dienste; i++) {
			wxStaticText* st_dienst = new wxStaticText(pl_maske, R::ID_ANY, (**iter_t).list_dienst_num.at(i).first->name);
			st_dienst->SetFont(st_dienst->GetFont().Italic());
			sizer_maske->Add(st_dienst, wxGBPosition(col, 2), wxDefaultSpan, wxALIGN_CENTER_VERTICAL | wxLEFT | wxRIGHT, 5);
			std::vector<wxStaticText*> tview_list_dienst;
			std::vector<wxPanel*> tview_list_dienst_pl;
			int num_einsatz = (**iter_t).list_dienst_num.at(i).second;
			tview_list_dienst.reserve(num_einsatz);
			tview_list_dienst_pl.reserve(num_einsatz);
			for (int j = 0; j < num_einsatz; j++) {
				wxPanel* pl_einsatz = new wxPanel(pl_maske, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxSIMPLE_BORDER);
				wxBoxSizer* sizer_einsatz = new wxBoxSizer(wxVERTICAL);
				wxStaticText* st_einsatz = new wxStaticText(pl_einsatz, R::ID_ANY, wxT("-            "));
				st_einsatz->Bind(wxEVT_LEFT_DCLICK, &PlanPlanerDialog::onShowPMiniChoiceDialog, this);
				st_einsatz->Bind(wxEVT_LEFT_DOWN, &PlanPlanerDialog::onHighlight, this);
				st_einsatz->SetBackgroundColour(colour_default);
				pl_einsatz->SetBackgroundColour(colour_default);
				sizer_einsatz->Add(st_einsatz, 1, wxEXPAND | wxALL, 2);
				pl_einsatz->SetSizer(sizer_einsatz);
				tview_list_dienst.push_back(st_einsatz);
				tview_list_dienst_pl.push_back(pl_einsatz);
				if (j % 2 == 0) {
					sizer_maske->Add(pl_einsatz, wxGBPosition(col, 3), wxDefaultSpan, wxALIGN_CENTER_VERTICAL | wxEXPAND);
					if (j == num_einsatz - 1) {
						sizer_maske->Add(0, 0, wxGBPosition(col, 4));
						col++;
					}
				} else {
					sizer_maske->Add(pl_einsatz, wxGBPosition(col, 4), wxDefaultSpan, wxALIGN_CENTER_VERTICAL | wxEXPAND);
					col++;
				}
			}
			tview_list_termin.push_back(tview_list_dienst);
			tview_list_termin_pl.push_back(tview_list_dienst_pl);
		}
		if (num_dienste == 0) {
			col++;
		}
		if (col == col_start) {
			if (!(**iter_t).bem.IsSameAs(wxT(""))) {
				col++;
			}
		}
		col++;
		tview_choices.push_back(tview_list_termin);
		tview_pls.push_back(tview_list_termin_pl);
	}
	pl_maske->FitInside();
	pl_maske->SetScrollRate(10, 10);
	pl_maske->Show();
	maskeShown = true;
}

void PlanPlanerDialog::redrawMaske() {
	if(!maskeShown) return;
	sizer_maske->Clear(false);
	pl_maske->DestroyChildren();
	tview_choices.clear();
	tview_pls.clear();
	maskeShown = false;
	if(modus == MODUS_MASKE) {
		initMaske();
	}
}

void PlanPlanerDialog::notifyMinis() {
	lv_minis->DeleteAllItems();
	int num = controller->planer->list_mini.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		lv_minis->InsertItem(item);
		PMessdiener m = *(controller->planer->list_mini.at(i));
		lv_minis->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_minis->SetItem(i, 1, m.name);
		lv_minis->SetItem(i, 2, m.vorname);
		lv_minis->SetItem(i, 3, PMessdiener::printDienste(&m));
		lv_minis->SetItem(i, 4, wxString::Format(wxT("%i"), m.num));
	}
	for (int i = 0; i < 5; i++) {
		lv_minis->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

void PlanPlanerDialog::notifyMGruppen() {
	lv_mgruppen->DeleteAllItems();
	int num = controller->planer->list_mgruppe.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		PMGruppe* mg = controller->planer->list_mgruppe.at(i);
		lv_mgruppen->InsertItem(item);
		lv_mgruppen->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_mgruppen->SetItem(i, 1, R::MGMODI[mg->modus]);
		lv_mgruppen->SetItem(i, 2, PMGruppe::printShort(mg));
	}
	for (int i = 0; i < 3; i++) {
		lv_mgruppen->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

void PlanPlanerDialog::notifyTermine(int index) {
	lv_termine->DeleteAllItems();
	for (int i = 0; i < (int) controller->planer->list_termin.size(); i++) {
		wxListItem item;
		item.SetId(i);
		PTermin* t = controller->planer->list_termin.at(i);
		lv_termine->InsertItem(item);
		lv_termine->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_termine->SetItem(i, 1, t->name);
		lv_termine->SetItem(i, 2, t->ort);
		lv_termine->SetItem(i, 3, Util::wxDateTime_to_wxString(t->datum) + wxT(" (") + R::WOCHENTAGE[t->datum.GetWeekDay()] + wxT(")"));
		lv_termine->SetItem(i, 4, t->zeit_beginn);
		lv_termine->SetItem(i, 5, PTermin::printDienste(t));
		lv_termine->SetItem(i, 6, t->bem);
	}
	if (index != -1) lv_termine->Select(index, true);
	for (int i = 0; i < R::TEINZEL_NUM + 1; i++) {
		lv_termine->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

void PlanPlanerDialog::notifyTGruppen() {
	lv_tgruppen->DeleteAllItems();
	int counter = 0;
	int gcounter = 1;
	for (std::vector<PTermin*>::iterator iter = controller->planer->list_termin.begin(); iter != controller->planer->list_termin.end(); iter++) {
		if ((**iter).prev == (PTermin *) NULL) {
			PTermin* termin = *iter;
			wxListItem item;
			item.SetId(counter);
			lv_tgruppen->InsertItem(item);
			lv_tgruppen->SetItem(counter, 0, wxString::Format(wxT("%i"), gcounter));
			bool ownRow = false;
			while (termin != (PTermin*) NULL) {
				if (ownRow) {
					counter++;
					wxListItem item;
					item.SetId(counter);
					lv_tgruppen->InsertItem(item);
				} else {
					ownRow = true;
				}
				lv_tgruppen->SetItem(counter, 1, PTermin::printShort(termin));
				termin = termin->next;
			}
			counter++;
			gcounter++;
		}
	}
	lv_tgruppen->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_tgruppen->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

void PlanPlanerDialog::notifyMaskeAndPreview() {
	if (modus == MODUS_MASKE) {
		previewUpToDate = false;
		notifyMaske();
		maskeUpToDate = true;
	} else {
		maskeUpToDate = false;
		notifyPreview();
		previewUpToDate = true;
	}
}

void PlanPlanerDialog::notifyMaske() {
	int num_termine = controller->planer->list_termin.size();
	for (int i = 0; i < num_termine; i++) {
		PTermin* t = controller->planer->list_termin.at(i);
		int num_dienste = t->list_dienst_num.size();
		for (int j = 0; j < num_dienste; j++) {
			int m_counter = 0;
			for (std::vector<PMessdiener*>::iterator iter_m = t->list_dienst_minis.at(j).second.begin(); iter_m != t->list_dienst_minis.at(j).second.end(); iter_m++) {
				wxStaticText* st = tview_choices.at(i).at(j).at(m_counter++);
				st->SetLabel(*iter_m == NULL ? wxT("-            ") : (**iter_m).vorname + wxT(" ") + (**iter_m).name);
			}
		}
	}
	pl_maske->Layout();
}

void PlanPlanerDialog::notifyPreview() {
	html_preview->SetPage(HTMLExport::createHTML(&layout, controller->planer, true));
}

void PlanPlanerDialog::notifySave(bool canSave) {
	bt_save->Enable(canSave);
}

void PlanPlanerDialog::notifyHistory(bool enabled) {
	bt_undo->Enable(enabled);
}

void PlanPlanerDialog::notifyFuture(bool enabled) {
	bt_redo->Enable(enabled);
}

BEGIN_EVENT_TABLE(PlanPlanerDialog, wxFrame)
EVT_CLOSE(PlanPlanerDialog::onClose)
EVT_BUTTON(R::ID_BT_COMPUTE, PlanPlanerDialog::onCompute)
EVT_BUTTON(R::ID_BT_STOP, PlanPlanerDialog::onStop)
EVT_BUTTON(R::ID_BT_EDT2, PlanPlanerDialog::onOptions)
EVT_BUTTON(R::ID_UNDO, PlanPlanerDialog::onUndo)
EVT_BUTTON(R::ID_REDO, PlanPlanerDialog::onRedo)
EVT_BUTTON(R::ID_BT_DEL, PlanPlanerDialog::onClear)
EVT_BUTTON(R::ID_BT_OK, PlanPlanerDialog::onSave)
EVT_BUTTON(R::ID_BT_ADD, PlanPlanerDialog::onBtLayout)
EVT_BUTTON(R::ID_BT_ADD2, PlanPlanerDialog::onBtHTML)
EVT_BUTTON(R::ID_BT_EDT, PlanPlanerDialog::onBtCSV)
EVT_BUTTON(R::ID_BT_DEL2, PlanPlanerDialog::onBtExcelXML)
EVT_BUTTON(R::ID_EXPORT, PlanPlanerDialog::onBtTermineEdt)
EVT_BUTTON(R::ID_IMPORT, PlanPlanerDialog::onBtTermineDel)
EVT_LIST_ITEM_ACTIVATED(R::ID_CH, PlanPlanerDialog::onLITermineActivated)
EVT_LIST_ITEM_SELECTED(R::ID_LC, PlanPlanerDialog::onMinisViewHighlight)
EVT_NOTEBOOK_PAGE_CHANGED(R::ID_LB, PlanPlanerDialog::onNBPageChange)
END_EVENT_TABLE()

void PlanPlanerDialog::onClose(wxCloseEvent& evt) {
	if (controller->edt) {
		bool save = false;
		bool close = false;
		CloseDialog dialog(this, &save, &close);
		dialog.ShowModal();
		if (save) {
			controller->onSave();
		}
		if (!close) {
			evt.Veto(true);
			return;
		}
	}
	continueComputation = false;
	if (GetThread() && GetThread()->IsRunning()) GetThread()->Wait();
	delete controller;
	delete single_instance_checker;
	single_instance_checker = 0;
	evt.Skip();
}

void PlanPlanerDialog::onCompute(wxCommandEvent&) {
	if (continueComputation) return;
	continueComputation = true;
	bt_compute->Disable();
	bt_stop->Enable();
	if (CreateThread(wxTHREAD_JOINABLE) != wxTHREAD_NO_ERROR || GetThread()->Run() != wxTHREAD_NO_ERROR) {
		continueComputation = false;
		bt_compute->Enable();
		bt_stop->Disable();
		return;
	}
}

wxThread::ExitCode PlanPlanerDialog::Entry() {
	int canCreate = controller->simpleCheckCanCreatePlan();
	wxThreadEvent* evt = new wxThreadEvent();
	if (canCreate == 0) {
		controller->computePlan(&continueComputation);
		evt->SetInt(0);
	} else if (canCreate == 1) {
		evt->SetInt(1);
	} else {//canCreate == 2
		evt->SetInt(2);
	}
	wxQueueEvent(GetEventHandler(), evt);
	return (wxThread::ExitCode) 0;
}

void PlanPlanerDialog::onThreadDone(wxThreadEvent& evt) {
	bt_compute->Enable();
	bt_stop->Disable();
	if (evt.GetInt() == 1) {
		wxMessageDialog dialog(this, R::MSG_PLAN_CREATE_IMPOSSIBLE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
		dialog.ShowModal();
	} else if (evt.GetInt() == 0 && continueComputation) {
		notifyMinis();
		unHighlight();
		notifyMaskeAndPreview();
		notifyHistory(true);
		notifyFuture(false);
		notifySave(true);
	}
	continueComputation = false; //windows interactive again
}

void PlanPlanerDialog::onStop(wxCommandEvent&) {
	continueComputation = false; //comp stops in next loop
}

void PlanPlanerDialog::onOptions(wxCommandEvent&) {
	if (continueComputation) return;
	bool edt = false;
	PlanerSettingsDialog dialog(this, &controller->planer->settings, &edt);
	dialog.ShowModal();
	if (edt) {
		controller->edt = true;
		notifySave(true);
	}
}

void PlanPlanerDialog::onUndo(wxCommandEvent&) {
	if (continueComputation) return;
	controller->onUndo();
}

void PlanPlanerDialog::onRedo(wxCommandEvent&) {
	if (continueComputation) return;
	controller->onRedo();
}

void PlanPlanerDialog::onClear(wxCommandEvent&) {
	if (continueComputation) return;
	controller->onClear();
}

void PlanPlanerDialog::onShowPMiniChoiceDialog(wxMouseEvent& evt) {
	if (continueComputation) return;
	if (evt.GetEventObject()->IsKindOf(wxCLASSINFO(wxStaticText))) {
		wxStaticText* st = (wxStaticText*) evt.GetEventObject();
		bool found = false;
		PTermin* termin;
		int dienst;
		int mini;
		int num_termine = tview_choices.size();
		for (int i = 0; i < num_termine && !found; i++) {
			int num_dienste = tview_choices.at(i).size();
			for (int j = 0; j < num_dienste && !found; j++) {
				int num_einsaetze = tview_choices.at(i).at(j).size();
				for (int k = 0; k < num_einsaetze; k++) {
					if (st == tview_choices.at(i).at(j).at(k)) {
						found = true;
						termin = controller->planer->list_termin.at(i);
						dienst = j;
						mini = k;
						break;
					}
				}
			}
		}
		if (found) {
			highlightPMiniChoiceDialog(termin, dienst, mini);
			PMiniChoiceDialog* dialog = new PMiniChoiceDialog(this, controller, termin, dienst, mini);
			dialog->Show();
		}
	}
}

void PlanPlanerDialog::highlightPMiniChoiceDialog(PTermin* termin, int dienst, int mini_i) {
	PMessdiener* mini = termin->list_dienst_minis.at(dienst).second.at(mini_i);
	highlight(mini);
	tview_choices.at(termin->_id).at(dienst).at(mini_i)->SetForegroundColour(colour_highlighttext);
	tview_choices.at(termin->_id).at(dienst).at(mini_i)->SetBackgroundColour(colour_selection);
	tview_pls.at(termin->_id).at(dienst).at(mini_i)->SetForegroundColour(colour_highlighttext);
	tview_pls.at(termin->_id).at(dienst).at(mini_i)->SetBackgroundColour(colour_selection);
	tview_pls.at(termin->_id).at(dienst).at(mini_i)->Refresh();
}

void PlanPlanerDialog::unHighlightPMiniChoiceDialog(PTermin* termin, int dienst, int mini_i) {
	PMessdiener* mini = termin->list_dienst_minis.at(dienst).second.at(mini_i);
	tview_mini_high = NULL;
	highlight(mini);
}

void PlanPlanerDialog::unHighlight() {
	tview_mini_high = NULL;
	int num_termine = tview_choices.size();
	for (int i = 0; i < num_termine; i++) {
		int num_dienste = tview_choices.at(i).size();
		for (int j = 0; j < num_dienste; j++) {
			int num_einsaetze = tview_choices.at(i).at(j).size();
			for (int k = 0; k < num_einsaetze; k++) {
				tview_choices.at(i).at(j).at(k)->SetForegroundColour(colour_default);
				tview_choices.at(i).at(j).at(k)->SetBackgroundColour(colour_default);
				tview_pls.at(i).at(j).at(k)->SetForegroundColour(colour_default);
				tview_pls.at(i).at(j).at(k)->SetBackgroundColour(colour_default);
				tview_pls.at(i).at(j).at(k)->Refresh();
			}
		}
	}
	int num_minis = controller->planer->list_mini.size();
	for (int i = 0; i < num_minis; i++) {
		lv_minis->Select(i, false);
	}
}

void PlanPlanerDialog::highlight(PMessdiener* mini) {
	if (mini == NULL || mini == tview_mini_high) {
		unHighlight();
	} else {
		tview_mini_high = mini;
		int num_termine = tview_choices.size();
		for (int i = 0; i < num_termine; i++) {
			int num_dienste = tview_choices.at(i).size();
			for (int j = 0; j < num_dienste; j++) {
				int num_einsaetze = tview_choices.at(i).at(j).size();
				for (int k = 0; k < num_einsaetze; k++) {
					if (mini == controller->planer->list_termin.at(i)->list_dienst_minis.at(j).second.at(k)) {
						tview_choices.at(i).at(j).at(k)->SetForegroundColour(colour_highlighttext);
						tview_choices.at(i).at(j).at(k)->SetBackgroundColour(colour_highlight);
						tview_pls.at(i).at(j).at(k)->SetForegroundColour(colour_highlighttext);
						tview_pls.at(i).at(j).at(k)->SetBackgroundColour(colour_highlight);
						tview_pls.at(i).at(j).at(k)->Refresh();
					} else {
						tview_choices.at(i).at(j).at(k)->SetForegroundColour(colour_default);
						tview_choices.at(i).at(j).at(k)->SetBackgroundColour(colour_default);
						tview_pls.at(i).at(j).at(k)->SetForegroundColour(colour_default);
						tview_pls.at(i).at(j).at(k)->SetBackgroundColour(colour_default);
						tview_pls.at(i).at(j).at(k)->Refresh();
					}
				}
			}
		}
		int num_minis = controller->planer->list_mini.size();
		for (int i = 0; i < num_minis; i++) {
			lv_minis->Select(i, i == mini->_id);
		}
	}
}

void PlanPlanerDialog::onHighlight(wxMouseEvent& evt) {
	if (continueComputation) return;
	if (evt.GetEventObject()->IsKindOf(wxCLASSINFO(wxStaticText))) {
		wxStaticText* st = (wxStaticText*) evt.GetEventObject();
		bool found = false;
		PMessdiener* mini;
		int num_termine = tview_choices.size();
		for (int i = 0; i < num_termine && !found; i++) {
			int num_dienste = tview_choices.at(i).size();
			for (int j = 0; j < num_dienste && !found; j++) {
				int num_einsaetze = tview_choices.at(i).at(j).size();
				for (int k = 0; k < num_einsaetze; k++) {
					if (st == tview_choices.at(i).at(j).at(k)) {
						found = true;
						mini = controller->planer->list_termin.at(i)->list_dienst_minis.at(j).second.at(k);
						break;
					}
				}
			}
		}
		if (found) {
			highlight(mini);
		}
	}
}

void PlanPlanerDialog::onMinisViewHighlight(wxListEvent& evt) {
	if (modus == MODUS_PREVIEW) return;
	if (continueComputation) return;
	PMessdiener* m = controller->planer->list_mini.at(evt.GetItem().GetId());
	//prevent loop
	if (m != tview_mini_high) highlight(m);
}

void PlanPlanerDialog::onSave(wxCommandEvent&) {
	if (continueComputation) return;
	controller->onSave();
}

void PlanPlanerDialog::onNBPageChange(wxBookCtrlEvent& evt) {
	if (evt.GetSelection() == 0) {
		if (!maskeShown) initMaske();
		modus = MODUS_MASKE;
		if (!maskeUpToDate) notifyMaskeAndPreview();
	} else {
		modus = MODUS_PREVIEW;
		if (!previewUpToDate) notifyMaskeAndPreview();
	}
}

void PlanPlanerDialog::onBtLayout(wxCommandEvent&) {
	if (continueComputation) return;
	ExportLayoutDialog* dialog = new ExportLayoutDialog(this, &layout);
	dialog->ShowModal();
	delete dialog;
	notifyPreview();
}

void PlanPlanerDialog::onBtHTML(wxCommandEvent&) {
	if (continueComputation) return;
	wxString text = HTMLExport::createHTML(&layout, controller->planer, false);
	if (rb_file->GetValue()) {
		wxFileDialog saveFileDialog(this, R::SPEICHERN_HTML, wxT("output"),
				R::MESSDIENERPLAN_SH + wxT("_") + controller->planer->getDir() + wxT(".html"), wxT("*.*"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		if (saveFileDialog.ShowModal() == wxID_CANCEL) {
			return;
		}
		wxFileOutputStream output_stream(saveFileDialog.GetPath());
		if (!output_stream.IsOk()) {
			return;
		}
		wxScopedCharBuffer text_utf8 = text.ToUTF8();
		output_stream.Write(text_utf8, text_utf8.length());
		output_stream.Close();
	} else {
		if (wxTheClipboard->Open()) {
			wxTheClipboard->SetData(new wxTextDataObject(text));
			wxTheClipboard->Close();
		}
	}
}

void PlanPlanerDialog::onBtCSV(wxCommandEvent&) {
	if (continueComputation) return;
	wxString text = CSVExport::createCSV(&layout, controller->planer);
	if (rb_file->GetValue()) {
		wxFileDialog saveFileDialog(this, R::SPEICHERN_CSV, wxT("output"),
				R::MESSDIENERPLAN_SH + wxT("_") + controller->planer->getDir() + wxT(".csv"), wxT("*.*"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		if (saveFileDialog.ShowModal() == wxID_CANCEL) {
			return;
		}
		wxFileOutputStream output_stream(saveFileDialog.GetPath());
		if (!output_stream.IsOk()) {
			return;
		}
		wxScopedCharBuffer text_utf8 = text.ToUTF8();
		output_stream.Write(text_utf8, text_utf8.length());
		output_stream.Close();
	} else {
		if (wxTheClipboard->Open()) {
			wxTheClipboard->SetData(new wxTextDataObject(text));
			wxTheClipboard->Close();
		}
	}
}

void PlanPlanerDialog::onBtExcelXML(wxCommandEvent&) {
	if (continueComputation) return;
	wxString text = ExcelXMLExport::createExcelXML(&layout, controller->planer);
	if (rb_file->GetValue()) {
		wxFileDialog saveFileDialog(this, R::SPEICHERN_EXCEL_XML, wxT("output"),
				R::MESSDIENERPLAN_SH + wxT("_") + controller->planer->getDir() + wxT(".xml"), wxT("*.*"), wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		if (saveFileDialog.ShowModal() == wxID_CANCEL) {
			return;
		}
		wxFileOutputStream output_stream(saveFileDialog.GetPath());
		if (!output_stream.IsOk()) {
			return;
		}
		wxScopedCharBuffer text_utf8 = text.ToUTF8();
		output_stream.Write(text_utf8, text_utf8.length());
		output_stream.Close();
	} else {
		if (wxTheClipboard->Open()) {
			wxTheClipboard->SetData(new wxTextDataObject(text));
			wxTheClipboard->Close();
		}
	}
}

void PlanPlanerDialog::onBtTermineEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		controller->onEdtTermin(i);
		break;
	}
}

void PlanPlanerDialog::onBtTermineDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) controller->onDelTermin(i);
		break;
	}
}

void PlanPlanerDialog::onLITermineActivated(wxListEvent& evt) {
	controller->onEdtTermin(evt.GetItem().GetId());
}

===== ./src/view-plan/PlaenePanel.cpp =====
/* 
 * File:   PlaenePanel.cpp
 * Author: Yannik
 * 
 * Created on August 25, 2015, 12:40 PM
 */

#include "PlaenePanel.h"
#include <wx/snglinst.h>
#include "../R.h"
#include "../App.h"
#include "TerminePlanerDialog.h"
#include "../Util.h"
#include "../view-data/DeleteDialog.h"
#include "../export/PlanerMiniInterfaceDialog.h"

PlaenePanel::PlaenePanel(wxWindow* parent, App* _app)
: wxPanel(parent, R::ID_ANY) {
	app = _app;
	sizer = new wxBoxSizer(wxHORIZONTAL);
	lv_plaene = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[2];
	cols[0].SetText(wxT(""));
	cols[1].SetText(R::ZEITRAUM);
	lv_plaene->InsertColumn(0, cols[0]);
	lv_plaene->InsertColumn(1, cols[1]);
	notifyPlaene();
	sizer->Add(lv_plaene, 1, wxEXPAND, 0);

	sizer_r = new wxBoxSizer(wxVERTICAL);
	bt_add = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_r->Add(bt_add, 0, 0, 0);
	bt_edt = new wxButton(this, R::ID_BT_EDT, R::OEFFNEN);
	sizer_r->Add(bt_edt, 0, 0, 0);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_r->Add(bt_del, 0, 0, 0);
	sizer_r->Add(new wxPanel(this), 1, wxEXPAND, 0);
	bt_extras = new wxButton(this, R::ID_BT_COMPUTE, R::EXTRAS);
	sizer_r->Add(bt_extras, 0, 0, 0);
	sizer->Add(sizer_r, 0, wxEXPAND, 0);
	
	SetSizer(sizer);
}

void PlaenePanel::notifyPlaene(int index) {
	lv_plaene->DeleteAllItems();
	int num = app->list_planer.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		lv_plaene->InsertItem(item);
		lv_plaene->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_plaene->SetItem(i, 1, app->list_planer.at(i).printShort());
	}
	if (index != -1) lv_plaene->Select(index, true);
	lv_plaene->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_plaene->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

BEGIN_EVENT_TABLE(PlaenePanel, wxPanel)
EVT_BUTTON(R::ID_BT_ADD, PlaenePanel::onBtAdd)
EVT_BUTTON(R::ID_BT_DEL, PlaenePanel::onBtDel)
EVT_BUTTON(R::ID_BT_EDT, PlaenePanel::onBtEdt)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, PlaenePanel::onLIActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, PlaenePanel::onLIKey)
EVT_BUTTON(R::ID_BT_COMPUTE, PlaenePanel::onBtExtras)
END_EVENT_TABLE()

void PlaenePanel::onBtAdd(wxCommandEvent&) {
	wxDateTime datum_beginn;
	wxDateTime datum_ende;
	std::vector<Dienst*> list_dienst;
	std::vector<PTermin*> list_termin;
	std::vector<PMessdiener*> list_mini;
	std::vector<PMGruppe*> list_mgruppe;
	std::vector<PFehlzeit*> list_fehlzeit;
	bool edt = false;
	TerminePlanerDialog* dialog = new TerminePlanerDialog(this, app, &edt, &datum_beginn, &datum_ende, &list_dienst, &list_termin, &list_mini, &list_mgruppe, &list_fehlzeit);
	dialog->ShowModal();
	delete dialog;
	if (edt) {
		app->createAndOpenPlanPlaner(datum_beginn, datum_ende, list_dienst, list_termin, list_mini, list_mgruppe, list_fehlzeit);
	}
}

void PlaenePanel::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_plaene->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		app->edtPlanPlaner(i);
		break;
	}
}

void PlaenePanel::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_plaene->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		//check if the corresponding window is opened
		wxSingleInstanceChecker* single_instance_checker = new wxSingleInstanceChecker;
		single_instance_checker->Create(app->list_planer.at(i).getDir());
		if (!single_instance_checker->IsAnotherRunning()) {
			//make sure decision and delete
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) app->delPlanPlaner(i);
		}
		delete single_instance_checker;
		single_instance_checker = 0;
		break;
	}
}

void PlaenePanel::onLIActivated(wxListEvent& evt) {
	app->edtPlanPlaner(evt.GetItem().GetId());
}

void PlaenePanel::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lv_plaene->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			//check if the corresponding window is opened
			wxSingleInstanceChecker* single_instance_checker = new wxSingleInstanceChecker;
			single_instance_checker->Create(app->list_planer.at(i).getDir());
			if (!single_instance_checker->IsAnotherRunning()) {
				//make sure decision and delete
				bool del = false;
				DeleteDialog dialog(this, &del);
				dialog.ShowModal();
				if (del) app->delPlanPlaner(i);
			}
			delete single_instance_checker;
			single_instance_checker = 0;
			break;
		}
	}
}

void PlaenePanel::onBtExtras(wxCommandEvent&) {
	wxDateTime datum_beginn;
	wxDateTime datum_ende;
	std::vector<Dienst*> list_dienst;
	std::vector<PTermin*> list_termin;
	std::vector<PMessdiener*> list_mini;
	std::vector<PMGruppe*> list_mgruppe;
	std::vector<PFehlzeit*> list_fehlzeit;
	bool edt = false;
	PlanerMiniInterfaceDialog* dialog = new PlanerMiniInterfaceDialog(this, app, &edt, &datum_beginn, &datum_ende, &list_dienst, &list_termin, &list_mini, &list_mgruppe, &list_fehlzeit);
	dialog->ShowModal();
	delete dialog;
	if (edt) {
		app->createAndOpenPlanPlaner(datum_beginn, datum_ende, list_dienst, list_termin, list_mini, list_mgruppe, list_fehlzeit);
	}
}

===== ./src/Util.h =====
/* 
 * File:   Util.h
 * Author: Yannik
 *
 * Created on August 12, 2015, 11:36 AM
 */

#ifndef UTIL_H
#define	UTIL_H

#include <wx/datetime.h>
#include <wx/string.h>
#include <vector>
#include "model-plan/PMessdiener.h"
#include "model-plan/PTermin.h"

namespace Util {
	extern wxDateTime wxString_to_wxDateTime(const wxString& s);
	extern wxString wxDateTime_to_wxString(const wxDateTime& d);
	//return dd.mm.yyyy if s valid date, else false and empty target string
	extern bool formatDate(const wxString& s, wxString* target);
	//return true and hh:mm if valid time, else false
	extern bool formatTime(const wxString& s, wxString* target);
	extern wxString rmD(const wxString& s);
	extern void erase_from_minivec(std::vector<PMessdiener*>* list, PMessdiener* mini);
	extern void setMiniNums(std::vector<PMessdiener*>* mlist, std::vector<PTermin*>* tlist);

	enum Wochentag {
		SONNTAG,
		MONTAG,
		DIENSTAG,
		MITTWOCH,
		DONNERSTAG,
		FREITAG,
		SAMSTAG
	};

	enum MONATSWOCHE {
		ERSTER,
		ZWEITER,
		DRITTER,
		VIERTER,
		FUENFTER,
		VORLETZTER,
		LETZTER
	};
};

#endif	/* UTIL_H */

===== ./src/view-data/FehlzeitenPanel.cpp =====
/* 
 * File:   FehlzeitenPanel.cpp
 * Author: Yannik
 * 
 * Created on August 23, 2015, 12:59 PM
 */

#include "FehlzeitenPanel.h"
#include "../App.h"
#include "../R.h"
#include "FehlzeitDialog.h"
#include "DeleteDialog.h"

FehlzeitenPanel::FehlzeitenPanel(wxWindow* parent, App* _app)
: wxPanel(parent, R::ID_ANY) {
	wxBoxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);
	app = _app;
	lv_fehlzeiten = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[3];
	wxString cols_texts[3] = {wxT(""), R::NAME, R::FEHLZEIT};
	for (int i = 0; i < 3; i++) {
		cols[i].SetText(cols_texts[i]);
		lv_fehlzeiten->InsertColumn(i, cols[i]);
	}
	notifyFehlzeiten();
	sizer->Add(lv_fehlzeiten, 1, wxEXPAND, 0);

	wxBoxSizer* sizer_r = new wxBoxSizer(wxVERTICAL);
	bt_add = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_r->Add(bt_add, 0, 0, 0);
	bt_edt = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_r->Add(bt_edt, 0, 0, 0);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_r->Add(bt_del, 0, 0, 0);
	sizer->Add(sizer_r, 0, 0, 0);

	SetSizer(sizer);
}

void FehlzeitenPanel::notifyFehlzeiten(int index) {
	lv_fehlzeiten->DeleteAllItems();
	const int num = app->list_fehlzeit.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		Fehlzeit f = *(app->list_fehlzeit.at(i));
		lv_fehlzeiten->InsertItem(item);
		lv_fehlzeiten->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_fehlzeiten->SetItem(i, 1, f.mini->vorname + wxT(" ") + f.mini->name);
		lv_fehlzeiten->SetItem(i, 2, Fehlzeit::printModus(&f));
	}
	if (index != -1) lv_fehlzeiten->Select(index, true);
	lv_fehlzeiten->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_fehlzeiten->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
	lv_fehlzeiten->SetColumnWidth(2, wxLIST_AUTOSIZE_USEHEADER);
}

BEGIN_EVENT_TABLE(FehlzeitenPanel, wxPanel)
EVT_BUTTON(R::ID_BT_ADD, FehlzeitenPanel::onBtAdd)
EVT_BUTTON(R::ID_BT_DEL, FehlzeitenPanel::onBtDel)
EVT_BUTTON(R::ID_BT_EDT, FehlzeitenPanel::onBtEdt)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, FehlzeitenPanel::onLIActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, FehlzeitenPanel::onLIKey)
END_EVENT_TABLE()

void FehlzeitenPanel::onBtAdd(wxCommandEvent&) {
	FehlzeitDialog* dialog = new FehlzeitDialog(this, app);
	dialog->ShowModal();
	delete dialog;
}

void FehlzeitenPanel::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_fehlzeiten->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) app->delFehlzeit(i);
		break;
	}
}

void FehlzeitenPanel::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_fehlzeiten->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		FehlzeitDialog* dialog = new FehlzeitDialog(this, app, i);
		dialog->ShowModal();
		delete dialog;
		break;
	}
}

void FehlzeitenPanel::onLIActivated(wxListEvent& evt) {
	FehlzeitDialog* dialog = new FehlzeitDialog(this, app, evt.GetItem().GetId());
	dialog->ShowModal();
	delete dialog;
}

void FehlzeitenPanel::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lv_fehlzeiten->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) app->delFehlzeit(i);
			break;
		}
	}
}

===== ./src/view-data/MGruppeDialog.h =====
/* 
 * File:   MGruppeDialog.h
 * Author: Yannik
 *
 * Created on August 13, 2015, 7:08 PM
 */

#ifndef MGRUPPEDIALOG_H
#define	MGRUPPEDIALOG_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include "../model-data/Messdiener.h"
#include "../model-data/MGruppe.h"
#include <vector>
#include <utility>
class App;

class MGruppeDialog : public wxDialog {
public:
	MGruppeDialog(wxWindow* parent, App* _app);
	MGruppeDialog(wxWindow* parent, App* _app, int _index);
private:
	App* app;
	bool edt;
	int index;
	std::vector<Messdiener*> list_gruppe;
	std::vector<Messdiener*> list_rest;
	wxStaticText* st_modus;
	wxChoice* ch_modus;
	wxStaticText* st_gruppe;
	wxStaticText* st_rest;
	wxListView* lv_gruppe;
	wxListView* lv_rest;
	wxButton* bt_togroup;
	wxButton* bt_torest;
	wxButton* bt_ok;
	wxButton* bt_cancel;
	void initComponents();
	void initGruppe();
	void initRest();
	void drawGruppe();
	void drawRest();
	DECLARE_EVENT_TABLE();
	void onBtToGruppe(wxCommandEvent&);
	void onBtToRest(wxCommandEvent&);
	void onBtOk(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};

#endif	/* MGRUPPEDIALOG_H */



===== ./src/view-data/MiniDialog.h =====
/* 
 * File:   MiniDialog.h
 * Author: Yannik
 *
 * Created on August 11, 2015, 7:36 PM
 */

#ifndef MINIDIALOG_H
#define	MINIDIALOG_H

#include <wx/wx.h>
#include <wx/checklst.h>
#include <wx/datectrl.h>
#include <wx/checkbox.h>
#include "../model-data/Messdiener.h"
class App;

class MiniDialog : public wxDialog {
public:
	MiniDialog(wxWindow* parent, App* _app);
	MiniDialog(wxWindow* parent, App* _app, int _index);
private:
	App* app;
	bool edt;
	int index;

	wxStaticText* st_name;
	wxStaticText* st_vorname;
	wxStaticText* st_geburtstag;
	wxStaticText* st_dienste;
	wxStaticText* st_strasse_nr;
	wxStaticText* st_plz_ort;
	wxStaticText* st_tel;
	wxStaticText* st_mobil;
	wxStaticText* st_email;
	wxStaticText* st_bem;

	wxTextCtrl* tc_name;
	wxTextCtrl* tc_vorname;
	wxCheckListBox* lb_dienste;
	wxCheckBox* cb_geburtstag;
	wxDatePickerCtrl* dc_geburtstag;
	wxTextCtrl* tc_strasse_nr;
	wxComboBox* tc_plz_ort;
	wxTextCtrl* tc_tel;
	wxTextCtrl* tc_mobil;
	wxTextCtrl* tc_email;
	wxTextCtrl* tc_bem;

	wxButton* bt_ok;
	wxButton* bt_cancel;
	void initComponents();
	DECLARE_EVENT_TABLE();
	void onBtOK(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
	void onCbGeburtstag(wxCommandEvent& event);
};

#endif	/* MINIDIALOG_H */

===== ./src/view-data/EinzelterminDialog.h =====
/* 
 * File:   EinzelterminDialog.h
 * Author: Yannik
 *
 * Created on August 12, 2015, 6:44 PM
 */

#ifndef EINZELTERMINDIALOG_H
#define	EINZELTERMINDIALOG_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include <wx/datectrl.h>
#include <wx/dateevt.h>
#include <vector>
#include "../model-data/Einzeltermin.h"
class App;

class EinzelterminDialog : public wxDialog {
public:
	EinzelterminDialog(wxWindow* parent, App* _app);
	EinzelterminDialog(wxWindow* parent, App* _app, int _index);
	std::vector< std::pair<Dienst*, int> > dienste;
private:
	App* app;
	bool edt;
	int index;
	wxStaticText* st_name;
	wxStaticText* st_ort;
	wxStaticText* st_datum;
	wxStaticText* st_zeit_beginn;
	wxStaticText* st_dienste;
	wxStaticText* st_bem;
	
	wxTextCtrl* tc_name;
	wxComboBox* tc_ort;
	wxDatePickerCtrl* dc_datum;
	wxStaticText* st_datum_wday;
	wxTextCtrl* tc_zeit_beginn;
	wxListView* lv_dienste;
	wxButton* bt_add_dienst;
	wxButton* bt_edt_dienst;
	wxButton* bt_del_dienst;
	wxTextCtrl* tc_bem;
	
	wxButton* bt_ok;
	wxButton* bt_cancel;
	
	void notifyDienste();
	void initComponents();
	
	DECLARE_EVENT_TABLE();
	void onBtOK(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
	void onBtAddDienst(wxCommandEvent&);
	void onBtEdtDienst(wxCommandEvent&);
	void onBtDelDienst(wxCommandEvent&);
	void onLIDienstActivated(wxListEvent& evt);
	void onDateChanged(wxDateEvent&);
};

#endif	/* EINZELTERMINDIALOG_H */

===== ./src/view-data/DeleteDialog.h =====
/* 
 * File:   DeleteDialog.h
 * Author: Yannik
 *
 * Created on October 2, 2015, 4:13 PM
 */

#ifndef DELETEDIALOG_H
#define	DELETEDIALOG_H

#include <wx/wx.h>

class DeleteDialog : public wxDialog {
public:
	DeleteDialog(wxWindow* parent, bool* _del);
private:
	bool* del;

	wxButton* bt_yes;
	wxButton* bt_no;
	DECLARE_EVENT_TABLE();
	void onBtYes(wxCommandEvent&);
	void onBtNo(wxCommandEvent&);
};

#endif	/* DELETEDIALOG_H */



===== ./src/view-data/TerminDienstDialog.cpp =====
/* 
 * File:   TerminDienstDialog.cpp
 * Author: Yannik
 * 
 * Created on August 21, 2015, 10:17 AM
 */

#include "TerminDienstDialog.h"

TerminDienstDialog::TerminDienstDialog(wxWindow* parent, std::vector< std::pair<Dienst*, int> >* _dienste, std::vector<Dienst*>* _missing_dienste)
: wxDialog(parent, R::ID_ANY, R::TERMIN_DIENST_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	edt = false;
	dienste = _dienste;
	missing_dienste = _missing_dienste;
	initComponents();
}

TerminDienstDialog::TerminDienstDialog(wxWindow* parent, std::vector< std::pair<Dienst*, int> >* _dienste, std::vector<Dienst*>* _missing_dienste, int _index)
: wxDialog(parent, R::ID_ANY, R::TERMIN_DIENST_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	edt = true;
	index = _index;
	dienste = _dienste;
	missing_dienste = _missing_dienste;
	initComponents();
	sp_anzahl->SetValue(dienste->at(index).second);
}

void TerminDienstDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	wxFlexGridSizer* gridsizer = new wxFlexGridSizer(2, 2, 0, 0);

	st_dienst = new wxStaticText(this, R::ID_ANY, R::DIENST);
	gridsizer->Add(st_dienst, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int num = missing_dienste->size();
	wxString dienste_s[num];
	for (int i = 0; i < num; i++) {
		dienste_s[i] = missing_dienste->at(i)->name;
	}
	ch_dienst = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, num, dienste_s);
	ch_dienst->SetSelection(0);//seems to work with empty lists
	gridsizer->Add(ch_dienst, 1, wxEXPAND | wxALL, 2);
	st_anzahl = new wxStaticText(this, R::ID_ANY, R::ANZAHL);
	gridsizer->Add(st_anzahl, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	sp_anzahl = new wxSpinCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 1, 1000000000, 1);
	gridsizer->Add(sp_anzahl, 1, wxEXPAND | wxALL, 2);

	sizer->Add(gridsizer, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
}

BEGIN_EVENT_TABLE(TerminDienstDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, TerminDienstDialog::onBtOK)
EVT_BUTTON(R::ID_BT_CANCEL, TerminDienstDialog::onBtCancel)
END_EVENT_TABLE()

void TerminDienstDialog::onBtOK(wxCommandEvent&) {
	int dienst_i = ch_dienst->GetSelection();
	if (dienst_i == wxNOT_FOUND) {
		wxMessageDialog dialog(this, R::MSG_DIENST_SEL_ERR);
		dialog.ShowModal();
		return;
	}
	if (edt) {
		dienste->at(index).first = missing_dienste->at(dienst_i);
		dienste->at(index).second = sp_anzahl->GetValue();
		Close(true);
	} else {
		dienste->push_back(std::make_pair(missing_dienste->at(dienst_i), sp_anzahl->GetValue()));
		Close(true);
	}
}

void TerminDienstDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

===== ./src/view-data/MinisPanel.cpp =====
/* 
 * File:   MinisPanel.cpp
 * Author: Yannik
 * 
 * Created on August 11, 2015, 5:37 PM
 */

#include "MinisPanel.h"
#include <algorithm>
#include "../App.h"
#include "../model-data/Messdiener.h"
#include "MiniDialog.h"
#include "DeleteDialog.h"
#include "../export/MiniExportDialog.h"
#include "../import/MiniImportDialog.h"
#include "MiniExtrasDialog.h"

MinisPanel::MinisPanel(wxWindow* parent, App* _app)
: wxPanel(parent, R::ID_ANY) {
	app = _app;
	sizer = new wxBoxSizer(wxHORIZONTAL);
	sizer_r = new wxBoxSizer(wxVERTICAL);
	lc_minis = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem lc_minis_cols[R::MINI_ATTS_NUM + 1];
	lc_minis_cols[0].SetText(wxT(""));
	lc_minis->InsertColumn(0, lc_minis_cols[0]);
	for (int i = 1; i < R::MINI_ATTS_NUM + 1; i++) {
		lc_minis_cols[i].SetText(R::MINI_ATTS[i - 1]);
		lc_minis->InsertColumn(i, lc_minis_cols[i]);
	}
	notifyMinis();
	sizer->Add(lc_minis, 1, wxEXPAND, 0);
	
	bt_add = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_r->Add(bt_add, 0, 0, 0);
	bt_edt = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_r->Add(bt_edt, 0, 0, 0);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_r->Add(bt_del, 0, 0, 0);
	sizer_r->Add(new wxPanel(this, R::ID_ANY), 1, wxEXPAND, 0);
	bt_import = new wxButton(this, R::ID_IMPORT, R::IMPORT);
	sizer_r->Add(bt_import, 0, 0, 0);
	bt_export = new wxButton(this, R::ID_EXPORT, R::EXPORT);
	sizer_r->Add(bt_export, 0, 0, 0);
	bt_extras = new wxButton(this, R::ID_BT_COMPUTE, R::EXTRAS);
	sizer_r->Add(bt_extras, 0, 0, 0);
	sizer->Add(sizer_r, 0, wxEXPAND, 0);

	SetSizer(sizer);
}

void MinisPanel::notifyMinis(int index) {
	shownMinis = app->list_mini;
	drawMinis(index);
}

void MinisPanel::drawMinis(int index) {
	lc_minis->DeleteAllItems();
	const int num = shownMinis.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		Messdiener* m = shownMinis.at(i);
		lc_minis->InsertItem(item);
		lc_minis->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lc_minis->SetItem(i, 1, m->name);
		lc_minis->SetItem(i, 2, m->vorname);
		lc_minis->SetItem(i, 3, Messdiener::printDienste(m));
		lc_minis->SetItem(i, 4, m->geburtstag);
		lc_minis->SetItem(i, 5, m->strasse_nr);
		lc_minis->SetItem(i, 6, m->plz_ort);
		lc_minis->SetItem(i, 7, m->tel);
		lc_minis->SetItem(i, 8, m->mobile);
		lc_minis->SetItem(i, 9, m->email);
		lc_minis->SetItem(i, 10, m->bem);
	}
	if (index != -1) lc_minis->Select(index, true);
	for (int i = 0; i < R::MINI_ATTS_NUM + 1; i++) {
		lc_minis->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

BEGIN_EVENT_TABLE(MinisPanel, wxPanel)
EVT_BUTTON(R::ID_BT_ADD, MinisPanel::onBtAdd)
EVT_BUTTON(R::ID_BT_DEL, MinisPanel::onBtDel)
EVT_BUTTON(R::ID_BT_EDT, MinisPanel::onBtEdt)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, MinisPanel::onLIActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, MinisPanel::onLIKey)
//EVT_LIST_COL_CLICK(R::ID_LC, MinisPanel::onColClick)
EVT_BUTTON(R::ID_EXPORT, MinisPanel::onBtExport)
EVT_BUTTON(R::ID_IMPORT, MinisPanel::onBtImport)
EVT_BUTTON(R::ID_BT_COMPUTE, MinisPanel::onBtExtras)
END_EVENT_TABLE()

void MinisPanel::onBtAdd(wxCommandEvent&) {
	MiniDialog* dialog = new MiniDialog(this, app);
	dialog->ShowModal();
	delete dialog;
}

void MinisPanel::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_minis->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) app->delMini(i);
		break;
	}
}

void MinisPanel::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_minis->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		MiniDialog* dialog = new MiniDialog(this, app, i);
		dialog->ShowModal();
		delete dialog;
		break;
	}
}

void MinisPanel::onLIActivated(wxListEvent& evt) {
	MiniDialog* dialog = new MiniDialog(this, app, evt.GetItem().GetId());
	dialog->ShowModal();
	delete dialog;
}

void MinisPanel::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lc_minis->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) app->delMini(i);
			break;
		}
	}
}

void MinisPanel::sortByString(bool inc, wxString Messdiener::* var) {
	if (inc) {
		std::sort(shownMinis.begin(), shownMinis.end(), [&var](const Messdiener* m1, const Messdiener* m2) {return (m1->*var).Cmp(m2->*var) < 0;});
	} else {
		std::sort(shownMinis.begin(), shownMinis.end(), [&var](const Messdiener* m1, const Messdiener* m2) {return (m1->*var).Cmp(m2->*var) > 0;});
	}
	drawMinis();
}

void MinisPanel::onBtExport(wxCommandEvent&) {
	MiniExportDialog dialog(this, &app->list_mini);
	dialog.ShowModal();
}

void MinisPanel::onBtImport(wxCommandEvent&) {
	bool edt = false;
	std::vector<Messdiener*> list_mini;
	MiniImportDialog dialog(this, &list_mini, &edt);
	dialog.ShowModal();
	if (edt) app->importMinis(list_mini);
}

void MinisPanel::onBtExtras(wxCommandEvent&) {
	MiniExtrasDialog dialog(this, &app->list_mini);
	dialog.ShowModal();
}

===== ./src/view-data/MGruppeDialog.cpp =====
/* 
 * File:   MGruppeDialog.cpp
 * Author: Yannik
 * 
 * Created on August 13, 2015, 7:08 PM
 */

#include "MGruppeDialog.h"
#include <wx/gbsizer.h>
#include "../App.h"
#include "../R.h"
#include "../Util.h"
#include <algorithm>

MGruppeDialog::MGruppeDialog(wxWindow* parent, App* _app)
: wxDialog(parent, R::ID_ANY, R::MGRUPPE_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = false;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

MGruppeDialog::MGruppeDialog(wxWindow* parent, App* _app, int _index)
: wxDialog(parent, R::ID_ANY, R::MGRUPPE_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = true;
	index = _index;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

void MGruppeDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxBoxSizer* sizer_modus = new wxBoxSizer(wxHORIZONTAL);
	st_modus = new wxStaticText(this, R::ID_ANY, R::MODUS);
	sizer_modus->Add(st_modus, 0, wxALIGN_CENTER_VERTICAL | wxRIGHT, 3);
	wxString modi[2] = {R::BEV_GEM, R::NUR_GEM};
	ch_modus = new wxChoice(this, R::ID_CH, wxDefaultPosition, wxDefaultSize, 2, modi);
	ch_modus->SetSelection(0);
	sizer_modus->Add(ch_modus, 1, wxEXPAND, 0);
	sizer->Add(sizer_modus, 0, wxEXPAND | wxALL, 5);

	wxBoxSizer* sizer_t = new wxBoxSizer(wxHORIZONTAL);

	wxBoxSizer* sizer_gruppe = new wxBoxSizer(wxVERTICAL);
	st_gruppe = new wxStaticText(this, R::ID_ANY, R::GRUPPE);
	sizer_gruppe->Add(st_gruppe, 0, 0, 0);
	lv_gruppe = new wxListView(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_NO_HEADER | wxLC_SINGLE_SEL);
	wxListItem lv_gruppe_col;
	lv_gruppe->InsertColumn(0, lv_gruppe_col);
	sizer_gruppe->Add(lv_gruppe, 1, wxEXPAND, 0);
	sizer_t->Add(sizer_gruppe, 1, wxEXPAND, 0);

	wxBoxSizer* inout_sizer = new wxBoxSizer(wxVERTICAL);
	bt_togroup = new wxButton(this, R::ID_BT_ADD, wxT("\x2190"));
	inout_sizer->Add(bt_togroup, 1, wxALL, 5);
	bt_torest = new wxButton(this, R::ID_BT_DEL, wxT("\x2192"));
	inout_sizer->Add(bt_torest, 1, wxALL, 5);
	sizer_t->Add(inout_sizer, 0, wxALIGN_CENTER_VERTICAL, 0);

	wxBoxSizer* sizer_rest = new wxBoxSizer(wxVERTICAL);
	st_rest = new wxStaticText(this, R::ID_ANY, R::RESTLISTE);
	sizer_rest->Add(st_rest, 0, 0, 0);
	lv_rest = new wxListView(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_NO_HEADER | wxLC_SINGLE_SEL);
	wxListItem lv_rest_col;
	lv_rest->InsertColumn(0, lv_rest_col);
	sizer_rest->Add(lv_rest, 1, wxEXPAND, 0);
	sizer_t->Add(sizer_rest, 1, wxEXPAND, 0);

	sizer->Add(sizer_t, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	initRest();
	drawRest();
	if (edt) {
		ch_modus->SetSelection(app->list_mgruppe.at(index)->modus);
		initGruppe();
		drawGruppe();
	}
	lv_gruppe->Fit();
	lv_rest->Fit();
	SetSizerAndFit(sizer);
	if (GetSize().GetHeight() < 300) {
		SetSize(-1, 300);
	}
}

void MGruppeDialog::initRest() {
	list_rest = app->list_mini;
	std::vector<Messdiener*>::iterator iter = list_rest.begin();
	while (iter != list_rest.end()) {
		bool inSomeGroup = false;
		for (std::vector<MGruppe*>::iterator iter_mg = app->list_mgruppe.begin(); iter_mg != app->list_mgruppe.end() && !inSomeGroup; iter_mg++) {
			for (std::vector<Messdiener*>::iterator iter_m = (**iter_mg).list.begin(); iter_m != (**iter_mg).list.end(); iter_m++) {
				if (*iter_m == *iter) {
					inSomeGroup = true;
					break;
				}
			}
		}
		if (inSomeGroup) {
			iter = list_rest.erase(iter);
		} else {
			iter++;
		}
	}
}

void MGruppeDialog::initGruppe() {
	list_gruppe = app->list_mgruppe.at(index)->list;
}

void MGruppeDialog::drawRest() {
	lv_rest->DeleteAllItems();
	int size = list_rest.size();
	for (int i = 0; i < size; i++) {
		wxListItem item;
		item.SetId(i);
		lv_rest->InsertItem(item);
		Messdiener* m = list_rest.at(i);
		lv_rest->SetItem(i, 0, m->vorname + wxT(" ") + m->name);
	}
	lv_rest->SetColumnWidth(0, wxLIST_AUTOSIZE);
}

void MGruppeDialog::drawGruppe() {
	lv_gruppe->DeleteAllItems();
	int size = list_gruppe.size();
	for (int i = 0; i < size; i++) {
		wxListItem item;
		item.SetId(i);
		lv_gruppe->InsertItem(item);
		Messdiener* m = list_gruppe.at(i);
		lv_gruppe->SetItem(i, 0, m->vorname + wxT(" ") + m->name);
	}
	lv_gruppe->SetColumnWidth(0, wxLIST_AUTOSIZE);
}

BEGIN_EVENT_TABLE(MGruppeDialog, wxDialog)
EVT_BUTTON(R::ID_BT_ADD, MGruppeDialog::onBtToGruppe)
EVT_BUTTON(R::ID_BT_DEL, MGruppeDialog::onBtToRest)
EVT_BUTTON(R::ID_BT_OK, MGruppeDialog::onBtOk)
EVT_BUTTON(R::ID_BT_CANCEL, MGruppeDialog::onBtCancel)
END_EVENT_TABLE()

void MGruppeDialog::onBtToGruppe(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_rest->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		list_gruppe.push_back(list_rest.at(i));
		std::sort(list_gruppe.begin(), list_gruppe.end(), Messdiener::cmp);
		list_rest.erase(list_rest.begin() + i);

		drawRest();
		drawGruppe();
		break;
	}
}

void MGruppeDialog::onBtToRest(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_gruppe->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		list_rest.push_back(list_gruppe.at(i));
		std::sort(list_rest.begin(), list_rest.end(), Messdiener::cmp);
		list_gruppe.erase(list_gruppe.begin() + i);

		drawGruppe();
		drawRest();
		break;
	}
}

void MGruppeDialog::onBtOk(wxCommandEvent&) {
	if (list_gruppe.size() > 1) {//group has min. 2 members
		MGruppe* mg = new MGruppe(ch_modus->GetSelection(), list_gruppe);
		if (edt) {
			app->edtMGruppe(index, mg);
			delete mg;
		} else {
			app->addMGruppe(mg);
		}
		Close(true);
	} else {
		wxMessageDialog dialog(this, R::MSG_GROUP_NUM);
		dialog.ShowModal();
	}
}

void MGruppeDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

===== ./src/view-data/FehlzeitDialog.h =====
/* 
 * File:   FehlzeitDialog.h
 * Author: Yannik
 *
 * Created on August 23, 2015, 5:08 PM
 */

#ifndef FEHLZEITDIALOG_H
#define	FEHLZEITDIALOG_H

#include <wx/wx.h>
#include <wx/datectrl.h>
#include <wx/dateevt.h>
class App;

class FehlzeitDialog : public wxDialog {
public:
	FehlzeitDialog(wxWindow* parent, App* _app);
	FehlzeitDialog(wxWindow* parent, App* _app, int _index);
private:
	App* app;
	bool edt;
	int index;

	wxFlexGridSizer* gridsizer;
	wxStaticText* st_mini;
	wxChoice* ch_mini;
	wxStaticText* st_modus;
	wxChoice* ch_modus;
	wxStaticText* st_termin;
	wxChoice* ch_termin;
	wxStaticText* st_wochentag;
	wxChoice* ch_wochentag;
	wxStaticText* st_datum_beginn;
	wxDatePickerCtrl* dc_beginn;
	wxStaticText* st_beginn_wday;
	wxStaticText* st_datum_ende;
	wxDatePickerCtrl* dc_ende;
	wxStaticText* st_ende_wday;
	wxStaticText* st_zeit_beginn;
	wxTextCtrl* tc_beginn;
	wxStaticText* st_zeit_ende;
	wxTextCtrl* tc_ende;

	wxButton* bt_ok;
	wxButton* bt_cancel;

	void initComponents();
	void setModusZeitraum();
	void setModusWochentag();
	void setModusTermin();
	DECLARE_EVENT_TABLE();
	void onChModus(wxCommandEvent&);
	void onBtOk(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
	void onDateBeginnChanged(wxDateEvent&);
	void onDateEndeChanged(wxDateEvent&);
};

#endif	/* FEHLZEITDIALOG_H */



===== ./src/view-data/EinzelterminDialog.cpp =====
/* 
 * File:   EinzelterminDialog.cpp
 * Author: Yannik
 * 
 * Created on August 12, 2015, 6:44 PM
 */

#include "EinzelterminDialog.h"
#include <algorithm>
#include "../App.h"
#include "../R.h"
#include "../Util.h"
#include "TerminDienstDialog.h"

EinzelterminDialog::EinzelterminDialog(wxWindow* parent, App* _app)
: wxDialog(parent, R::ID_ANY, R::EINZELTERMIN_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = false;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

EinzelterminDialog::EinzelterminDialog(wxWindow* parent, App* _app, int _index)
: wxDialog(parent, R::ID_ANY, R::EINZELTERMIN_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = true;
	index = _index;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

void EinzelterminDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxFlexGridSizer* gridsizer = new wxFlexGridSizer(R::TEINZEL_NUM, 2, 0, 0);

	st_name = new wxStaticText(this, R::ID_ANY, R::NAME);
	gridsizer->Add(st_name, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_name = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_name, 1, wxEXPAND | wxALL, 2);

	st_ort = new wxStaticText(this, R::ID_ANY, R::ORT);
	gridsizer->Add(st_ort, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int num_orte =app->list_ort.size();
	wxString arr_orte[num_orte];
	for(int i = 0; i < num_orte; i++) {
		arr_orte[i] = app->list_ort.at(i);
	}
	tc_ort = new wxComboBox(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, num_orte, arr_orte);
	gridsizer->Add(tc_ort, 1, wxEXPAND | wxALL, 2);

	st_datum = new wxStaticText(this, R::ID_ANY, R::DATUM);
	gridsizer->Add(st_datum, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_datum = new wxBoxSizer(wxHORIZONTAL);
	dc_datum = new wxDatePickerCtrl(this, R::ID_CH, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, wxDP_DEFAULT | wxDP_SHOWCENTURY);
	sizer_datum->Add(dc_datum, 1, wxEXPAND | wxALL, 2);
	st_datum_wday = new wxStaticText(this, R::ID_ANY, wxT("(") + R::WOCHENTAGE[dc_datum->GetValue().GetWeekDay()] + wxT(")"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT | wxST_NO_AUTORESIZE);
	sizer_datum->Add(st_datum_wday, 1, wxALL | wxALIGN_CENTER_VERTICAL | wxALIGN_RIGHT, 2);
	gridsizer->Add(sizer_datum, 1, wxEXPAND | wxALL, 2);

	st_zeit_beginn = new wxStaticText(this, R::ID_ANY, R::ZEIT);
	gridsizer->Add(st_zeit_beginn, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_zeit_beginn = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	tc_zeit_beginn->SetHint(wxT("hh:mm"));
	gridsizer->Add(tc_zeit_beginn, 1, wxEXPAND | wxALL, 2);

	st_dienste = new wxStaticText(this, R::ID_ANY, R::DIENSTE);
	gridsizer->Add(st_dienste, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_dienste = new wxBoxSizer(wxHORIZONTAL);
	lv_dienste = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[2];
	cols[0].SetText(R::DIENST);
	lv_dienste->InsertColumn(0, cols[0]);
	cols[1].SetText(R::ANZAHL);
	lv_dienste->InsertColumn(1, cols[1]);
	sizer_dienste->Add(lv_dienste, 1, wxEXPAND, 0);
	wxBoxSizer* sizer_dienste_r = new wxBoxSizer(wxVERTICAL);
	bt_add_dienst = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_dienste_r->Add(bt_add_dienst, 0, 0, 0);
	bt_edt_dienst = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_dienste_r->Add(bt_edt_dienst, 0, 0, 0);
	bt_del_dienst = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_dienste_r->Add(bt_del_dienst, 0, 0, 0);
	sizer_dienste->Add(sizer_dienste_r, 0, 0, 0);
	gridsizer->Add(sizer_dienste, 1, wxEXPAND | wxALL, 2);

	st_bem = new wxStaticText(this, R::ID_ANY, R::BEM);
	gridsizer->Add(st_bem, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_bem = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_bem, 1, wxEXPAND | wxALL, 2);

	gridsizer->AddGrowableCol(1, 1);
	gridsizer->AddGrowableRow(4, 1);
	sizer->Add(gridsizer, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizer(sizer);
	Fit();
	if (GetSize().GetWidth() < 260) {
		SetSize(260, -1);
	}

	if (edt) {
		Einzeltermin termin = *(app->list_einzeltermin.at(index));
		tc_name->SetValue(termin.name);
		dienste = termin.dienste;
		notifyDienste();
		tc_ort->SetValue(termin.ort);
		dc_datum->SetValue(Util::wxString_to_wxDateTime(termin.datum));
		st_datum_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum->GetValue().GetWeekDay()] + wxT(")"));
		tc_zeit_beginn->SetValue(termin.zeit_beginn);
		tc_bem->SetValue(termin.bem);
	}
}

void EinzelterminDialog::notifyDienste() {
	lv_dienste->DeleteAllItems();
	int num_dienste = dienste.size();
	for (int i = 0; i < num_dienste; i++) {
		wxListItem item;
		item.SetId(i);
		lv_dienste->InsertItem(item);
		lv_dienste->SetItem(i, 0, dienste.at(i).first->name);
		lv_dienste->SetItem(i, 1, wxString::Format(wxT("%i"), dienste.at(i).second));
	}
	lv_dienste->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_dienste->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

BEGIN_EVENT_TABLE(EinzelterminDialog, wxDialog)
EVT_BUTTON(R::ID_BT_ADD, EinzelterminDialog::onBtAddDienst)
EVT_BUTTON(R::ID_BT_EDT, EinzelterminDialog::onBtEdtDienst)
EVT_BUTTON(R::ID_BT_DEL, EinzelterminDialog::onBtDelDienst)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, EinzelterminDialog::onLIDienstActivated)
EVT_BUTTON(R::ID_BT_OK, EinzelterminDialog::onBtOK)
EVT_BUTTON(R::ID_BT_CANCEL, EinzelterminDialog::onBtCancel)
EVT_DATE_CHANGED(R::ID_CH, EinzelterminDialog::onDateChanged)
END_EVENT_TABLE()

void EinzelterminDialog::onBtAddDienst(wxCommandEvent&) {
	std::vector<Dienst*> missing_dienste;
	for (std::vector<Dienst*>::iterator iter = app->list_dienst.begin(); iter != app->list_dienst.end(); iter++) {
		bool contains = false;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = dienste.begin(); iter_t != dienste.end(); iter_t++) {
			if (*iter == iter_t->first) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			missing_dienste.push_back(*iter);
		}
	}
	TerminDienstDialog* dialog = new TerminDienstDialog(this, &dienste, &missing_dienste);
	dialog->ShowModal();
	delete dialog;
	std::sort(dienste.begin(), dienste.end(), Dienst::cmp2);
	notifyDienste();
}

void EinzelterminDialog::onBtEdtDienst(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		std::vector<Dienst*> missing_dienste;
		missing_dienste.insert(missing_dienste.begin(), dienste.at(i).first);
		for (std::vector<Dienst*>::iterator iter = app->list_dienst.begin(); iter != app->list_dienst.end(); iter++) {
			bool contains = false;
			for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = dienste.begin(); iter_t != dienste.end(); iter_t++) {
				if (*iter == iter_t->first) {
					contains = true;
					break;
				}
			}
			if (!contains) {
				missing_dienste.push_back(*iter);
			}
		}
		TerminDienstDialog* dialog = new TerminDienstDialog(this, &dienste, &missing_dienste, i);
		dialog->ShowModal();
		delete dialog;
		break;
	}
	std::sort(dienste.begin(), dienste.end(), Dienst::cmp2);
	notifyDienste();
}

void EinzelterminDialog::onBtDelDienst(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		dienste.erase(dienste.begin() + i);
		break;
	}
	notifyDienste();
}

void EinzelterminDialog::onLIDienstActivated(wxListEvent& evt) {
	std::vector<Dienst*> missing_dienste;
	missing_dienste.insert(missing_dienste.begin(), dienste.at(evt.GetItem().GetId()).first);
	for (std::vector<Dienst*>::iterator iter = app->list_dienst.begin(); iter != app->list_dienst.end(); iter++) {
		bool contains = false;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = dienste.begin(); iter_t != dienste.end(); iter_t++) {
			if (*iter == iter_t->first) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			missing_dienste.push_back(*iter);
		}
	}
	TerminDienstDialog* dialog = new TerminDienstDialog(this, &dienste, &missing_dienste, evt.GetItem().GetId());
	dialog->ShowModal();
	delete dialog;
	std::sort(dienste.begin(), dienste.end(), Dienst::cmp2);
	notifyDienste();
}

void EinzelterminDialog::onBtOK(wxCommandEvent&) {
	wxString t_zeit_beginn;
	if (!Util::formatTime(tc_zeit_beginn->GetValue(), &t_zeit_beginn)) {
		wxMessageDialog dialog(this, R::MSG_TIME_ERR);
		dialog.ShowModal();
		return;
	}
	Einzeltermin* t = new Einzeltermin(Util::rmD(tc_name->GetValue()), Util::rmD(tc_ort->GetValue()),
			Util::wxDateTime_to_wxString(dc_datum->GetValue()), t_zeit_beginn, dienste, Util::rmD(tc_bem->GetValue()));
	if (edt) {
		if (!app->edtEinzeltermin(index, t)) {
			delete t;
			wxMessageDialog dialog(this, R::MSG_EINZEL_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			delete t;
			Close(true);
		}
	} else {
		if (!app->addEinzeltermin(t)) {
			delete t;
			wxMessageDialog dialog(this, R::MSG_EINZEL_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			Close(true);
		}
	}
}

void EinzelterminDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

void EinzelterminDialog::onDateChanged(wxDateEvent&) {
	st_datum_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum->GetValue().GetWeekDay()] + wxT(")"));
}

===== ./src/view-data/MiniExtrasDialog.cpp =====
/* 
 * File:   MiniExtrasDialog.cpp
 * Author: Yannik
 * 
 * Created on February 11, 2016, 9:39 PM
 */

#include "MiniExtrasDialog.h"
#include <wx/clipbrd.h>
#include "../R.h"

MiniExtrasDialog::MiniExtrasDialog(wxWindow* parent, std::vector<Messdiener*>* _list_mini)
: wxDialog(parent, R::ID_ANY, R::MINI_EXTRAS_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	list_mini = _list_mini;

	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxFlexGridSizer* sizer_1 = new wxFlexGridSizer(2, 2, 0, 0);
	
	wxButton* bt_email = new wxButton(this, R::ID_BT_ADD, R::EMAILS);
	sizer_1->Add(bt_email, 0, wxALL, 2);
	wxStaticText* st_email = new wxStaticText(this, R::ID_ANY, R::KOPIERTEMAILS);
	sizer_1->Add(st_email, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	
	wxButton* bt_adressen = new wxButton(this, R::ID_BT_DEL, R::ADRESSEN);
	sizer_1->Add(bt_adressen, 0, wxALL, 2);
	wxStaticText* st_adressen = new wxStaticText(this, R::ID_ANY, R::KOPIERTADRESSEN);
	sizer_1->Add(st_adressen, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	
	sizer->Add(sizer_1, 0, wxALL, 2);

	textbox = new wxTextCtrl(this, R::ID_ANY, wxT(""), wxDefaultPosition, wxDefaultSize, wxTE_READONLY | wxTE_MULTILINE);
	sizer->Add(textbox, 1, wxALL | wxEXPAND, 2);
	SetSizerAndFit(sizer);
	if (GetSize().GetHeight() < 210) {
		SetSize(-1, 210);
	}
}

void MiniExtrasDialog::createEmails() {
	successString.Empty();
	failureString.Empty();
	for (std::vector<Messdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
		Messdiener* mini = *iter;
		if (mini->email.IsEmpty()) {
			failureString += mini->name + wxT(", ") + mini->vorname + wxT("\n");
		} else {
			successString += mini->email + wxT("; ");
		}
	}
}

void MiniExtrasDialog::createAddresses() {
	successString.Empty();
	failureString.Empty();
	for (std::vector<Messdiener*>::iterator iter = list_mini->begin(); iter != list_mini->end(); iter++) {
		Messdiener* mini = *iter;
		if (mini->plz_ort.IsEmpty() && mini->strasse_nr.IsEmpty()) {
			failureString += mini->name + wxT(", ") + mini->vorname + wxT("\n");
		} else {
			successString += mini->vorname + wxT(" ") + mini->name + wxT("\n") + mini->strasse_nr + wxT("\n") + mini->plz_ort + wxT("\n\n");
		}
	}
}

BEGIN_EVENT_TABLE(MiniExtrasDialog, wxDialog)
EVT_BUTTON(R::ID_BT_ADD, MiniExtrasDialog::onBtEmail)
EVT_BUTTON(R::ID_BT_DEL, MiniExtrasDialog::onBtAddresses)
END_EVENT_TABLE()

void MiniExtrasDialog::onBtEmail(wxCommandEvent&) {
	createEmails();
	if (wxTheClipboard->Open()) {
		wxTheClipboard->SetData(new wxTextDataObject(successString));
		wxTheClipboard->Close();
		wxString msg = R::KOPIERTEMAILSFERTIG;
		if (!failureString.IsEmpty()) {
			msg += R::KOPIERTWARNICHTMOEGLICH + failureString;
		}
		textbox->SetValue(msg);
	}
}

void MiniExtrasDialog::onBtAddresses(wxCommandEvent&) {
	createAddresses();
	if (wxTheClipboard->Open()) {
		wxTheClipboard->SetData(new wxTextDataObject(successString));
		wxTheClipboard->Close();
		wxString msg = R::KOPIERTADRESSENFERTIG;
		if (!failureString.IsEmpty()) {
			msg += R::KOPIERTWARNICHTMOEGLICH + failureString;
		}
		textbox->SetValue(msg);
	}
}

===== ./src/view-data/DienstePanel.cpp =====
/* 
 * File:   DienstePanel.cpp
 * Author: Yannik
 * 
 * Created on August 19, 2015, 11:37 AM
 */

#include "DienstePanel.h"
#include "../R.h"
#include "../App.h"
#include "DienstDialog.h"
#include "DeleteDialog.h"

DienstePanel::DienstePanel(wxWindow* parent, App* _app)
: wxPanel(parent, R::ID_ANY) {
	app = _app;
	wxBoxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer* sizer_r = new wxBoxSizer(wxVERTICAL);
	lc_dienste = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem lc_dienste_cols[2];
	lc_dienste_cols[0].SetText(wxT(""));
	lc_dienste->InsertColumn(0, lc_dienste_cols[0]);
	lc_dienste_cols[1].SetText(R::DIENST);
	lc_dienste->InsertColumn(1, lc_dienste_cols[1]);
	notifyDienste();
	sizer->Add(lc_dienste, 1, wxEXPAND, 0);
	bt_add = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_r->Add(bt_add, 0, 0, 0);
	bt_edt = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_r->Add(bt_edt, 0, 0, 0);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_r->Add(bt_del, 0, 0, 0);
	sizer->Add(sizer_r, 0, 0, 0);
	SetSizerAndFit(sizer);
}

void DienstePanel::notifyDienste(int index) {
	lc_dienste->DeleteAllItems();
	const int num = app->list_dienst.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		Dienst d = *(app->list_dienst.at(i));
		lc_dienste->InsertItem(item);
		lc_dienste->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lc_dienste->SetItem(i, 1, d.name);
	}
	if (index != -1) lc_dienste->Select(index, true);
	lc_dienste->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lc_dienste->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

BEGIN_EVENT_TABLE(DienstePanel, wxPanel)
EVT_BUTTON(R::ID_BT_ADD, DienstePanel::onBtAdd)
EVT_BUTTON(R::ID_BT_DEL, DienstePanel::onBtDel)
EVT_BUTTON(R::ID_BT_EDT, DienstePanel::onBtEdt)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, DienstePanel::onLIActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, DienstePanel::onLIKey)
END_EVENT_TABLE()

void DienstePanel::onBtAdd(wxCommandEvent&) {
	DienstDialog dialog(this, app);
	dialog.ShowModal();
}

void DienstePanel::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) app->delDienst(i);
		break;
	}
}

void DienstePanel::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		DienstDialog dialog(this, app, i);
		dialog.ShowModal();
		break;
	}
}

void DienstePanel::onLIActivated(wxListEvent& evt) {
	DienstDialog dialog(this, app, evt.GetItem().GetId());
	dialog.ShowModal();
}

void DienstePanel::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lc_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) app->delDienst(i);
			break;
		}
	}
}

===== ./src/view-data/DeleteDialog.cpp =====
/* 
 * File:   DeleteDialog.cpp
 * Author: Yannik
 * 
 * Created on October 2, 2015, 4:13 PM
 */

#include "DeleteDialog.h"
#include "../R.h"

DeleteDialog::DeleteDialog(wxWindow* parent, bool* _del)
: wxDialog(parent, R::ID_ANY, R::LOESCHEN_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	del = _del;
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxStaticText* st_q = new wxStaticText(this, R::ID_ANY, R::Q_LOESCHEN);
	sizer->Add(st_q, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_yes = new wxButton(this, R::ID_BT_OK, R::JA);
	btsizer->Add(bt_yes);
	bt_no = new wxButton(this, R::ID_BT_CANCEL, R::NEIN);
	btsizer->Add(bt_no);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
	R::setSubWindowPosition(parent, this);
}

BEGIN_EVENT_TABLE(DeleteDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, DeleteDialog::onBtYes)
EVT_BUTTON(R::ID_BT_CANCEL, DeleteDialog::onBtNo)
END_EVENT_TABLE()

void DeleteDialog::onBtYes(wxCommandEvent&) {
	*del = true;
	Close(true);
}

void DeleteDialog::onBtNo(wxCommandEvent&) {
	Close(true);
}


===== ./src/view-data/TGruppenPanel.h =====
/* 
 * File:   TGruppePanel.h
 * Author: Yannik
 *
 * Created on August 16, 2015, 10:30 AM
 */

#ifndef TGRUPPENPANEL_H
#define	TGRUPPENPANEL_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include "../model-data/TGruppe.h"
#include "../R.h"
class App;

class TGruppenPanel : public wxPanel {
public:
	TGruppenPanel(wxWindow* parent, App* _app);
	void notifyTGruppen(int index = -1);
private:
	App* app;
	wxListView* lv_tgruppen;
	std::vector<int> list_tgruppen_indices;
	wxButton* bt_add;
	wxButton* bt_del;
	wxButton* bt_edt;
	DECLARE_EVENT_TABLE();
	void onBtAdd(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLISelected(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
};

#endif	/* TGRUPPENPANEL_H */

===== ./src/view-data/FehlzeitenPanel.h =====
/* 
 * File:   FehlzeitenPanel.h
 * Author: Yannik
 *
 * Created on August 23, 2015, 12:59 PM
 */

#ifndef FEHLZEITENPANEL_H
#define	FEHLZEITENPANEL_H

#include <wx/wx.h>
#include <wx/listctrl.h>
class App;

class FehlzeitenPanel : public wxPanel {
public:
	FehlzeitenPanel(wxWindow* parent, App* _app);
	void notifyFehlzeiten(int index = -1);
private:
	App* app;
	wxListView* lv_fehlzeiten;
	wxButton* bt_add;
	wxButton* bt_del;
	wxButton* bt_edt;
	DECLARE_EVENT_TABLE();
	void onBtAdd(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
};

#endif	/* FEHLZEITENPANEL_H */

===== ./src/view-data/FehlzeitDialog.cpp =====
/* 
 * File:   FehlzeitDialog.cpp
 * Author: Yannik
 * 
 * Created on August 23, 2015, 5:08 PM
 */

#include "FehlzeitDialog.h"
#include "../R.h"
#include "../model-data/Messdiener.h"
#include "../model-data/Einzeltermin.h"
#include "../model-data/Serientermin.h"
#include "../App.h"
#include "../Util.h"

FehlzeitDialog::FehlzeitDialog(wxWindow* parent, App* _app)
: wxDialog(parent, R::ID_ANY, R::FEHLZEIT_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = false;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

FehlzeitDialog::FehlzeitDialog(wxWindow* parent, App* _app, int _index)
: wxDialog(parent, R::ID_ANY, R::FEHLZEIT_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = true;
	index = _index;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

void FehlzeitDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	gridsizer = new wxFlexGridSizer(8, 2, 0, 0);

	st_mini = new wxStaticText(this, R::ID_ANY, R::MINI);
	gridsizer->Add(st_mini, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int minis_size = app->list_mini.size();
	wxString minis[minis_size];
	for (int i = 0; i < minis_size; i++) {
		minis[i] = app->list_mini.at(i)->vorname + wxT(" ") + app->list_mini.at(i)->name;
	}
	ch_mini = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, minis_size, minis);
	gridsizer->Add(ch_mini, 1, wxEXPAND | wxALL, 2);

	st_modus = new wxStaticText(this, R::ID_ANY, R::MODUS);
	gridsizer->Add(st_modus, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	ch_modus = new wxChoice(this, R::ID_CH, wxDefaultPosition, wxDefaultSize, 3, R::FEHLZEIT_MODI);
	ch_modus->SetSelection(0);
	gridsizer->Add(ch_modus, 1, wxEXPAND | wxALL, 2);

	st_termin = new wxStaticText(this, R::ID_ANY, R::TERMIN);
	gridsizer->Add(st_termin, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int etermine_size = app->list_einzeltermin.size();
	int stermine_size = app->list_serientermin.size();
	wxString termine[etermine_size + stermine_size];
	for (int i = 0; i < etermine_size; i++) {
		termine[i] = Einzeltermin::printShort(app->list_einzeltermin.at(i));
	}
	for (int i = 0; i < stermine_size; i++) {
		termine[etermine_size + i] = Serientermin::printShort(app->list_serientermin.at(i));
	}
	ch_termin = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, etermine_size + stermine_size, termine);
	gridsizer->Add(ch_termin, 1, wxEXPAND | wxALL, 2);

	st_wochentag = new wxStaticText(this, R::ID_ANY, R::WOCHENTAG);
	gridsizer->Add(st_wochentag, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	ch_wochentag = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, 7, R::WOCHENTAGE);
	ch_wochentag->SetSelection(0);
	gridsizer->Add(ch_wochentag, 1, wxEXPAND | wxALL, 2);

	st_datum_beginn = new wxStaticText(this, R::ID_ANY, R::DATUM_AB);
	gridsizer->Add(st_datum_beginn, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_datum_beginn = new wxBoxSizer(wxHORIZONTAL);
	dc_beginn = new wxDatePickerCtrl(this, R::ID_LC, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, wxDP_DEFAULT | wxDP_SHOWCENTURY);
	sizer_datum_beginn->Add(dc_beginn, 1, wxEXPAND | wxALL, 2);
	st_beginn_wday = new wxStaticText(this, R::ID_ANY, wxT("(") + R::WOCHENTAGE[dc_beginn->GetValue().GetWeekDay()] + wxT(")"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT | wxST_NO_AUTORESIZE);
	sizer_datum_beginn->Add(st_beginn_wday, 1, wxALL | wxALIGN_CENTER_VERTICAL | wxALIGN_RIGHT, 2);
	gridsizer->Add(sizer_datum_beginn, 1, wxEXPAND | wxALL, 2);

	st_datum_ende = new wxStaticText(this, R::ID_ANY, R::DATUM_BIS);
	gridsizer->Add(st_datum_ende, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_datum_ende = new wxBoxSizer(wxHORIZONTAL);
	dc_ende = new wxDatePickerCtrl(this, R::ID_LC2, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, wxDP_DEFAULT | wxDP_SHOWCENTURY);
	sizer_datum_ende->Add(dc_ende, 1, wxEXPAND | wxALL, 2);
	st_ende_wday = new wxStaticText(this, R::ID_ANY, wxT("(") + R::WOCHENTAGE[dc_ende->GetValue().GetWeekDay()] + wxT(")"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT | wxST_NO_AUTORESIZE);
	sizer_datum_ende->Add(st_ende_wday, 1, wxALL | wxALIGN_CENTER_VERTICAL | wxALIGN_RIGHT, 2);
	gridsizer->Add(sizer_datum_ende, 1, wxEXPAND | wxALL, 2);

	st_zeit_beginn = new wxStaticText(this, R::ID_ANY, R::VON);
	gridsizer->Add(st_zeit_beginn, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_beginn = new wxTextCtrl(this, R::ID_ANY, wxT("00:00"));
	tc_beginn->SetHint(wxT("hh:mm"));
	gridsizer->Add(tc_beginn, 1, wxEXPAND | wxALL, 2);

	st_zeit_ende = new wxStaticText(this, R::ID_ANY, R::BIS);
	gridsizer->Add(st_zeit_ende, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_ende = new wxTextCtrl(this, R::ID_ANY, wxT("23:59"));
	tc_ende->SetHint(wxT("hh:mm"));
	gridsizer->Add(tc_ende, 1, wxEXPAND | wxALL, 2);

	gridsizer->AddGrowableCol(1, 1);
	sizer->Add(gridsizer, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	setModusWochentag();
	SetSizerAndFit(sizer);
	if (GetSize().GetWidth() < 410) {
		SetSize(410, -1);
	}
	if (edt) {
		Fehlzeit f = *(app->list_fehlzeit.at(index));
		ch_mini->SetSelection(f.mini->_id);
		switch (f.modus) {
			case Fehlzeit::ZEITRAUM:
				dc_beginn->SetValue(Util::wxString_to_wxDateTime(f.beginn));
				st_beginn_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_beginn->GetValue().GetWeekDay()] + wxT(")"));
				dc_ende->SetValue(Util::wxString_to_wxDateTime(f.ende));
				st_ende_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_ende->GetValue().GetWeekDay()] + wxT(")"));
				ch_modus->SetSelection(Fehlzeit::ZEITRAUM);
				setModusZeitraum();
				break;
			case Fehlzeit::WOCHENTAG:
				ch_wochentag->SetSelection(f.wochentag);
				tc_beginn->SetValue(f.beginn);
				tc_ende->SetValue(f.ende);
				ch_modus->SetSelection(Fehlzeit::WOCHENTAG);
				setModusWochentag();
				break;
			case Fehlzeit::EINZELTERMIN:
				ch_termin->SetSelection(f.einzeltermin->_id);
				ch_modus->SetSelection(2);
				setModusTermin();
				break;
			default:
				ch_termin->SetSelection(app->list_einzeltermin.size() + f.serientermin->_id);
				ch_modus->SetSelection(2);
				setModusTermin();
		}
	} else {
		setModusZeitraum();
	}
}

void FehlzeitDialog::setModusZeitraum() {
	st_termin->Hide();
	ch_termin->Hide();
	st_wochentag->Hide();
	ch_wochentag->Hide();
	st_datum_beginn->Show();
	dc_beginn->Show();
	st_beginn_wday->Show();
	st_datum_ende->Show();
	dc_ende->Show();
	st_ende_wday->Show();
	st_zeit_beginn->Hide();
	tc_beginn->Hide();
	st_zeit_ende->Hide();
	tc_ende->Hide();
	gridsizer->Layout();
}

void FehlzeitDialog::setModusWochentag() {
	st_termin->Hide();
	ch_termin->Hide();
	st_wochentag->Show();
	ch_wochentag->Show();
	st_datum_beginn->Hide();
	dc_beginn->Hide();
	st_beginn_wday->Hide();
	st_datum_ende->Hide();
	dc_ende->Hide();
	st_ende_wday->Hide();
	st_zeit_beginn->Show();
	tc_beginn->Show();
	st_zeit_ende->Show();
	tc_ende->Show();
	gridsizer->Layout();
}

void FehlzeitDialog::setModusTermin() {
	st_termin->Show();
	ch_termin->Show();
	st_wochentag->Hide();
	ch_wochentag->Hide();
	st_datum_beginn->Hide();
	dc_beginn->Hide();
	st_beginn_wday->Hide();
	st_datum_ende->Hide();
	dc_ende->Hide();
	st_ende_wday->Hide();
	st_zeit_beginn->Hide();
	tc_beginn->Hide();
	st_zeit_ende->Hide();
	tc_ende->Hide();
	gridsizer->Layout();
}

BEGIN_EVENT_TABLE(FehlzeitDialog, wxDialog)
EVT_CHOICE(R::ID_CH, FehlzeitDialog::onChModus)
EVT_BUTTON(R::ID_BT_OK, FehlzeitDialog::onBtOk)
EVT_BUTTON(R::ID_BT_CANCEL, FehlzeitDialog::onBtCancel)
EVT_DATE_CHANGED(R::ID_LC, FehlzeitDialog::onDateBeginnChanged)
EVT_DATE_CHANGED(R::ID_LC2, FehlzeitDialog::onDateEndeChanged)
END_EVENT_TABLE()

void FehlzeitDialog::onChModus(wxCommandEvent&) {
	switch (ch_modus->GetSelection()) {
		case Fehlzeit::ZEITRAUM:
			setModusZeitraum();
			break;
		case Fehlzeit::WOCHENTAG:
			setModusWochentag();
			break;
		default:
			setModusTermin();
	}
}

void FehlzeitDialog::onBtOk(wxCommandEvent&) {
	int mini_i = ch_mini->GetSelection();
	if (mini_i == wxNOT_FOUND) {
		wxMessageDialog dialog(this, R::MSG_MINI_SEL_ERR);
		dialog.ShowModal();
		return;
	}
	Fehlzeit* f;
	switch (ch_modus->GetSelection()) {
		case Fehlzeit::ZEITRAUM:
		{
			wxDateTime beginn = dc_beginn->GetValue();
			wxDateTime ende = dc_ende->GetValue();
			if (ende.IsEarlierThan(beginn)) {
				wxMessageDialog dialog(this, R::MSG_DATUM_ORDER);
				dialog.ShowModal();
				return;
			}
			f = new Fehlzeit(app->list_mini.at(mini_i), Util::wxDateTime_to_wxString(dc_beginn->GetValue()), Util::wxDateTime_to_wxString(dc_ende->GetValue()));
			break;
		}
		case Fehlzeit::WOCHENTAG:
		{
			wxString zeit_beginn;
			if (!Util::formatTime(tc_beginn->GetValue(), &zeit_beginn)) {
				wxMessageDialog dialog(this, R::MSG_TIME_BEGINN_ERR);
				dialog.ShowModal();
				return;
			}
			wxString zeit_ende;
			if (!Util::formatTime(tc_ende->GetValue(), &zeit_ende)) {
				wxMessageDialog dialog(this, R::MSG_TIME_ENDE_ERR);
				dialog.ShowModal();
				return;
			}
			f = new Fehlzeit(app->list_mini.at(mini_i), ch_wochentag->GetSelection(), zeit_beginn, zeit_ende);
			break;
		}
		default:
		{
			int termin_i = ch_termin->GetSelection();
			if (termin_i == wxNOT_FOUND) {
				wxMessageDialog dialog(this, R::MSG_TERMIN_SEL_ERR);
				dialog.ShowModal();
				return;
			}
			int einzel_i = app->list_einzeltermin.size();
			if (termin_i < einzel_i) {
				f = new Fehlzeit(app->list_mini.at(mini_i), app->list_einzeltermin.at(termin_i));
			} else {
				f = new Fehlzeit(app->list_mini.at(mini_i), app->list_serientermin.at(termin_i - einzel_i));
			}
		}
	}
	if (edt) {
		if (!app->edtFehlzeit(index, f)) {
			delete f;
			wxMessageDialog dialog(this, R::MSG_FEHLZEIT_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			delete f;
			Close(true);
		}
	} else {
		if (!app->addFehlzeit(f)) {
			delete f;
			wxMessageDialog dialog(this, R::MSG_FEHLZEIT_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			Close(true);
		}
	}
}

void FehlzeitDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

void FehlzeitDialog::onDateBeginnChanged(wxDateEvent&) {
	st_beginn_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_beginn->GetValue().GetWeekDay()] + wxT(")"));
}

void FehlzeitDialog::onDateEndeChanged(wxDateEvent&) {
	st_ende_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_ende->GetValue().GetWeekDay()] + wxT(")"));
}

===== ./src/view-data/MiniDialog.cpp =====
/* 
 * File:   MiniDialog.cpp
 * Author: Yannik
 * 
 * Created on August 11, 2015, 7:36 PM
 */

#include "MiniDialog.h"
#include "../App.h"
#include "../R.h"
#include "../Util.h"

MiniDialog::MiniDialog(wxWindow* parent, App* _app)
: wxDialog(parent, R::ID_ANY, R::MINI_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = false;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

MiniDialog::MiniDialog(wxWindow* parent, App* _app, int _index)
: wxDialog(parent, R::ID_ANY, R::MINI_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = true;
	index = _index;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

void MiniDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxFlexGridSizer* gridsizer = new wxFlexGridSizer(R::MINI_ATTS_NUM, 2, 0, 0);

	st_name = new wxStaticText(this, R::ID_ANY, R::NACHNAME, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_name, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_name = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(tc_name, 1, wxEXPAND | wxALL, 2);

	st_vorname = new wxStaticText(this, R::ID_ANY, R::VORNAME, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_vorname, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_vorname = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(tc_vorname, 1, wxEXPAND | wxALL, 2);

	st_dienste = new wxStaticText(this, R::ID_ANY, R::DIENSTE, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_dienste, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int num_dienste = app->list_dienst.size();
	wxString dienste[num_dienste];
	for (int i = 0; i < num_dienste; i++) {
		dienste[i] = app->list_dienst.at(i)->name;
	}
	lb_dienste = new wxCheckListBox(this, R::ID_LC, wxDefaultPosition, wxDefaultSize, num_dienste, dienste, wxLB_SINGLE);
	gridsizer->Add(lb_dienste, 1, wxEXPAND | wxALL, 2);

	st_geburtstag = new wxStaticText(this, R::ID_ANY, R::GEBURTSTAG, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_geburtstag, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* gtagsizer = new wxBoxSizer(wxHORIZONTAL);
	cb_geburtstag = new wxCheckBox(this, R::ID_BT_ADD, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	cb_geburtstag->SetValue(false);
	gtagsizer->Add(cb_geburtstag, 0, wxALL | wxALIGN_CENTER, 0);
	dc_geburtstag = new wxDatePickerCtrl(this, R::ID_ANY, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, wxDP_DEFAULT | wxDP_SHOWCENTURY);
	dc_geburtstag->Enable(false);
	gtagsizer->Add(dc_geburtstag, 1, wxEXPAND | wxALL, 0);
	gridsizer->Add(gtagsizer, 1, wxEXPAND | wxALL, 2);

	st_strasse_nr = new wxStaticText(this, R::ID_ANY, R::STRASSE_NR, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_strasse_nr, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_strasse_nr = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(tc_strasse_nr, 1, wxEXPAND | wxALL, 2);

	st_plz_ort = new wxStaticText(this, R::ID_ANY, R::PLZ_ORT, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_plz_ort, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int num_plzorte = app->list_plzort.size();
	wxString arr_plzorte[num_plzorte];
	for (int i = 0; i < num_plzorte; i++) {
		arr_plzorte[i] = app->list_plzort.at(i);
	}
	tc_plz_ort = new wxComboBox(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, num_plzorte, arr_plzorte);
	gridsizer->Add(tc_plz_ort, 1, wxEXPAND | wxALL, 2);

	st_tel = new wxStaticText(this, R::ID_ANY, R::TEL, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_tel, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_tel = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(tc_tel, 1, wxEXPAND | wxALL, 2);

	st_mobil = new wxStaticText(this, R::ID_ANY, R::MOBILE, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_mobil, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_mobil = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(tc_mobil, 1, wxEXPAND | wxALL, 2);

	st_email = new wxStaticText(this, R::ID_ANY, R::EMAIL, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_email, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_email = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(tc_email, 1, wxEXPAND | wxALL, 2);

	st_bem = new wxStaticText(this, R::ID_ANY, R::BEM, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(st_bem, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_bem = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	gridsizer->Add(tc_bem, 1, wxEXPAND | wxALL, 2);

	gridsizer->AddGrowableCol(1, 1);
	gridsizer->AddGrowableRow(2, 1);
	sizer->Add(gridsizer, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	if (edt) {
		Messdiener* m = app->list_mini.at(index);
		tc_name->SetValue(m->name);
		tc_vorname->SetValue(m->vorname);
		int mnum_dienste = m->dienste.size();
		for (int i = 0; i < num_dienste; i++) {
			for (int j = 0; j < mnum_dienste; j++) {
				if (app->list_dienst.at(i) == m->dienste.at(j)) {
					lb_dienste->Check(i, true);
				}
			}
		}
		if (m->geburtstag != wxT("")) {
			dc_geburtstag->SetValue(Util::wxString_to_wxDateTime(m->geburtstag));
			cb_geburtstag->SetValue(true);
			dc_geburtstag->Enable(true);
		}
		tc_strasse_nr->SetValue(m->strasse_nr);
		tc_plz_ort->SetValue(m->plz_ort);
		tc_tel->SetValue(m->tel);
		tc_mobil->SetValue(m->mobile);
		tc_email->SetValue(m->email);
		tc_bem->SetValue(m->bem);
	} else {
		for (int i = 0; i < num_dienste; i++) {
			lb_dienste->Check(i, true);
		}
	}

	SetSizerAndFit(sizer);
	if (GetSize().GetWidth() < 260) {
		SetSize(260, -1);
	}
}

BEGIN_EVENT_TABLE(MiniDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, MiniDialog::onBtOK)
EVT_BUTTON(R::ID_BT_CANCEL, MiniDialog::onBtCancel)
EVT_CHECKBOX(R::ID_BT_ADD, MiniDialog::onCbGeburtstag)
END_EVENT_TABLE()

void MiniDialog::onBtOK(wxCommandEvent& event) {
	wxString date = cb_geburtstag->IsChecked() ? Util::wxDateTime_to_wxString(dc_geburtstag->GetValue()) : wxT("");
	std::vector<Dienst*> dienste;
	for (int i = 0; i < (int) app->list_dienst.size(); i++) {
		if (lb_dienste->IsChecked(i)) {
			dienste.push_back(app->list_dienst.at(i));
		}
	}
	Messdiener* m = new Messdiener(Util::rmD(tc_name->GetValue()), Util::rmD(tc_vorname->GetValue()), dienste, date,
			Util::rmD(tc_strasse_nr->GetValue()), Util::rmD(tc_plz_ort->GetValue()), Util::rmD(tc_tel->GetValue()),
			Util::rmD(tc_mobil->GetValue()), Util::rmD(tc_email->GetValue()), Util::rmD(tc_bem->GetValue()));
	if (edt) {
		if (!app->edtMini(index, m)) {
			delete m;
			wxMessageDialog dialog(this, R::MSG_MINI_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			delete m;
			Close(true);
		}
	} else {
		if (!app->addMini(m)) {
			delete m;
			wxMessageDialog dialog(this, R::MSG_MINI_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			Close(true);
		}
	}
}

void MiniDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

void MiniDialog::onCbGeburtstag(wxCommandEvent&) {
	dc_geburtstag->Enable(!dc_geburtstag->IsEnabled());
}

===== ./src/view-data/TerminePanel.cpp =====
/* 
 * File:   TerminePanel.cpp
 * Author: Yannik
 * 
 * Created on August 12, 2015, 5:37 PM
 */

#include "TerminePanel.h"
#include <wx/splitter.h>
#include "../App.h"
#include "../Util.h"
#include "EinzelterminDialog.h"
#include "SerienterminDialog.h"
#include "../import/EinzelterminImportDialog.h"
#include "DeleteDialog.h"

TerminePanel::TerminePanel(wxWindow* parent, App* _app)
: wxPanel(parent, R::ID_ANY) {
	app = _app;

	wxSplitterWindow* splitterWindow = new wxSplitterWindow(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_3D | wxSP_LIVE_UPDATE);
	splitterWindow->SetSashGravity(0.5);
	splitterWindow->SetMinimumPaneSize(20);
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxPanel* pl_1 = new wxPanel(splitterWindow, R::ID_ANY);
	wxBoxSizer* sizer_1 = new wxBoxSizer(wxVERTICAL);
	st_einzel = new wxStaticText(pl_1, R::ID_ANY, R::EINZELTERMINE);
	sizer_1->Add(st_einzel, 0, wxTOP, 5);
	wxBoxSizer* sizer_einzel = new wxBoxSizer(wxHORIZONTAL);
	lc_einzel = new wxListView(pl_1, R::ID_LC, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	lc_einzel_cols[0].SetId(0);
	lc_einzel_cols[0].SetText(wxT(""));
	lc_einzel->InsertColumn(0, lc_einzel_cols[0]);
	for (int i = 1; i < R::TEINZEL_NUM + 1; i++) {
		lc_einzel_cols[i].SetId(i);
		lc_einzel_cols[i].SetText(R::TEINZEL_ATTS[i - 1]);
		lc_einzel->InsertColumn(i, lc_einzel_cols[i]);
	}
	sizer_einzel->Add(lc_einzel, 1, wxEXPAND, 0);
	notifyEinzeltermine();
	wxBoxSizer* sizer_einzel_r = new wxBoxSizer(wxVERTICAL);
	bt_einzel_add = new wxButton(pl_1, R::ID_BT_ADD, R::ADD);
	sizer_einzel_r->Add(bt_einzel_add, 0, 0, 0);
	bt_einzel_edt = new wxButton(pl_1, R::ID_BT_EDT, R::EDT);
	sizer_einzel_r->Add(bt_einzel_edt, 0, 0, 0);
	bt_einzel_del = new wxButton(pl_1, R::ID_BT_DEL, R::DEL);
	sizer_einzel_r->Add(bt_einzel_del, 0, 0, 0);
	sizer_einzel_r->Add(new wxPanel(this, R::ID_ANY), 1, wxEXPAND, 0);
	bt_einzel_import = new wxButton(pl_1, R::ID_IMPORT, R::IMPORT);
	sizer_einzel_r->Add(bt_einzel_import, 0, 0, 0);
	sizer_einzel->Add(sizer_einzel_r, 0, wxEXPAND, 0);
	sizer_1->Add(sizer_einzel, 1, wxEXPAND, 0);
	pl_1->SetSizer(sizer_1);

	wxPanel* pl_2 = new wxPanel(splitterWindow, R::ID_ANY);
	wxBoxSizer* sizer_2 = new wxBoxSizer(wxVERTICAL);
	st_serie = new wxStaticText(pl_2, R::ID_ANY, R::SERIENTERMINE);
	sizer_2->Add(st_serie, 0, 0, 0);
	wxBoxSizer* sizer_serie = new wxBoxSizer(wxHORIZONTAL);
	lc_serie = new wxListView(pl_2, R::ID_LC2, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	lc_serie_cols[0].SetId(0);
	lc_serie_cols[0].SetText(wxT(""));
	lc_serie->InsertColumn(0, lc_serie_cols[0]);
	for (int i = 1; i < R::TSERIE_NUM + 1; i++) {
		lc_serie_cols[i].SetId(i);
		lc_serie_cols[i].SetText(R::TSERIE_ATTS[i - 1]);
		lc_serie->InsertColumn(i, lc_serie_cols[i]);
	}
	sizer_serie->Add(lc_serie, 1, wxEXPAND, 0);
	notifySerientermine();
	wxBoxSizer* sizer_serie_r = new wxBoxSizer(wxVERTICAL);
	bt_serie_add = new wxButton(pl_2, R::ID_BT_ADD2, R::ADD);
	sizer_serie_r->Add(bt_serie_add, 0, 0, 0);
	bt_serie_edt = new wxButton(pl_2, R::ID_BT_EDT2, R::EDT);
	sizer_serie_r->Add(bt_serie_edt, 0, 0, 0);
	bt_serie_del = new wxButton(pl_2, R::ID_BT_DEL2, R::DEL);
	sizer_serie_r->Add(bt_serie_del, 0, 0, 0);
	sizer_serie->Add(sizer_serie_r, 0, wxEXPAND, 0);
	sizer_2->Add(sizer_serie, 1, wxEXPAND, 0);
	pl_2->SetSizer(sizer_2);

	splitterWindow->SplitHorizontally(pl_1, pl_2);
	sizer->Add(splitterWindow, 1, wxEXPAND, 0);
	SetSizer(sizer);
}

void TerminePanel::notifyEinzeltermine(int index) {
	lc_einzel->DeleteAllItems();
	const int num = app->list_einzeltermin.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		Einzeltermin t = *(app->list_einzeltermin.at(num - 1 - i));
		lc_einzel->InsertItem(item);
		lc_einzel->SetItem(i, 0, wxString::Format(wxT("%i"), num - i));
		lc_einzel->SetItem(i, 1, t.name);
		lc_einzel->SetItem(i, 2, t.ort);
		lc_einzel->SetItem(i, 3, t.datum + wxT(" (") + R::WOCHENTAGE[Util::wxString_to_wxDateTime(t.datum).GetWeekDay()] + wxT(")"));
		lc_einzel->SetItem(i, 4, t.zeit_beginn);
		lc_einzel->SetItem(i, 5, Einzeltermin::printDienste(&t));
		lc_einzel->SetItem(i, 6, t.bem);
	}
	if (index != -1) lc_einzel->Select(num - 1 - index, true);
	for (int i = 0; i < R::TEINZEL_NUM + 1; i++) {
		lc_einzel->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

void TerminePanel::notifySerientermine(int index) {
	lc_serie->DeleteAllItems();
	const int num = app->list_serientermin.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		Serientermin t = *(app->list_serientermin.at(i));
		lc_serie->InsertItem(item);
		lc_serie->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lc_serie->SetItem(i, 1, t.name);
		lc_serie->SetItem(i, 2, t.ort);
		lc_serie->SetItem(i, 3, Serientermin::printModus(&t));
		lc_serie->SetItem(i, 4, t.zeit_beginn);
		lc_serie->SetItem(i, 5, Serientermin::printDienste(&t));
		lc_serie->SetItem(i, 6, t.datum_beginn);
		lc_serie->SetItem(i, 7, t.datum_ende);
		lc_serie->SetItem(i, 8, t.bem);
	}
	if (index != -1) lc_serie->Select(index, true);
	for (int i = 0; i < R::TSERIE_NUM + 1; i++) {
		lc_serie->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

BEGIN_EVENT_TABLE(TerminePanel, wxPanel)
EVT_BUTTON(R::ID_BT_ADD, TerminePanel::onBtEinAdd)
EVT_BUTTON(R::ID_BT_DEL, TerminePanel::onBtEinDel)
EVT_BUTTON(R::ID_BT_EDT, TerminePanel::onBtEinEdt)
EVT_BUTTON(R::ID_IMPORT, TerminePanel::onBtEinImport)
EVT_BUTTON(R::ID_BT_ADD2, TerminePanel::onBtSerAdd)
EVT_BUTTON(R::ID_BT_DEL2, TerminePanel::onBtSerDel)
EVT_BUTTON(R::ID_BT_EDT2, TerminePanel::onBtSerEdt)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, TerminePanel::onLIEinActivated)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC2, TerminePanel::onLISerActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, TerminePanel::onLIEinKey)
EVT_LIST_KEY_DOWN(R::ID_LC2, TerminePanel::onLISerKey)
END_EVENT_TABLE()

void TerminePanel::onBtEinAdd(wxCommandEvent&) {
	EinzelterminDialog* dialog = new EinzelterminDialog(this, app);
	dialog->ShowModal();
	delete dialog;
}

void TerminePanel::onBtEinDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_einzel->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) app->delEinzeltermin(app->list_einzeltermin.size() - 1 - i);
		break;
	}
}

void TerminePanel::onBtEinEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_einzel->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		EinzelterminDialog *dialog = new EinzelterminDialog(this, app, app->list_einzeltermin.size() - 1 - i);
		dialog->ShowModal();
		delete dialog;
		break;
	}
}

void TerminePanel::onBtEinImport(wxCommandEvent&) {
	bool edt = false;
	std::vector<Einzeltermin*> list_einzel;
	EinzelterminImportDialog dialog(this, &list_einzel, &edt, &app->list_dienst);
	dialog.ShowModal();
	if (edt) app->importEinzeltermine(list_einzel);
}

void TerminePanel::onBtSerAdd(wxCommandEvent&) {
	SerienterminDialog* dialog = new SerienterminDialog(this, app);
	dialog->ShowModal();
	delete dialog;
}

void TerminePanel::onBtSerDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_serie->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) app->delSerientermin(i);
		break;
	}
}

void TerminePanel::onBtSerEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lc_serie->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		SerienterminDialog* dialog = new SerienterminDialog(this, app, i);
		dialog->ShowModal();
		delete dialog;
		break;
	}
}

void TerminePanel::onLIEinActivated(wxListEvent& evt) {
	EinzelterminDialog* dialog = new EinzelterminDialog(this, app, app->list_einzeltermin.size() - 1 - evt.GetItem().GetId());
	dialog->ShowModal();
	delete dialog;
}

void TerminePanel::onLISerActivated(wxListEvent& evt) {
	SerienterminDialog* dialog = new SerienterminDialog(this, app, evt.GetItem().GetId());
	dialog->ShowModal();
	delete dialog;
}

void TerminePanel::onLIEinKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lc_einzel->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) app->delEinzeltermin(app->list_einzeltermin.size() - 1 - i);
			break;
		}
	}
}

void TerminePanel::onLISerKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lc_serie->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) app->delSerientermin(i);
			break;
		}
	}
}

===== ./src/view-data/TGruppeDialog.cpp =====
/* 
 * File:   TGruppeDialog.cpp
 * Author: Yannik
 * 
 * Created on August 16, 2015, 1:48 PM
 */

#include "TGruppeDialog.h"
#include <algorithm>
#include "../R.h"
#include "../App.h"
#include "../Util.h"
#include "../model-data/TGruppe.h"

TGruppeDialog::TGruppeDialog(wxWindow* parent, App* _app)
: wxDialog(parent, R::ID_ANY, R::TGRUPPE_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = false;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

TGruppeDialog::TGruppeDialog(wxWindow* parent, App* _app, int _index)
: wxDialog(parent, R::ID_ANY, R::TGRUPPE_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = true;
	index = _index;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

void TGruppeDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxBoxSizer* sizer_w = new wxBoxSizer(wxHORIZONTAL);
	st_wochentag = new wxStaticText(this, R::ID_ANY, R::PERIODISCH);
	sizer_w->Add(st_wochentag, 0, wxRIGHT | wxALIGN_CENTER_VERTICAL, 2);
	ch_wochentag = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, 7, R::WOCHENTAGE);
	ch_wochentag->SetSelection(0);
	sizer_w->Add(ch_wochentag, 0, wxEXPAND | wxLEFT, 2);
	sizer->Add(sizer_w, 0, wxEXPAND | wxALL, 5);

	wxBoxSizer* sizer_t = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer* sizer_tgruppe = new wxBoxSizer(wxVERTICAL);
	st_tgruppe = new wxStaticText(this, R::ID_ANY, R::TGRUPPE);
	sizer_tgruppe->Add(st_tgruppe, 0, 0, 0);
	lv_tgruppe = new wxListView(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_NO_HEADER);
	wxListItem col_tgruppe;
	lv_tgruppe->InsertColumn(0, col_tgruppe);
	sizer_tgruppe->Add(lv_tgruppe, 1, wxEXPAND, 0);
	sizer_t->Add(sizer_tgruppe, 1, wxEXPAND, 0);

	wxBoxSizer* inout_sizer = new wxBoxSizer(wxVERTICAL);
	bt_togroup = new wxButton(this, R::ID_BT_ADD, wxT("\x2190"));
	inout_sizer->Add(bt_togroup, 1, wxALL, 5);
	bt_torest = new wxButton(this, R::ID_BT_DEL, wxT("\x2192"));
	inout_sizer->Add(bt_torest, 1, wxALL, 5);
	sizer_t->Add(inout_sizer, 0, wxALIGN_CENTER_VERTICAL, 0);

	wxBoxSizer* sizer_rest = new wxBoxSizer(wxVERTICAL);
	st_rest = new wxStaticText(this, R::ID_ANY, R::RESTTERMINE);
	sizer_rest->Add(st_rest, 0, 0, 0);
	lv_rest = new wxListView(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL | wxLC_NO_HEADER);
	wxListItem col_rest;
	lv_rest->InsertColumn(0, col_rest);
	sizer_rest->Add(lv_rest, 1, wxEXPAND, 0);
	sizer_t->Add(sizer_rest, 1, wxEXPAND, 0);

	sizer->Add(sizer_t, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);
	//delete items from rest lists
	list_einzel_rest = app->list_einzeltermin;
	list_serie_rest = app->list_serientermin;
	std::vector<Einzeltermin*>::iterator iter = list_einzel_rest.begin();
	while (iter != list_einzel_rest.end()) {
		bool inSomeGroup = false;
		for (std::vector<TGruppe*>::iterator iter_tg = app->list_tgruppe.begin(); iter_tg != app->list_tgruppe.end() && !inSomeGroup; iter_tg++) {
			for (std::vector<Einzeltermin*>::iterator iter_t = (**iter_tg).list_einzel.begin(); iter_t != (**iter_tg).list_einzel.end(); iter_t++) {
				if (*iter == *iter_t) {
					inSomeGroup = true;
					break;
				}
			}
		}

		if (inSomeGroup) {
			iter = list_einzel_rest.erase(iter);
		} else {
			iter++;
		}
	}
	std::vector<Serientermin*>::iterator iter2 = list_serie_rest.begin();
	while (iter2 != list_serie_rest.end()) {
		bool inSomeGroup = false;
		for (std::vector<TGruppe*>::iterator iter_tg = app->list_tgruppe.begin(); iter_tg != app->list_tgruppe.end() && !inSomeGroup; iter_tg++) {
			for (std::vector<Serientermin*>::iterator iter_t = (**iter_tg).list_serie.begin(); iter_t != (**iter_tg).list_serie.end(); iter_t++) {
				if (*iter2 == *iter_t) {
					inSomeGroup = true;
					break;
				}
			}
		}
		if (inSomeGroup) {
			iter2 = list_serie_rest.erase(iter2);
		} else {
			iter2++;
		}
	}
	if (edt) {
		TGruppe tgruppe = *(app->list_tgruppe.at(index));
		list_einzel_tgruppe = tgruppe.list_einzel;
		list_serie_tgruppe = tgruppe.list_serie;
		if (tgruppe.list_serie.size() > 0) {
			ch_wochentag->SetSelection(tgruppe.wochentag);
			setModePeriodic();
		} else {
			setModeNonPeriodic();
		}
	} else {
		setModeNonPeriodic();
	}
	drawGruppe();
	drawRest();
	lv_tgruppe->Fit();
	lv_rest->Fit();
	SetSizerAndFit(sizer);
	if (GetSize().GetHeight() < 300) {
		SetSize(-1, 300);
	}
}

void TGruppeDialog::setModePeriodic() {
	st_wochentag->Show();
	ch_wochentag->Show();
	Layout();
}

void TGruppeDialog::setModeNonPeriodic() {
	st_wochentag->Hide();
	ch_wochentag->Hide();
	Layout();
}

void TGruppeDialog::drawGruppe() {
	lv_tgruppe->DeleteAllItems();
	int num = list_einzel_tgruppe.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		lv_tgruppe->InsertItem(item);
		lv_tgruppe->SetItem(i, 0, Einzeltermin::printShort(list_einzel_tgruppe.at(i)));
	}
	for (int i = 0; i < (int) list_serie_tgruppe.size(); i++) {
		wxListItem item;
		item.SetId(num + i);
		lv_tgruppe->InsertItem(item);
		lv_tgruppe->SetItem(num + i, 0, Serientermin::printShort(list_serie_tgruppe.at(i)));
	}
	lv_tgruppe->SetColumnWidth(0, wxLIST_AUTOSIZE);
}

void TGruppeDialog::drawRest() {
	lv_rest->DeleteAllItems();
	int num = list_einzel_rest.size();
	for (int i = 0; i < num; i++) {
		wxListItem item;
		item.SetId(i);
		lv_rest->InsertItem(item);
		lv_rest->SetItem(i, 0, Einzeltermin::printShort(list_einzel_rest.at(i)));
	}
	for (int i = 0; i < (int) list_serie_rest.size(); i++) {
		wxListItem item;
		item.SetId(num + i);
		Serientermin t = *(list_serie_rest.at(i));
		lv_rest->InsertItem(item);
		lv_rest->SetItem(num + i, 0, Serientermin::printShort(list_serie_rest.at(i)));
	}
	lv_rest->SetColumnWidth(0, wxLIST_AUTOSIZE);
}

BEGIN_EVENT_TABLE(TGruppeDialog, wxDialog)
EVT_BUTTON(R::ID_BT_ADD, TGruppeDialog::onBtToGruppe)
EVT_BUTTON(R::ID_BT_DEL, TGruppeDialog::onBtToRest)
EVT_BUTTON(R::ID_BT_OK, TGruppeDialog::onBtOk)
EVT_BUTTON(R::ID_BT_CANCEL, TGruppeDialog::onBtCancel)
END_EVENT_TABLE()


void TGruppeDialog::onBtToGruppe(wxCommandEvent&) {
	int i = -1;
	int num = list_einzel_rest.size();
	for (;;) {
		i = lv_rest->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		if (i >= num) {
			list_serie_tgruppe.push_back(list_serie_rest.at(i - num));
			std::sort(list_serie_tgruppe.begin(), list_serie_tgruppe.end(), Serientermin::cmp);
			list_serie_rest.erase(list_serie_rest.begin() + i - num);
		} else {
			list_einzel_tgruppe.push_back(list_einzel_rest.at(i));
			std::sort(list_einzel_tgruppe.begin(), list_einzel_tgruppe.end(), Einzeltermin::cmp);
			list_einzel_rest.erase(list_einzel_rest.begin() + i);
		}
		break;
	}
	drawRest();
	drawGruppe();
	if (list_serie_tgruppe.size() > 0) {
		setModePeriodic();
	} else {
		setModeNonPeriodic();
	}
}

void TGruppeDialog::onBtToRest(wxCommandEvent&) {
	int i = -1;
	int num = list_einzel_tgruppe.size();
	for (;;) {
		i = lv_tgruppe->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		if (i >= num) {
			list_serie_rest.push_back(list_serie_tgruppe.at(i - num));
			std::sort(list_serie_rest.begin(), list_serie_rest.end(), Serientermin::cmp);
			list_serie_tgruppe.erase(list_serie_tgruppe.begin() + i - num);
		} else {
			list_einzel_rest.push_back(list_einzel_tgruppe.at(i));
			std::sort(list_einzel_rest.begin(), list_einzel_rest.end(), Einzeltermin::cmp);
			list_einzel_tgruppe.erase(list_einzel_tgruppe.begin() + i);
		}
		break;
	}
	drawGruppe();
	drawRest();
	if (list_serie_tgruppe.size() > 0) {
		setModePeriodic();
	} else {
		setModeNonPeriodic();
	}
}

void TGruppeDialog::onBtOk(wxCommandEvent&) {
	if (list_einzel_tgruppe.size() + list_serie_tgruppe.size() > 1) {
		TGruppe* tg;
		if (list_serie_tgruppe.size() > 0) {
			tg = new TGruppe(ch_wochentag->GetSelection(), list_einzel_tgruppe, list_serie_tgruppe);
		} else {
			tg = new TGruppe(0, list_einzel_tgruppe, list_serie_tgruppe);
		}
		if (edt) {
			app->edtTGruppe(index, tg);
			delete tg;
		} else {
			app->addTGruppe(tg);
		}
		Close(true);
	} else {
		wxMessageDialog dialog(this, R::MSG_TGROUP_NUM);
		dialog.ShowModal();
	}
}

void TGruppeDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

===== ./src/view-data/MinisPanel.h =====
/* 
 * File:   MinisPanel.h
 * Author: Yannik
 *
 * Created on August 11, 2015, 5:37 PM
 */

#ifndef MINISPANEL_H
#define	MINISPANEL_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include "../R.h"
#include "../model-data/Messdiener.h"
#include <vector>
class App;

class MinisPanel : public wxPanel {
public:
	MinisPanel(wxWindow* parent, App* _app);
	void notifyMinis(int index = -1);
private:
	App* app;
	
	std::vector<Messdiener*> shownMinis;
	void sortByString(bool inc, wxString Messdiener::* var);
	
	wxBoxSizer* sizer;
	wxBoxSizer* sizer_r;
	wxListView* lc_minis;
	wxButton* bt_add;
	wxButton* bt_del;
	wxButton* bt_edt;
	wxButton* bt_import;
	wxButton* bt_export;
	wxButton* bt_extras;
	
	DECLARE_EVENT_TABLE();
	void drawMinis(int index = -1);
	void onBtAdd(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
	//void onColClick(wxListEvent& evt);
	void onBtExport(wxCommandEvent&);
	void onBtImport(wxCommandEvent&);
	void onBtExtras(wxCommandEvent&);
};

#endif	/* MINISPANEL_H */



===== ./src/view-data/TGruppenPanel.cpp =====
/* 
 * File:   TGruppePanel.cpp
 * Author: Yannik
 * 
 * Created on August 16, 2015, 10:30 AM
 */

#include "TGruppenPanel.h"
#include "../App.h"
#include "../model-data/TGruppe.h"
#include "TGruppeDialog.h"
#include "../Util.h"
#include "DeleteDialog.h"

TGruppenPanel::TGruppenPanel(wxWindow* parent, App* _app)
: wxPanel(parent, R::ID_ANY) {
	app = _app;
	wxBoxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer* sizer_r = new wxBoxSizer(wxVERTICAL);
	lv_tgruppen = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[3];
	cols[0].SetText(wxT(""));
	lv_tgruppen->InsertColumn(0, cols[0]);
	cols[1].SetText(R::TGRUPPE);
	lv_tgruppen->InsertColumn(1, cols[1]);
	cols[2].SetText(R::TERMINE);
	lv_tgruppen->InsertColumn(2, cols[2]);
	notifyTGruppen();
	sizer->Add(lv_tgruppen, 1, wxEXPAND, 0);
	bt_add = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_r->Add(bt_add, 0, 0, 0);
	bt_edt = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_r->Add(bt_edt, 0, 0, 0);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_r->Add(bt_del, 0, 0, 0);
	sizer->Add(sizer_r, 0, 0, 0);

	SetSizer(sizer);
}

void TGruppenPanel::notifyTGruppen(int index) {
	lv_tgruppen->DeleteAllItems();
	list_tgruppen_indices.clear();
	int counter = 0;
	int tgruppen_counter = 0;
	int num_tgruppen = app->list_tgruppe.size();
	for (int i = 0; i < num_tgruppen; i++) {
		TGruppe tg = *(app->list_tgruppe.at(i));
		wxListItem item;
		item.SetId(counter);
		lv_tgruppen->InsertItem(item);
		lv_tgruppen->SetItem(counter, 0, wxString::Format(wxT("%i"), tgruppen_counter + 1));
		lv_tgruppen->SetItem(counter, 1, TGruppe::printModus(&tg));
		list_tgruppen_indices.push_back(counter);
		counter++;
		tgruppen_counter++;
		for (int j = 0; j < (int) tg.list_einzel.size(); j++) {
			Einzeltermin* t = tg.list_einzel.at(j);
			wxListItem item_t;
			item_t.SetId(counter);
			lv_tgruppen->InsertItem(item_t);
			lv_tgruppen->SetItem(counter, 2, Einzeltermin::printShort(t));
			counter++;
		}
		for (int j = 0; j < (int) tg.list_serie.size(); j++) {
			Serientermin* t = tg.list_serie.at(j);
			wxListItem item_t;
			item_t.SetId(counter);
			lv_tgruppen->InsertItem(item_t);
			lv_tgruppen->SetItem(counter, 2, Serientermin::printShort(t));
			counter++;
		}
	}
	if (index != -1) lv_tgruppen->Select(list_tgruppen_indices.at(index), true);
	for (int i = 0; i < 3; i++) {
		lv_tgruppen->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

BEGIN_EVENT_TABLE(TGruppenPanel, wxPanel)
EVT_BUTTON(R::ID_BT_ADD, TGruppenPanel::onBtAdd)
EVT_BUTTON(R::ID_BT_DEL, TGruppenPanel::onBtDel)
EVT_BUTTON(R::ID_BT_EDT, TGruppenPanel::onBtEdt)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, TGruppenPanel::onLIActivated)
EVT_LIST_ITEM_SELECTED(R::ID_LC, TGruppenPanel::onLISelected)
EVT_LIST_KEY_DOWN(R::ID_LC, TGruppenPanel::onLIKey)
END_EVENT_TABLE()

void TGruppenPanel::onBtAdd(wxCommandEvent&) {
	TGruppeDialog* dialog = new TGruppeDialog(this, app);
	dialog->ShowModal();
	delete dialog;
}

void TGruppenPanel::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_tgruppen->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		for (int j = 0; j < (int) list_tgruppen_indices.size(); j++) {
			if (i == list_tgruppen_indices.at(j)) {
				bool del = false;
				DeleteDialog dialog(this, &del);
				dialog.ShowModal();
				if (del) app->delTGruppe(j);
				break;
			}
		}
		break;
	}
}

void TGruppenPanel::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_tgruppen->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		for (int j = 0; j < (int) list_tgruppen_indices.size(); j++) {
			if (i == list_tgruppen_indices.at(j)) {
				TGruppeDialog* dialog = new TGruppeDialog(this, app, j);
				dialog->ShowModal();
				delete dialog;
				break;
			}
		}
		break;
	}
}

void TGruppenPanel::onLIActivated(wxListEvent& evt) {
	int index = evt.GetItem().GetId();
	for (int i = 0; i < (int) list_tgruppen_indices.size(); i++) {
		if (index == list_tgruppen_indices.at(i)) {
			TGruppeDialog* dialog = new TGruppeDialog(this, app, i);
			dialog->ShowModal();
			delete dialog;
			break;
		}
	}
}

void TGruppenPanel::onLISelected(wxListEvent& evt) {
	int index = evt.GetItem().GetId();
	bool correctIndex = false;
	for (int i = 0; i < (int) list_tgruppen_indices.size(); i++) {
		if (index == list_tgruppen_indices.at(i)) {
			correctIndex = true;
			break;
		}
	}
	if (!correctIndex) {
		lv_tgruppen->Select(index, false);
	}
}

void TGruppenPanel::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lv_tgruppen->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			for (int j = 0; j < (int) list_tgruppen_indices.size(); j++) {
				if (i == list_tgruppen_indices.at(j)) {
					bool del = false;
					DeleteDialog dialog(this, &del);
					dialog.ShowModal();
					if (del) app->delTGruppe(j);
					break;
				}
			}
			break;
		}
	}
}

===== ./src/view-data/DienstDialog.h =====
/* 
 * File:   DienstDialog.h
 * Author: Yannik
 *
 * Created on August 19, 2015, 1:25 PM
 */

#ifndef DIENSTDIALOG_H
#define	DIENSTDIALOG_H

#include <wx/wx.h>
class App;

class DienstDialog : public wxDialog {
public:
	DienstDialog(wxWindow* parent, App* _app);
	DienstDialog(wxWindow* parent, App* _app, int _index);
private:
	App* app;
	bool edt;
	int index;
	wxStaticText* st_name;
	wxTextCtrl* tc_name;
	wxButton* bt_ok;
	wxButton* bt_cancel;
	void initComponents();
	DECLARE_EVENT_TABLE();
	void onBtOK(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};

#endif	/* DIENSTDIALOG_H */



===== ./src/view-data/TerminDienstDialog.h =====
/* 
 * File:   TerminDienstDialog.h
 * Author: Yannik
 *
 * Created on August 21, 2015, 10:17 AM
 */

#ifndef TERMINDIENSTDIALOG_H
#define	TERMINDIENSTDIALOG_H

#include <wx/wx.h>
#include <wx/spinctrl.h>
#include <vector>
#include "../model-data/Dienst.h"
#include "../R.h"

/**
 * Pass list of missing services. Case edt: service to edit at(0).
 */
class TerminDienstDialog : public wxDialog {
public:
	TerminDienstDialog(wxWindow* parent, std::vector< std::pair<Dienst*, int> >* _dienste, std::vector<Dienst*>* _missing_dienste);
	TerminDienstDialog(wxWindow* parent, std::vector< std::pair<Dienst*, int> >* _dienste, std::vector<Dienst*>* _missing_dienste, int _index);
private:
	bool edt;
	int index;
	std::vector< std::pair<Dienst*, int> >* dienste;
	std::vector<Dienst*>* missing_dienste;
	wxStaticText* st_dienst;
	wxStaticText* st_anzahl;
	wxChoice* ch_dienst;
	wxSpinCtrl* sp_anzahl;
	wxButton* bt_ok;
	wxButton* bt_cancel;
	void initComponents();
	DECLARE_EVENT_TABLE();
	void onBtOK(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};


#endif	/* TERMINDIENSTDIALOG_H */



===== ./src/view-data/SerienterminDialog.cpp =====
/* 
 * File:   SerienterminDialog.cpp
 * Author: Yannik
 * 
 * Created on August 12, 2015, 6:44 PM
 */

#include "SerienterminDialog.h"
#include <algorithm>
#include "../App.h"
#include "../R.h"
#include "../Util.h"
#include "TerminDienstDialog.h"

SerienterminDialog::SerienterminDialog(wxWindow* parent, App* _app)
: wxDialog(parent, R::ID_ANY, R::SERIENTERMIN_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = false;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

SerienterminDialog::SerienterminDialog(wxWindow* parent, App* _app, int _index)
: wxDialog(parent, R::ID_ANY, R::SERIENTERMIN_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = true;
	index = _index;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

void SerienterminDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	gridsizer = new wxFlexGridSizer(12, 2, 0, 0);

	st_name = new wxStaticText(this, R::ID_ANY, R::NAME);
	gridsizer->Add(st_name, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_name = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_name, 1, wxEXPAND | wxALL, 2);

	st_ort = new wxStaticText(this, R::ID_ANY, R::ORT);
	gridsizer->Add(st_ort, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	int num_orte =app->list_ort.size();
	wxString arr_orte[num_orte];
	for(int i = 0; i < num_orte; i++) {
		arr_orte[i] = app->list_ort.at(i);
	}
	tc_ort = new wxComboBox(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, num_orte, arr_orte);
	gridsizer->Add(tc_ort, 1, wxEXPAND | wxALL, 2);

	st_modus = new wxStaticText(this, R::ID_ANY, R::MODUS);
	gridsizer->Add(st_modus, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	ch_modus = new wxChoice(this, R::ID_CH, wxDefaultPosition, wxDefaultSize, R::TMODI_NUM, R::TMODI);
	gridsizer->Add(ch_modus, 1, wxEXPAND | wxALL, 2);

	st_wochentag = new wxStaticText(this, R::ID_ANY, R::WOCHENTAG);
	gridsizer->Add(st_wochentag, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	ch_wochentag = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, 7, R::WOCHENTAGE);
	ch_wochentag->SetSelection(0);
	gridsizer->Add(ch_wochentag, 0, wxEXPAND | wxALL, 2);

	st_n = new wxStaticText(this, R::ID_ANY, wxT("n"));
	gridsizer->Add(st_n, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_n = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_n, 0, wxEXPAND | wxALL, 2);

	st_woche = new wxStaticText(this, R::ID_ANY, wxT("n"));
	gridsizer->Add(st_woche, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxString n_im_monat[] = {wxT("1."), wxT("2."), wxT("3."), wxT("4."), wxT("5."), R::VORLETZTER, R::LETZTER};
	ch_woche = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, 7, n_im_monat);
	ch_woche->SetSelection(0);
	gridsizer->Add(ch_woche, 0, wxEXPAND | wxALL, 2);

	st_monatstag = new wxStaticText(this, R::ID_ANY, R::TAG);
	gridsizer->Add(st_monatstag, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxString monatstage[31];
	for (int i = 0; i < 31; i++) {
		monatstage[i] = wxString::Format(wxT("%i"), i + 1);
	}
	ch_monatstag = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, 31, monatstage);
	ch_monatstag->SetSelection(0);
	gridsizer->Add(ch_monatstag, 0, wxEXPAND | wxALL, 2);

	st_zeit_beginn = new wxStaticText(this, R::ID_ANY, R::ZEIT);
	gridsizer->Add(st_zeit_beginn, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_zeit_beginn = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	tc_zeit_beginn->SetHint(wxT("hh:mm"));
	gridsizer->Add(tc_zeit_beginn, 1, wxEXPAND | wxALL, 2);

	st_dienste = new wxStaticText(this, R::ID_ANY, R::DIENSTE);
	gridsizer->Add(st_dienste, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_dienste = new wxBoxSizer(wxHORIZONTAL);
	lv_dienste = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[2];
	cols[0].SetText(R::DIENST);
	lv_dienste->InsertColumn(0, cols[0]);
	cols[1].SetText(R::ANZAHL);
	lv_dienste->InsertColumn(1, cols[1]);
	sizer_dienste->Add(lv_dienste, 1, wxEXPAND, 0);
	wxBoxSizer* sizer_dienste_r = new wxBoxSizer(wxVERTICAL);
	bt_add_dienst = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_dienste_r->Add(bt_add_dienst, 0, 0, 0);
	bt_edt_dienst = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_dienste_r->Add(bt_edt_dienst, 0, 0, 0);
	bt_del_dienst = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_dienste_r->Add(bt_del_dienst, 0, 0, 0);
	sizer_dienste->Add(sizer_dienste_r, 0, 0, 0);
	gridsizer->Add(sizer_dienste, 1, wxEXPAND | wxALL, 2);

	st_datum_beginn = new wxStaticText(this, R::ID_ANY, R::DATUM_AB);
	gridsizer->Add(st_datum_beginn, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_datum_beginn = new wxBoxSizer(wxHORIZONTAL);
	cb_datum_beginn = new wxCheckBox(this, R::ID_BT_ADD2, wxEmptyString);
	cb_datum_beginn->SetValue(false);
	sizer_datum_beginn->Add(cb_datum_beginn, 0, wxALL | wxALIGN_CENTER, 0);
	dc_datum_beginn = new wxDatePickerCtrl(this, R::ID_LC, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, wxDP_DEFAULT | wxDP_SHOWCENTURY);
	dc_datum_beginn->Enable(false);
	sizer_datum_beginn->Add(dc_datum_beginn, 1, wxEXPAND | wxALL, 0);
	st_datum_beginn_wday = new wxStaticText(this, R::ID_ANY, wxT(""), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT | wxST_NO_AUTORESIZE);
	sizer_datum_beginn->Add(st_datum_beginn_wday, 1, wxALL | wxALIGN_CENTER_VERTICAL | wxALIGN_RIGHT, 2);
	gridsizer->Add(sizer_datum_beginn, 1, wxEXPAND | wxALL, 2);

	st_datum_ende = new wxStaticText(this, R::ID_ANY, R::DATUM_BIS);
	gridsizer->Add(st_datum_ende, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	wxBoxSizer* sizer_datum_ende = new wxBoxSizer(wxHORIZONTAL);
	cb_datum_ende = new wxCheckBox(this, R::ID_BT_DEL2, wxEmptyString);
	cb_datum_ende->SetValue(false);
	sizer_datum_ende->Add(cb_datum_ende, 0, wxALL | wxALIGN_CENTER, 0);
	dc_datum_ende = new wxDatePickerCtrl(this, R::ID_LC2, wxDefaultDateTime, wxDefaultPosition, wxDefaultSize, wxDP_DEFAULT | wxDP_SHOWCENTURY);
	dc_datum_ende->Enable(false);
	sizer_datum_ende->Add(dc_datum_ende, 1, wxEXPAND | wxALL, 0);
	st_datum_ende_wday = new wxStaticText(this, R::ID_ANY, wxT(""), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT | wxST_NO_AUTORESIZE);
	sizer_datum_ende->Add(st_datum_ende_wday, 1, wxALL | wxALIGN_CENTER_VERTICAL | wxALIGN_RIGHT, 2);
	gridsizer->Add(sizer_datum_ende, 0, wxEXPAND | wxALL, 2);

	st_bem = new wxStaticText(this, R::ID_ANY, R::BEM);
	gridsizer->Add(st_bem, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_bem = new wxTextCtrl(this, R::ID_ANY, wxEmptyString);
	gridsizer->Add(tc_bem, 1, wxEXPAND | wxALL, 2);

	gridsizer->AddGrowableCol(1, 1);
	gridsizer->AddGrowableRow(8, 1);
	sizer->Add(gridsizer, 1, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	setModusNWochentagImMonat(); //for size
	SetSizerAndFit(sizer);
	if (GetSize().GetWidth() < 260) {
		SetSize(260, -1);
	}
	if (edt) {
		Serientermin termin = *(app->list_serientermin.at(index));
		tc_name->SetValue(termin.name);
		tc_ort->SetValue(termin.ort);
		dienste = termin.dienste;
		notifyDienste();
		tc_zeit_beginn->SetValue(termin.zeit_beginn);
		if (termin.datum_beginn != wxT("")) {
			cb_datum_beginn->SetValue(true);
			dc_datum_beginn->Enable(true);
			dc_datum_beginn->SetValue(Util::wxString_to_wxDateTime(termin.datum_beginn));
			st_datum_beginn_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum_beginn->GetValue().GetWeekDay()] + wxT(")"));
		}
		if (termin.datum_ende != wxT("")) {
			cb_datum_ende->SetValue(true);
			dc_datum_ende->Enable(true);
			dc_datum_ende->SetValue(Util::wxString_to_wxDateTime(termin.datum_ende));
			st_datum_ende_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum_ende->GetValue().GetWeekDay()] + wxT(")"));
		}
		tc_bem->SetValue(termin.bem);
		ch_modus->SetSelection(termin.modus);
		modus = termin.modus;
		switch (modus) {
			case Serientermin::TAEGLICH:
				setModusTaeglich();
				break;
			case Serientermin::WOECHENTLICH:
				ch_wochentag->SetSelection(termin.wochentag);
				setModusWoechentlich();
				break;
			case Serientermin::GERADE_KW:
				ch_wochentag->SetSelection(termin.wochentag);
				setModusKW();
				break;
			case Serientermin::UNGERADE_KW:
				ch_wochentag->SetSelection(termin.wochentag);
				setModusKW();
				break;
			case Serientermin::N_WOECHENTLICH:
				ch_wochentag->SetSelection(termin.wochentag);
				tc_n->SetValue(wxString::Format(wxT("%i"), termin.n));
				setModusNWoechentlich();
				break;
			case Serientermin::W_IM_MONAT:
				ch_wochentag->SetSelection(termin.wochentag);
				ch_woche->SetSelection(termin.n);
				setModusNWochentagImMonat();
				break;
			case Serientermin::MONATLICH:
				ch_monatstag->SetSelection(termin.n - 1);
				setModusMonatlich();
				break;
		}
	} else {
		modus = Serientermin::WOECHENTLICH;
		ch_modus->SetSelection(1);
		setModusWoechentlich();
	}
}

void SerienterminDialog::notifyDienste() {
	lv_dienste->DeleteAllItems();
	for (int i = 0; i < (int) dienste.size(); i++) {
		wxListItem item;
		item.SetId(i);
		lv_dienste->InsertItem(item);
		lv_dienste->SetItem(i, 0, dienste.at(i).first->name);
		lv_dienste->SetItem(i, 1, wxString::Format(wxT("%i"), dienste.at(i).second));
	}
	lv_dienste->SetColumnWidth(0, wxLIST_AUTOSIZE_USEHEADER);
	lv_dienste->SetColumnWidth(1, wxLIST_AUTOSIZE_USEHEADER);
}

void SerienterminDialog::setModusTaeglich() {
	st_wochentag->Hide();
	ch_wochentag->Hide();
	st_n->Hide();
	tc_n->Hide();
	st_woche->Hide();
	ch_woche->Hide();
	st_monatstag->Hide();
	ch_monatstag->Hide();
	gridsizer->Layout();
}

void SerienterminDialog::setModusWoechentlich() {
	st_wochentag->Show();
	ch_wochentag->Show();
	st_n->Hide();
	tc_n->Hide();
	st_woche->Hide();
	ch_woche->Hide();
	st_monatstag->Hide();
	ch_monatstag->Hide();
	gridsizer->Layout();
}

void SerienterminDialog::setModusKW() {
	st_wochentag->Show();
	ch_wochentag->Show();
	st_n->Hide();
	tc_n->Hide();
	st_woche->Hide();
	ch_woche->Hide();
	st_monatstag->Hide();
	ch_monatstag->Hide();
	gridsizer->Layout();
}

void SerienterminDialog::setModusNWoechentlich() {
	st_wochentag->Show();
	ch_wochentag->Show();
	st_n->Show();
	tc_n->Show();
	st_woche->Hide();
	ch_woche->Hide();
	st_monatstag->Hide();
	ch_monatstag->Hide();
	gridsizer->Layout();
}

void SerienterminDialog::setModusNWochentagImMonat() {
	st_wochentag->Show();
	ch_wochentag->Show();
	st_n->Hide();
	tc_n->Hide();
	st_woche->Show();
	ch_woche->Show();
	st_monatstag->Hide();
	ch_monatstag->Hide();
	gridsizer->Layout();
}

void SerienterminDialog::setModusMonatlich() {
	st_wochentag->Hide();
	ch_wochentag->Hide();
	st_n->Hide();
	tc_n->Hide();
	st_woche->Hide();
	ch_woche->Hide();
	st_monatstag->Show();
	ch_monatstag->Show();
	gridsizer->Layout();
}

BEGIN_EVENT_TABLE(SerienterminDialog, wxDialog)
EVT_BUTTON(R::ID_BT_ADD, SerienterminDialog::onBtAddDienst)
EVT_BUTTON(R::ID_BT_EDT, SerienterminDialog::onBtEdtDienst)
EVT_BUTTON(R::ID_BT_DEL, SerienterminDialog::onBtDelDienst)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, SerienterminDialog::onLIDienstActivated)
EVT_BUTTON(R::ID_BT_OK, SerienterminDialog::onBtOK)
EVT_BUTTON(R::ID_BT_CANCEL, SerienterminDialog::onBtCancel)
EVT_CHOICE(R::ID_CH, SerienterminDialog::onChModus)
EVT_DATE_CHANGED(R::ID_LC, SerienterminDialog::onDateBeginnChanged)
EVT_DATE_CHANGED(R::ID_LC2, SerienterminDialog::onDateEndeChanged)
EVT_CHECKBOX(R::ID_BT_ADD2, SerienterminDialog::onCbDatumBeginn)
EVT_CHECKBOX(R::ID_BT_DEL2, SerienterminDialog::onCbDatumEnde)
END_EVENT_TABLE()

void SerienterminDialog::onBtAddDienst(wxCommandEvent&) {
	std::vector<Dienst*> missing_dienste;
	for (std::vector<Dienst*>::iterator iter = app->list_dienst.begin(); iter != app->list_dienst.end(); iter++) {
		bool contains = false;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = dienste.begin(); iter_t != dienste.end(); iter_t++) {
			if (*iter == iter_t->first) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			missing_dienste.push_back(*iter);
		}
	}
	TerminDienstDialog* dialog = new TerminDienstDialog(this, &dienste, &missing_dienste);
	dialog->ShowModal();
	delete dialog;
	std::sort(dienste.begin(), dienste.end(), Dienst::cmp2);
	notifyDienste();
}

void SerienterminDialog::onBtEdtDienst(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		std::vector<Dienst*> missing_dienste;
		missing_dienste.insert(missing_dienste.begin(), dienste.at(i).first);
		for (std::vector<Dienst*>::iterator iter = app->list_dienst.begin(); iter != app->list_dienst.end(); iter++) {
			bool contains = false;
			for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = dienste.begin(); iter_t != dienste.end(); iter_t++) {
				if (*iter == iter_t->first) {
					contains = true;
					break;
				}
			}
			if (!contains) {
				missing_dienste.push_back(*iter);
			}
		}
		TerminDienstDialog* dialog = new TerminDienstDialog(this, &dienste, &missing_dienste, i);
		dialog->ShowModal();
		delete dialog;
		break;
	}
	std::sort(dienste.begin(), dienste.end(), Dienst::cmp2);
	notifyDienste();
}

void SerienterminDialog::onBtDelDienst(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_dienste->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		dienste.erase(dienste.begin() + i);
		break;
	}
	notifyDienste();
}

void SerienterminDialog::onLIDienstActivated(wxListEvent& evt) {
	int id = evt.GetItem().GetId();
	std::vector<Dienst*> missing_dienste;
	missing_dienste.insert(missing_dienste.begin(), dienste.at(id).first);
	for (std::vector<Dienst*>::iterator iter = app->list_dienst.begin(); iter != app->list_dienst.end(); iter++) {
		bool contains = false;
		for (std::vector< std::pair<Dienst*, int> >::iterator iter_t = dienste.begin(); iter_t != dienste.end(); iter_t++) {
			if (*iter == iter_t->first) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			missing_dienste.push_back(*iter);
		}
	}
	TerminDienstDialog* dialog = new TerminDienstDialog(this, &dienste, &missing_dienste, id);
	dialog->ShowModal();
	delete dialog;
	std::sort(dienste.begin(), dienste.end(), Dienst::cmp2);
	notifyDienste();
}

void SerienterminDialog::onBtOK(wxCommandEvent&) {
	wxString t_zeit_beginn;
	if (!Util::formatTime(tc_zeit_beginn->GetValue(), &t_zeit_beginn)) {
		wxMessageDialog dialog(this, R::MSG_TIME_ERR);
		dialog.ShowModal();
		return;
	}
	wxString t_datum_beginn = cb_datum_beginn->IsChecked() ? Util::wxDateTime_to_wxString(dc_datum_beginn->GetValue()) : wxT("");
	wxString t_datum_ende = cb_datum_ende->IsChecked() ? Util::wxDateTime_to_wxString(dc_datum_ende->GetValue()) : wxT("");
	Serientermin* t;
	switch (modus) {
		case Serientermin::TAEGLICH:
			t = new Serientermin(Util::rmD(tc_name->GetValue()), Util::rmD(tc_ort->GetValue()),
					dienste, t_zeit_beginn, t_datum_beginn, t_datum_ende, modus, 0, 0, Util::rmD(tc_bem->GetValue()));
			break;
		case Serientermin::WOECHENTLICH:
		case Serientermin::GERADE_KW:
		case Serientermin::UNGERADE_KW:
			t = new Serientermin(Util::rmD(tc_name->GetValue()), Util::rmD(tc_ort->GetValue()),
					dienste, t_zeit_beginn, t_datum_beginn, t_datum_ende, modus, ch_wochentag->GetSelection(), 0, Util::rmD(tc_bem->GetValue()));
			break;
		case Serientermin::N_WOECHENTLICH:
			long t_n;
			if (!tc_n->GetValue().ToLong(&t_n, 10) || t_n < 1) {
				wxMessageDialog dialog(this, R::MSG_WEEK_NUM_ERR);
				dialog.ShowModal();
				return;
			}
			if (!cb_datum_beginn->IsChecked()) {
				wxMessageDialog dialog(this, R::MSG_WEEK_COUNT_START);
				dialog.ShowModal();
				return;
			}
			t = new Serientermin(Util::rmD(tc_name->GetValue()), Util::rmD(tc_ort->GetValue()),
					dienste, t_zeit_beginn, t_datum_beginn, t_datum_ende, modus, ch_wochentag->GetSelection(), t_n, Util::rmD(tc_bem->GetValue()));
			break;
		case Serientermin::W_IM_MONAT:
			t = new Serientermin(Util::rmD(tc_name->GetValue()), Util::rmD(tc_ort->GetValue()),
					dienste, t_zeit_beginn, t_datum_beginn, t_datum_ende, modus, ch_wochentag->GetSelection(), ch_woche->GetSelection(), Util::rmD(tc_bem->GetValue()));
			break;
		default://Serientermin::MONATLICH
			t = new Serientermin(Util::rmD(tc_name->GetValue()), Util::rmD(tc_ort->GetValue()),
					dienste, t_zeit_beginn, t_datum_beginn, t_datum_ende, modus, 0, ch_monatstag->GetSelection() + 1, Util::rmD(tc_bem->GetValue()));
			break;
	}
	if (edt) {
		if (!app->edtSerientermin(index, t)) {
			delete t;
			wxMessageDialog dialog(this, R::MSG_SERIE_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			delete t;
			Close(true);
		}
	} else {
		if (!app->addSerientermin(t)) {
			delete t;
			wxMessageDialog dialog(this, R::MSG_SERIE_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			Close(true);
		}
	}
}

void SerienterminDialog::onBtCancel(wxCommandEvent&) {
	Close();
}

void SerienterminDialog::onChModus(wxCommandEvent&) {
	switch (ch_modus->GetSelection()) {
		case 0:
			modus = Serientermin::TAEGLICH;
			setModusTaeglich();
			break;
		case 1:
			modus = Serientermin::WOECHENTLICH;
			setModusWoechentlich();
			break;
		case 2:
			modus = Serientermin::GERADE_KW;
			setModusKW();
			break;
		case 3:
			modus = Serientermin::UNGERADE_KW;
			setModusKW();
			break;
		case 4:
			modus = Serientermin::N_WOECHENTLICH;
			setModusNWoechentlich();
			break;
		case 5:
			modus = Serientermin::W_IM_MONAT;
			setModusNWochentagImMonat();
			break;
		case 6:
			modus = Serientermin::MONATLICH;
			setModusMonatlich();
			break;
	}
}

void SerienterminDialog::onCbDatumBeginn(wxCommandEvent&) {
	if (dc_datum_beginn->IsEnabled()) {
		dc_datum_beginn->Enable(false);
		st_datum_beginn_wday->SetLabel(wxT(""));
	} else {
		dc_datum_beginn->Enable(true);
		st_datum_beginn_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum_beginn->GetValue().GetWeekDay()] + wxT(")"));
	}
}

void SerienterminDialog::onCbDatumEnde(wxCommandEvent&) {
	if (dc_datum_ende->IsEnabled()) {
		dc_datum_ende->Enable(false);
		st_datum_ende_wday->SetLabel(wxT(""));
	} else {
		dc_datum_ende->Enable(true);
		st_datum_ende_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum_ende->GetValue().GetWeekDay()] + wxT(")"));
	}
}

void SerienterminDialog::onDateBeginnChanged(wxDateEvent&) {
	st_datum_beginn_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum_beginn->GetValue().GetWeekDay()] + wxT(")"));
}

void SerienterminDialog::onDateEndeChanged(wxDateEvent&) {
	st_datum_ende_wday->SetLabel(wxT("(") + R::WOCHENTAGE[dc_datum_ende->GetValue().GetWeekDay()] + wxT(")"));
}

===== ./src/view-data/SerienterminDialog.h =====
/* 
 * File:   SerienterminDialog.h
 * Author: Yannik
 *
 * Created on August 12, 2015, 6:44 PM
 */

#ifndef SERIENTERMINDIALOG_H
#define	SERIENTERMINDIALOG_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include <wx/datectrl.h>
#include <wx/dateevt.h>
#include <vector>
#include "../model-data/Serientermin.h"
class App;

class SerienterminDialog : public wxDialog {
public:
	SerienterminDialog(wxWindow* parent, App* _app);
	SerienterminDialog(wxWindow* parent, App* _app, int _index);
	std::vector< std::pair<Dienst*, int> > dienste;
private:
	App* app;
	bool edt;
	int index;
	int modus;

	wxFlexGridSizer* gridsizer;

	wxStaticText* st_name;
	wxStaticText* st_ort;
	wxStaticText* st_dienste;
	wxStaticText* st_zeit_beginn;
	wxStaticText* st_modus;
	wxStaticText* st_wochentag;
	wxStaticText* st_n;
	wxStaticText* st_woche;
	wxStaticText* st_monatstag;
	wxStaticText* st_datum_beginn;
	wxStaticText* st_datum_ende;
	wxStaticText* st_bem;

	wxTextCtrl* tc_name;
	wxComboBox* tc_ort;
	wxListView* lv_dienste;
	wxButton* bt_add_dienst;
	wxButton* bt_edt_dienst;
	wxButton* bt_del_dienst;
	wxTextCtrl* tc_zeit_beginn;
	wxChoice* ch_modus;
	wxChoice* ch_wochentag;
	wxTextCtrl* tc_n;
	wxChoice* ch_woche;
	wxChoice* ch_monatstag;
	wxCheckBox* cb_datum_beginn;
	wxDatePickerCtrl* dc_datum_beginn;
	wxStaticText* st_datum_beginn_wday;
	wxCheckBox* cb_datum_ende;
	wxDatePickerCtrl* dc_datum_ende;
	wxStaticText* st_datum_ende_wday;
	wxTextCtrl* tc_bem;

	wxButton* bt_ok;
	wxButton* bt_cancel;
	void notifyDienste();
	void initComponents();

	void setModusTaeglich();
	void setModusWoechentlich();
	void setModusKW();
	void setModusNWoechentlich();
	void setModusNWochentagImMonat();
	void setModusMonatlich();
	DECLARE_EVENT_TABLE();
	void onBtOK(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
	void onBtAddDienst(wxCommandEvent&);
	void onBtEdtDienst(wxCommandEvent&);
	void onBtDelDienst(wxCommandEvent&);
	void onLIDienstActivated(wxListEvent& evt);
	void onChModus(wxCommandEvent&);
	void onCbDatumBeginn(wxCommandEvent&);
	void onCbDatumEnde(wxCommandEvent&);
	void onDateBeginnChanged(wxDateEvent&);
	void onDateEndeChanged(wxDateEvent&);
};

#endif	/* SERIENTERMINDIALOG_H */



===== ./src/view-data/MGruppenPanel.h =====
/* 
 * File:   MGruppenPanel.h
 * Author: Yannik
 *
 * Created on August 13, 2015, 11:44 AM
 */

#ifndef MGRUPPENPANEL_H
#define	MGRUPPENPANEL_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include "../model-data/MGruppe.h"
class App;

class MGruppenPanel : public wxPanel {
public:
	MGruppenPanel(wxWindow* parent, App* _app);
	void notifyMGruppen(int index = -1);
private:
	App* app;
	wxListView* lv_gruppen;
	wxButton* bt_add;
	wxButton* bt_del;
	wxButton* bt_edt;
	DECLARE_EVENT_TABLE();
	void onBtAdd(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
};

#endif	/* MGRUPPENPANEL_H */

===== ./src/view-data/DienstePanel.h =====
/* 
 * File:   DienstePanel.h
 * Author: Yannik
 *
 * Created on August 19, 2015, 11:37 AM
 */

#ifndef DIENSTEPANEL_H
#define	DIENSTEPANEL_H

#include <wx/wx.h>
#include <wx/listctrl.h>
class App;

class DienstePanel : public wxPanel {
public:
	DienstePanel(wxWindow* parent, App* _app);
	void notifyDienste(int index = -1);
private:
	App* app;
	wxListView* lc_dienste;
	wxButton* bt_add;
	wxButton* bt_edt;
	wxButton* bt_del;
	DECLARE_EVENT_TABLE();
	void onBtAdd(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtEdt(wxCommandEvent&);
	void onLIActivated(wxListEvent& evt);
	void onLIKey(wxListEvent& evt);
};

#endif	/* DIENSTEPANEL_H */



===== ./src/view-data/TerminePanel.h =====
/* 
 * File:   TerminePanel.h
 * Author: Yannik
 *
 * Created on August 12, 2015, 5:37 PM
 */

#ifndef TERMINEPANEL_H
#define	TERMINEPANEL_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include "../R.h"
class App;

class TerminePanel : public wxPanel {
public:
	TerminePanel(wxWindow* parent, App* _app);
	void notifyEinzeltermine(int index = -1);
	void notifySerientermine(int index = -1);
private:
	App* app;
	
	wxStaticText* st_einzel;
	wxStaticText* st_serie;
	wxListView* lc_einzel;
	wxListView* lc_serie;
	wxButton* bt_einzel_add;
	wxButton* bt_einzel_del;
	wxButton* bt_einzel_edt;
	wxButton* bt_einzel_import;
	wxButton* bt_serie_add;
	wxButton* bt_serie_del;
	wxButton* bt_serie_edt;
	wxListItem lc_einzel_cols[R::TEINZEL_NUM + 1];
	wxListItem lc_serie_cols[R::TSERIE_NUM + 1];
	DECLARE_EVENT_TABLE();
	void onBtEinAdd(wxCommandEvent&);
	void onBtEinDel(wxCommandEvent&);
	void onBtEinEdt(wxCommandEvent&);
	void onBtEinImport(wxCommandEvent&);
	void onBtSerAdd(wxCommandEvent&);
	void onBtSerDel(wxCommandEvent&);
	void onBtSerEdt(wxCommandEvent&);
	void onLIEinActivated(wxListEvent& evt);
	void onLISerActivated(wxListEvent& evt);
	void onLIEinKey(wxListEvent& evt);
	void onLISerKey(wxListEvent& evt);
};

#endif	/* TERMINEPANEL_H */



===== ./src/view-data/TGruppeDialog.h =====
/* 
 * File:   TGruppeDialog.h
 * Author: Yannik
 *
 * Created on August 16, 2015, 1:48 PM
 */

#ifndef TGRUPPEDIALOG_H
#define	TGRUPPEDIALOG_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include "../model-data/TGruppe.h"
class App;

class TGruppeDialog : public wxDialog {
public:
	TGruppeDialog(wxWindow* parent, App* _app);
	TGruppeDialog(wxWindow* parent, App* _app, int _index);
private:
	App* app;
	bool edt;
	int index;
	std::vector<Serientermin*> list_serie_tgruppe;
	std::vector<Serientermin*> list_serie_rest;
	std::vector<Einzeltermin*> list_einzel_tgruppe;
	std::vector<Einzeltermin*> list_einzel_rest;

	wxStaticText* st_wochentag;
	wxChoice* ch_wochentag;
	wxStaticText* st_tgruppe;
	wxListView* lv_tgruppe;
	wxStaticText* st_rest;
	wxListView* lv_rest;
	wxButton* bt_togroup;
	wxButton* bt_torest;

	wxButton* bt_ok;
	wxButton* bt_cancel;

	void initComponents();
	void setModePeriodic();
	void setModeNonPeriodic();
	void drawGruppe();
	void drawRest();
	DECLARE_EVENT_TABLE();
	void onBtToGruppe(wxCommandEvent&);
	void onBtToRest(wxCommandEvent&);
	void onBtOk(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};

#endif	/* TGRUPPEDIALOG_H */



===== ./src/view-data/MiniExtrasDialog.h =====
/* 
 * File:   MiniExtrasDialog.h
 * Author: Yannik
 *
 * Created on February 11, 2016, 9:39 PM
 */

#ifndef MINIEXTRASDIALOG_H
#define	MINIEXTRASDIALOG_H

#include <wx/wx.h>
#include <vector>
#include "../model-data/Messdiener.h"

class MiniExtrasDialog : public wxDialog {
public:
	MiniExtrasDialog(wxWindow* parent, std::vector<Messdiener*>* _list_mini);
private:
	std::vector<Messdiener*>* list_mini;
	wxTextCtrl* textbox;
	wxString successString;
	wxString failureString;
	void createEmails();
	void createAddresses();
	DECLARE_EVENT_TABLE();
	void onBtEmail(wxCommandEvent&);
	void onBtAddresses(wxCommandEvent&);	
};

#endif	/* MINIEXTRASDIALOG_H */



===== ./src/view-data/MGruppenPanel.cpp =====
/* 
 * File:   MGruppenPanel.cpp
 * Author: Yannik
 * 
 * Created on August 13, 2015, 11:44 AM
 */

#include "MGruppenPanel.h"
#include "../R.h"
#include "../App.h"
#include "MGruppeDialog.h"
#include "../model-data/Messdiener.h"
#include "DeleteDialog.h"

MGruppenPanel::MGruppenPanel(wxWindow* parent, App* _app)
: wxPanel(parent, R::ID_ANY) {
	app = _app;
	wxBoxSizer* sizer = new wxBoxSizer(wxHORIZONTAL);
	wxBoxSizer* sizer_r = new wxBoxSizer(wxVERTICAL);
	lv_gruppen = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT | wxLC_SINGLE_SEL);
	wxListItem cols[3];
	wxString cols_s[3] = {wxT(""), R::MODUS, R::GRUPPE};
	for (int i = 0; i < 3; i++) {
		cols[i].SetText(cols_s[i]);
		lv_gruppen->InsertColumn(i, cols[i]);
	}
	notifyMGruppen();
	sizer->Add(lv_gruppen, 1, wxEXPAND, 0);
	bt_add = new wxButton(this, R::ID_BT_ADD, R::ADD);
	sizer_r->Add(bt_add, 0, 0, 0);
	bt_edt = new wxButton(this, R::ID_BT_EDT, R::EDT);
	sizer_r->Add(bt_edt, 0, 0, 0);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_r->Add(bt_del, 0, 0, 0);
	sizer->Add(sizer_r, 0, 0, 0);
	SetSizerAndFit(sizer);
}

void MGruppenPanel::notifyMGruppen(int index) {
	lv_gruppen->DeleteAllItems();
	int size = app->list_mgruppe.size();
	for (int i = 0; i < size; i++) {
		wxListItem item;
		item.SetId(i);
		lv_gruppen->InsertItem(item);
		lv_gruppen->SetItem(i, 0, wxString::Format(wxT("%i"), i + 1));
		lv_gruppen->SetItem(i, 1, R::MGMODI[app->list_mgruppe.at(i)->modus]);
		lv_gruppen->SetItem(i, 2, MGruppe::printShort(app->list_mgruppe.at(i)));
	}
	if (index != -1) lv_gruppen->Select(index, true);
	for (int i = 0; i < 3; i++) {
		lv_gruppen->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

BEGIN_EVENT_TABLE(MGruppenPanel, wxPanel)
EVT_BUTTON(R::ID_BT_ADD, MGruppenPanel::onBtAdd)
EVT_BUTTON(R::ID_BT_DEL, MGruppenPanel::onBtDel)
EVT_BUTTON(R::ID_BT_EDT, MGruppenPanel::onBtEdt)
EVT_LIST_ITEM_ACTIVATED(R::ID_LC, MGruppenPanel::onLIActivated)
EVT_LIST_KEY_DOWN(R::ID_LC, MGruppenPanel::onLIKey)
END_EVENT_TABLE()

void MGruppenPanel::onBtAdd(wxCommandEvent&) {
	MGruppeDialog* dialog = new MGruppeDialog(this, app);
	dialog->ShowModal();
	delete dialog;
}

void MGruppenPanel::onBtDel(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_gruppen->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		bool del = false;
		DeleteDialog dialog(this, &del);
		dialog.ShowModal();
		if (del) app->delMGruppe(i);
		break;
	}
}

void MGruppenPanel::onBtEdt(wxCommandEvent&) {
	int i = -1;
	for (;;) {
		i = lv_gruppen->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		MGruppeDialog* dialog = new MGruppeDialog(this, app, i);
		dialog->ShowModal();
		delete dialog;
		break;
	}
}

void MGruppenPanel::onLIActivated(wxListEvent& evt) {
	MGruppeDialog* dialog = new MGruppeDialog(this, app, evt.GetItem().GetId());
	dialog->ShowModal();
	delete dialog;
}

void MGruppenPanel::onLIKey(wxListEvent& evt) {
	if (evt.GetKeyCode() == WXK_DELETE) {
		int i = -1;
		for (;;) {
			i = lv_gruppen->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
			if (i == -1) {
				break;
			}
			bool del = false;
			DeleteDialog dialog(this, &del);
			dialog.ShowModal();
			if (del) app->delMGruppe(i);
			break;
		}
	}
}

===== ./src/view-data/DienstDialog.cpp =====
/* 
 * File:   DienstDialog.cpp
 * Author: Yannik
 * 
 * Created on August 19, 2015, 1:25 PM
 */

#include "DienstDialog.h"
#include "../App.h"
#include "../model-data/Dienst.h"
#include "../Util.h"

DienstDialog::DienstDialog(wxWindow* parent, App* _app)
: wxDialog(parent, R::ID_ANY, R::DIENST_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = false;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

DienstDialog::DienstDialog(wxWindow* parent, App* _app, int _index)
: wxDialog(parent, R::ID_ANY, R::DIENST_DIALOG, wxDefaultPosition, wxDefaultSize,
wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) {
	app = _app;
	edt = true;
	index = _index;
	initComponents();
	R::setSubWindowPosition(parent, this);
}

void DienstDialog::initComponents() {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);
	wxFlexGridSizer* sizer_t = new wxFlexGridSizer(1, 2, 0, 0);

	st_name = new wxStaticText(this, R::ID_ANY, R::NAME);
	sizer_t->Add(st_name, 0, wxALL | wxALIGN_CENTER_VERTICAL, 2);
	tc_name = new wxTextCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, 0);
	sizer_t->Add(tc_name, 1, wxALL | wxEXPAND, 2);
	if (edt) {
		tc_name->SetValue(app->list_dienst.at(index)->name);
	}
	sizer_t->AddGrowableCol(1, 1);

	sizer->Add(sizer_t, 1, wxALL | wxEXPAND, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::OK);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizer(sizer);
	Fit();
	if (GetSize().GetWidth() < 260) {
		SetSize(260, -1);
	}
}

BEGIN_EVENT_TABLE(DienstDialog, wxDialog)
EVT_BUTTON(R::ID_BT_OK, DienstDialog::onBtOK)
EVT_BUTTON(R::ID_BT_CANCEL, DienstDialog::onBtCancel)
END_EVENT_TABLE()

void DienstDialog::onBtOK(wxCommandEvent&) {
	Dienst* d = new Dienst(Util::rmD(tc_name->GetValue()));
	if (edt) {
		if (!app->edtDienst(index, d)) {
			delete d;
			wxMessageDialog dialog(this, R::MSG_DIENST_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			delete d;
			Close(true);
		}
	} else {
		if (!app->addDienst(d)) {
			delete d;
			wxMessageDialog dialog(this, R::MSG_DIENST_UNIQUE, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
			dialog.ShowModal();
		} else {
			Close(true);
		}
	}
}

void DienstDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

===== ./src/MiniPlaner.cpp =====
/* 
 * File:   MiniPlaner.cpp
 * Author: Yannik
 *
 * Created on August 11, 2015, 4:01 PM
 */

#include "App.h"

IMPLEMENT_APP(App);

===== ./src/model-data/TGruppe.h =====
/* 
 * File:   TGruppe.h
 * Author: Yannik
 *
 * Created on August 16, 2015, 6:37 AM
 */

#ifndef TGRUPPE_H
#define	TGRUPPE_H

#include <wx/string.h>
#include <vector>
#include "Einzeltermin.h"
#include "Serientermin.h"

class TGruppe {
public:
	int wochentag;
	std::vector<Einzeltermin*> list_einzel;
	std::vector<Serientermin*> list_serie;
	
	TGruppe(int _wochentag, std::vector<Einzeltermin*> _list_einzel, std::vector<Serientermin*> _list_serie);
	static wxString printModus(const TGruppe* tgruppe);
private:
};

#endif	/* TGRUPPE_H */

===== ./src/model-data/Einzeltermin.cpp =====
/* 
 * File:   Einzeltermin.cpp
 * Author: Yannik
 * 
 * Created on August 12, 2015, 6:22 PM
 */

#include "Einzeltermin.h"
#include "../Util.h"
#include "../R.h"

Einzeltermin::Einzeltermin() {

}

Einzeltermin::Einzeltermin(wxString _name, wxString _ort, wxString _datum, wxString _zeit_beginn, std::vector< std::pair<Dienst*, int> > _dienste, wxString _bem)
: name(_name), ort(_ort), datum(_datum), zeit_beginn(_zeit_beginn), dienste(_dienste), bem(_bem) {

}

bool Einzeltermin::cmp(const Einzeltermin* e1, const Einzeltermin* e2) {
	if (e1->datum.IsSameAs(e2->datum)) {
		return e1->zeit_beginn.Cmp(e2->zeit_beginn) < 0;
	}
	return Util::wxString_to_wxDateTime(e1->datum).IsEarlierThan(Util::wxString_to_wxDateTime(e2->datum));
}

bool Einzeltermin::equal(const Einzeltermin* e1, const Einzeltermin* e2) {
	return e1->datum.IsSameAs(e2->datum) && e1->ort.IsSameAs(e2->ort) && e1->zeit_beginn.IsSameAs(e2->zeit_beginn);
}

wxString Einzeltermin::printDienste(const Einzeltermin* e) {
	int num_dienste = e->dienste.size();
	wxString s_dienste;
	for (int i = 0; i < num_dienste; i++) {
		s_dienste += wxString::Format(wxT("%i"), e->dienste.at(i).second) + wxT(" ") + e->dienste.at(i).first->name;
		if (i < num_dienste - 1) {
			s_dienste += wxT(", ");
		}
	}
	return s_dienste;
}

wxString Einzeltermin::printShort(const Einzeltermin* e) {
	wxString ss;
	if (!e->name.IsEmpty()) {
		ss += e->name + wxT(": ");
	}
	if (!e->ort.IsEmpty()) {
		ss += e->ort + wxT(", ");
	}
	ss += e->datum + wxT(" (") + R::WOCHENTAGE[Util::wxString_to_wxDateTime(e->datum).GetWeekDay()] + wxT("), ") + e->zeit_beginn
			+ wxT(", ") + printDienste(e);
	return ss;
}


===== ./src/model-data/Fehlzeit.cpp =====
/* 
 * File:   Fehlzeit.cpp
 * Author: Yannik
 * 
 * Created on August 23, 2015, 12:40 PM
 */

#include "Fehlzeit.h"
#include "../Util.h"
#include "../R.h"

Fehlzeit::Fehlzeit() {

}

Fehlzeit::Fehlzeit(Messdiener* _mini, wxString _datum_beginn, wxString _datum_ende)
: mini(_mini), modus(ZEITRAUM), beginn(_datum_beginn), ende(_datum_ende) {
}

Fehlzeit::Fehlzeit(Messdiener* _mini, int _wochentag, wxString _zeit_beginn, wxString _zeit_ende)
: mini(_mini), modus(WOCHENTAG), wochentag(_wochentag), beginn(_zeit_beginn), ende(_zeit_ende) {

}

Fehlzeit::Fehlzeit(Messdiener* _mini, Einzeltermin* _einzeltermin)
: mini(_mini), modus(EINZELTERMIN), einzeltermin(_einzeltermin) {

}

Fehlzeit::Fehlzeit(Messdiener* _mini, Serientermin* _serientermin)
: mini(_mini), modus(SERIENTERMIN), serientermin(_serientermin) {

}

bool Fehlzeit::cmp(const Fehlzeit* f1, const Fehlzeit* f2) {
	if (Messdiener::equal(f1->mini, f2->mini)) {
		if (f1->modus == f2->modus) {
			switch (f1->modus) {
				case Fehlzeit::ZEITRAUM:
					return Util::wxString_to_wxDateTime(f1->ende).IsLaterThan(Util::wxString_to_wxDateTime(f2->ende));
				case Fehlzeit::WOCHENTAG:
					return f1->wochentag > f2->wochentag;
				case Fehlzeit::EINZELTERMIN:
					return f1->einzeltermin > f2->einzeltermin;
				default:
					return f1->serientermin > f2->serientermin;
			}
		}
		return f1->modus > f2->modus;
	}
	return Messdiener::cmp(f1->mini, f2->mini);
}

bool Fehlzeit::equal(const Fehlzeit* f1, const Fehlzeit* f2) {
	return f1->mini == f2->mini && f1->modus == f2->modus && f1->beginn.IsSameAs(f2->beginn) && f1->ende.IsSameAs(f2->ende) 
			&& f1->wochentag == f2->wochentag && f1->einzeltermin == f2->einzeltermin && f1->serientermin == f2->serientermin;
}

wxString Fehlzeit::printModus(const Fehlzeit* f) {
	wxString s;
	switch (f->modus) {
		case ZEITRAUM:
			s = f->beginn + wxT(" - ") + f->ende;
			break;
		case WOCHENTAG:
			s = R::WOECHENTLICH + wxT(": ") + R::WOCHENTAGE[f->wochentag] + wxT(" ") + f->beginn + wxT(" - ") + f->ende;
			break;
		case EINZELTERMIN:
			s = R::TERMIN + wxT(": ") + Einzeltermin::printShort(f->einzeltermin);
			break;
		case SERIENTERMIN:
			s = R::TERMIN + wxT(": ") + Serientermin::printShort(f->serientermin);
	}
	return s;
}

===== ./src/model-data/Fehlzeit.h =====
/* 
 * File:   Fehlzeit.h
 * Author: Yannik
 *
 * Created on August 23, 2015, 12:40 PM
 */

#ifndef FEHLZEIT_H
#define	FEHLZEIT_H

#include <wx/string.h>
#include "Messdiener.h"
#include "Einzeltermin.h"
#include "Serientermin.h"

class Fehlzeit {
public:
	static const int ZEITRAUM = 0;
	static const int WOCHENTAG = 1;
	static const int EINZELTERMIN = 2;
	static const int SERIENTERMIN = 3;
	static bool cmp(const Fehlzeit* f1, const Fehlzeit* f2);
	static bool equal(const Fehlzeit* f1, const Fehlzeit* f2);
	static wxString printModus(const Fehlzeit* f);
	Messdiener* mini;
	int modus = 0;
	int wochentag = 0;
	wxString beginn; //date or time
	wxString ende; //date or time
	Einzeltermin* einzeltermin = NULL;
	Serientermin* serientermin = NULL;
	
	Fehlzeit();
	Fehlzeit(Messdiener* _mini, wxString _datum_beginn, wxString _datum_ende);
	Fehlzeit(Messdiener* _mini, int _wochentag, wxString _zeit_beginn, wxString _zeit_ende);
	Fehlzeit(Messdiener* _mini, Einzeltermin* _einzeltermin);
	Fehlzeit(Messdiener* _mini, Serientermin* _serientermin);
private:

};

#endif	/* FEHLZEIT_H */



===== ./src/model-data/Serientermin.h =====
/* 
 * File:   Serientermin.h
 * Author: Yannik
 *
 * Created on August 12, 2015, 6:22 PM
 */

#ifndef SERIENTERMIN_H
#define	SERIENTERMIN_H

#include <wx/string.h>
#include "Dienst.h"
#include <vector>

class Serientermin {
public:
	static const int TAEGLICH = 0;
	static const int WOECHENTLICH = 1;
	static const int GERADE_KW = 2;
	static const int UNGERADE_KW = 3;
	static const int N_WOECHENTLICH = 4;
	static const int W_IM_MONAT = 5;
	static const int MONATLICH = 6;
	//Grunddaten
	wxString name;
	wxString ort;
	std::vector< std::pair<Dienst*, int> > dienste;
	wxString zeit_beginn;
	wxString datum_beginn;
	wxString datum_ende;
	int modus;
	//Modus-Daten
	int wochentag;
	int n;
	wxString bem;
	int _id;
	
	Serientermin();
	Serientermin(wxString _name, wxString _ort, std::vector< std::pair<Dienst*, int> > _dienste,
			wxString _zeit_beginn, wxString _datum_beginn, wxString _datum_ende, int _modus, int _wochentag, int _n, wxString _bem);
	static bool cmp(const Serientermin* s1, const Serientermin* s2);
	static bool equal(const Serientermin* s1, const Serientermin* s2);
	static wxString printDienste(const Serientermin* s);
	static wxString printModus(const Serientermin* s);
	static wxString printShort(const Serientermin* s);
private:

};

#endif	/* SERIENTERMIN_H */

===== ./src/model-data/TGruppe.cpp =====
/* 
 * File:   TGruppe.cpp
 * Author: Yannik
 * 
 * Created on August 16, 2015, 6:37 AM
 */

#include "TGruppe.h"
#include "../R.h"

TGruppe::TGruppe(int _wochentag, std::vector<Einzeltermin*> _list_einzel, std::vector<Serientermin*> _list_serie)
: wochentag(_wochentag), list_einzel(_list_einzel), list_serie(_list_serie) {
}

wxString TGruppe::printModus(const TGruppe* tgruppe) {
	if (tgruppe->list_serie.size() > 0) {
		return R::PERIODISCH + R::WOCHENTAGE[tgruppe->wochentag];
	} else {
		return R::NICHT_PERIODISCH;
	}
}


===== ./src/model-data/Dienst.cpp =====
/* 
 * File:   Dienst.cpp
 * Author: Yannik
 * 
 * Created on August 19, 2015, 11:34 AM
 */

#include <utility>

#include "Dienst.h"

Dienst::Dienst(wxString _name)
: name(_name) {

}

bool Dienst::equal(const Dienst* d1, const Dienst* d2) {
	return d1->name.IsSameAs(d2->name);
}

bool Dienst::cmp(const Dienst* d1, const Dienst* d2) {
	return d1->name.compare(d2->name) < 0 ? true : false;
}

bool Dienst::cmp2(const std::pair<Dienst*, int>& d1, const std::pair<Dienst*, int>& d2) {
	return Dienst::cmp(d1.first, d2.first);
}

===== ./src/model-data/Messdiener.cpp =====
/* 
 * File:   Messdiener.cpp
 * Author: Yannik
 * 
 * Created on August 11, 2015, 6:47 PM
 */

#include "Messdiener.h"

Messdiener::Messdiener() {

}

Messdiener::Messdiener(const wxString& _name, const wxString& _vorname, std::vector<Dienst*> _dienste, const wxString& _geburtstag,
		const wxString& _strasse_nr, const wxString& _plz_ort, const wxString& _tel,
		const wxString& _mobile, const wxString& _email, const wxString& _bem)
: name(_name), vorname(_vorname), dienste(_dienste), geburtstag(_geburtstag), strasse_nr(_strasse_nr),
plz_ort(_plz_ort), tel(_tel), mobile(_mobile), email(_email), bem(_bem) {

}

bool Messdiener::cmp(const Messdiener* m1, const Messdiener* m2) {
	if (m1->name.IsSameAs(m2->name)) {
		return m1->vorname.Cmp(m2->vorname) < 0;
	}
	return m1->name.Cmp(m2->name) < 0;
}

bool Messdiener::equal(const Messdiener* m1, const Messdiener* m2) {
	return m1->name.IsSameAs(m2->name) && m1->vorname.IsSameAs(m2->vorname);
}

wxString Messdiener::printDienste(const Messdiener* m) {
	int num_dienste = m->dienste.size();
	wxString s_dienste;
	for (int i = 0; i < num_dienste; i++) {
		s_dienste += m->dienste.at(i)->name;
		if (i < num_dienste - 1) {
			s_dienste += wxT(", ");
		}
	}
	return s_dienste;
}

===== ./src/model-data/Serientermin.cpp =====
/* 
 * File:   Serientermin.cpp
 * Author: Yannik
 * 
 * Created on August 12, 2015, 6:22 PM
 */

#include "Serientermin.h"
#include "../R.h"
#include "../Util.h"

Serientermin::Serientermin() {

}

Serientermin::Serientermin(wxString _name, wxString _ort, std::vector< std::pair<Dienst*, int> > _dienste, wxString _zeit_beginn, wxString _datum_beginn, wxString _datum_ende,
		int _modus, int _wochentag, int _n, wxString _bem)
: name(_name), ort(_ort), dienste(_dienste), zeit_beginn(_zeit_beginn), datum_beginn(_datum_beginn), datum_ende(_datum_ende),
modus(_modus), wochentag(_wochentag), n(_n), bem(_bem) {

}

bool Serientermin::cmp(const Serientermin* s1, const Serientermin* s2) {
	if (s1->modus == s2->modus) {
		if (s1->wochentag == s2->wochentag) {
			return s1->zeit_beginn.Cmp(s2->zeit_beginn) < 0;
		}
		return s1->wochentag < s2->wochentag;
	}
	return s1->modus < s2->modus;
}

bool Serientermin::equal(const Serientermin* s1, const Serientermin* s2) {
	return s1->ort.IsSameAs(s2->ort) && s1->datum_beginn.IsSameAs(s2->datum_beginn) && s1->datum_ende.IsSameAs(s2->datum_ende)
			&& s1->modus == s2->modus && s1->n == s2->n
			&& s1->wochentag == s2->wochentag && s1->zeit_beginn.IsSameAs(s2->zeit_beginn);
}

wxString Serientermin::printDienste(const Serientermin* s) {
	int num_dienste = s->dienste.size();
	wxString s_dienste;
	for (int i = 0; i < num_dienste; i++) {
		s_dienste += wxString::Format(wxT("%i"), s->dienste.at(i).second) + wxT(" ") + s->dienste.at(i).first->name;
		if (i < num_dienste - 1) {
			s_dienste += wxT(", ");
		}
	}
	return s_dienste;
}

wxString Serientermin::printModus(const Serientermin* s) {
	wxString t_modus = R::TMODI[s->modus];
	switch (s->modus) {
		case TAEGLICH:
			break;
		case WOECHENTLICH:
			t_modus += wxT(": ") + R::WOCHENTAGE[s->wochentag];
			break;
		case GERADE_KW:
			t_modus += wxT(": ") + R::WOCHENTAGE[s->wochentag];
			break;
		case UNGERADE_KW:
			t_modus += wxT(": ") + R::WOCHENTAGE[s->wochentag];
			break;
		case N_WOECHENTLICH:
			t_modus = wxString::Format(wxT("%i"), s->n) + wxT("-wöchentlich am ") + R::WOCHENTAGE[s->wochentag] + wxT(", ab (inkl.) der Woche nach [Anfangsdatum]");
			break;
		case W_IM_MONAT:
			if (s->n < 5) {
				t_modus = wxString::Format(wxT("%i"), s->n + 1) + wxT(".");
			} else if (s->n == 5) {
				t_modus = R::VORLETZTER;
			} else {
				t_modus = R::LETZTER;
			}
			t_modus += wxT(" ") + R::WOCHENTAGE[s->wochentag] + wxT(" im Monat");
			break;
		case MONATLICH:
			t_modus += wxT(": ") + wxString::Format(wxT("%i"), s->n) + wxT(".");
			break;
	}
	return t_modus;
}

wxString Serientermin::printShort(const Serientermin* s) {
	wxString ss;
	if (!s->name.IsEmpty()) {
		ss += s->name + wxT(": ");
	}
	if (!s->ort.IsEmpty()) {
		ss += s->ort + wxT(", ");
	}
	ss += printModus(s) + wxT(", ") + s->zeit_beginn;
	if (!s->datum_beginn.IsEmpty()) {
		if (!s->datum_ende.IsEmpty()) {
			ss += wxT(", ") + s->datum_beginn + wxT(" bis ") + s->datum_ende;
		} else {
			ss += wxT(", ab ") + s->datum_beginn;
		}
	} else {
		if (!s->datum_ende.IsEmpty()) {
			ss += wxT(", bis ") + s->datum_ende;
		}
	}
	ss += wxT(", ") + printDienste(s);
	return ss;
}


===== ./src/model-data/Dienst.h =====
/* 
 * File:   Dienst.h
 * Author: Yannik
 *
 * Created on August 19, 2015, 11:33 AM
 */

#ifndef DIENST_H
#define	DIENST_H

#include <wx/string.h>

class Dienst {
public:
	wxString name;
	int _id;
	Dienst(wxString _name);
	static bool equal(const Dienst* d1, const Dienst* d2);
	static bool cmp(const Dienst* d1, const Dienst* d2);
	static bool cmp2(const std::pair<Dienst*, int>& d1, const std::pair<Dienst*, int>& d2);
private:
};

#endif	/* DIENST_H */

===== ./src/model-data/Messdiener.h =====
/* 
 * File:   Messdiener.h
 * Author: Yannik
 *
 * Created on August 11, 2015, 6:47 PM
 */

#ifndef MESSDIENER_H
#define	MESSDIENER_H

#include <wx/string.h>
#include <vector>
#include "Dienst.h"

class Messdiener {
public:
	static bool cmp(const Messdiener* m1, const Messdiener* m2);
	static bool equal(const Messdiener* m1, const Messdiener* m2);
	static wxString printDienste(const Messdiener* m);
	Messdiener();
	Messdiener(const wxString& _name, const wxString& _vorname, std::vector<Dienst*> _dienste, const wxString& _geburtstag,
			const wxString& _strasse_nr, const wxString& _plz_ort, const wxString& _tel,
			const wxString& _mobile, const wxString& _email, const wxString& _bem);

	wxString name;
	wxString vorname;
	std::vector<Dienst*> dienste;
	wxString geburtstag;
	wxString strasse_nr;
	wxString plz_ort;
	wxString tel;
	wxString mobile;
	wxString email;
	wxString bem;
	int _id;
private:

};

#endif	/* MESSDIENER_H */

===== ./src/model-data/Einzeltermin.h =====
/* 
 * File:   Einzeltermin.h
 * Author: Yannik
 *
 * Created on August 12, 2015, 6:22 PM
 */

#ifndef EINZELTERMIN_H
#define	EINZELTERMIN_H

#include <wx/string.h>
#include "Dienst.h"
#include <vector>

class Einzeltermin {
public:
	wxString name;
	wxString ort;
	wxString datum;
	wxString zeit_beginn;
	std::vector< std::pair<Dienst*, int> > dienste;
	wxString bem;
	int _id;
	
	Einzeltermin();
	Einzeltermin(wxString _name, wxString _ort, wxString _datum, wxString _zeit_beginn, std::vector< std::pair<Dienst*, int> > _dienste, wxString _bem);
	static bool cmp(const Einzeltermin* e1, const Einzeltermin* e2);
	static bool equal(const Einzeltermin* e1, const Einzeltermin* e2);
	static wxString printDienste(const Einzeltermin* e);
	static wxString printShort(const Einzeltermin* e);
private:

};

#endif	/* EINZELTERMIN_H */



===== ./src/model-data/MGruppe.cpp =====
/* 
 * File:   MGruppe.cpp
 * Author: Yannik
 * 
 * Created on August 13, 2015, 11:50 AM
 */

#include "MGruppe.h"
#include <algorithm>

MGruppe::MGruppe(int _modus, std::vector<Messdiener*> _list)
: modus(_modus), list(_list) {
}

bool MGruppe::cmp(const MGruppe* m1, const MGruppe* m2) {
	return Messdiener::cmp(m1->list.front(), m2->list.front());
}

wxString MGruppe::printShort(MGruppe* mg) {
	Messdiener m = *(mg->list.at(0));
	wxString s = m.vorname + wxT(" ") + m.name;
	std::vector<Messdiener*>::iterator iter = mg->list.begin();
	iter++;
	for (; iter != mg->list.end(); iter++) {
		s += wxT(", ") + (**iter).vorname + wxT(" ") + (**iter).name;
	}
	return s;
}

===== ./src/model-data/MGruppe.h =====
/* 
 * File:   MGruppe.h
 * Author: Yannik
 *
 * Created on August 13, 2015, 11:50 AM
 */

#ifndef MGRUPPE_H
#define	MGRUPPE_H

#include <vector>
#include "Messdiener.h"

class MGruppe {
public:
	static const int BEV_GEM = 0; //bevorzugt gemeinsam
	static const int NUR_GEM = 1; //nur gemeinsam
	int modus = 0;
	std::vector<Messdiener*> list;
	
	MGruppe(int _modus, std::vector<Messdiener*> _list);
	static bool cmp(const MGruppe* m1, const MGruppe* m2);
	static wxString printShort(MGruppe* m);
private:
};

#endif	/* MGRUPPE_H */

===== ./src/import/MiniImportDialog.cpp =====
/* 
 * File:   MiniImportDialog.cpp
 * Author: Yannik
 * 
 * Created on October 8, 2015, 6:28 PM
 */

#include "MiniImportDialog.h"
#include <wx/filedlg.h>
#include <wx/textfile.h>
#include <wx/tokenzr.h>
#include "../Util.h"
#include "../R.h"
#include "../model-data/Dienst.h"

MiniImportDialog::MiniImportDialog(wxWindow* parent, std::vector<Messdiener*>* _list_mini, bool* _edt)
: wxDialog(parent, R::ID_ANY, R::MINI_IMPORT_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER),
list_mini(_list_mini), edt(_edt) {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxStaticText* st_head = new wxStaticText(this, R::ID_ANY, R::MINI_CSV_MSG);
	sizer->Add(st_head, 0, wxEXPAND | wxLEFT | wxTOP | wxRIGHT, 5);
	const wxString SEP = wxT(";");
	wxStaticText* st_cells = new wxStaticText(this, R::ID_ANY, R::NACHNAME + SEP + R::VORNAME + SEP + R::GEBURTSTAG
			+ SEP + R::STRASSE_NR + SEP + R::PLZ_ORT + SEP + R::TEL + SEP + R::MOBILE + SEP + R::EMAIL);
	st_cells->SetFont(st_cells->GetFont().Bold());
	sizer->Add(st_cells, 0, wxEXPAND | wxLEFT | wxRIGHT | wxBOTTOM, 5);

	sizer->AddSpacer(5);
	wxBoxSizer* sizer_sep = new wxBoxSizer(wxHORIZONTAL);
	wxStaticText* st_sep = new wxStaticText(this, R::ID_ANY, R::SEPARATOR + wxT(": "));
	sizer_sep->Add(st_sep, 0, wxALIGN_CENTER_VERTICAL | wxALL, 0);
	rb_semicolon = new wxRadioButton(this, R::ID_ANY, R::SEMIKOLON, wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
	sizer_sep->Add(rb_semicolon, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_comma = new wxRadioButton(this, R::ID_ANY, R::KOMMA);
	sizer_sep->Add(rb_comma, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_tab = new wxRadioButton(this, R::ID_ANY, wxT("Tab"));
	sizer_sep->Add(rb_tab, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_space = new wxRadioButton(this, R::ID_ANY, R::LEERZEICHEN);
	sizer_sep->Add(rb_space, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_other = new wxRadioButton(this, R::ID_ANY, R::ANDERES);
	sizer_sep->Add(rb_other, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	tc_sep = new wxTextCtrl(this, R::ID_ANY, wxT(""));
	sizer_sep->Add(tc_sep, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_semicolon->SetValue(true);
	sizer->Add(sizer_sep, 0, wxEXPAND | wxALL, 5);

	sizer->AddSpacer(5);
	bt_file = new wxButton(this, R::ID_BT_COMPUTE, R::CSV_DATEI_WAEHLEN);
	sizer->Add(bt_file, 0, wxALL, 5);

	sizer->AddSpacer(5);
	wxStaticText* st_preview = new wxStaticText(this, R::ID_ANY, R::VORSCHAU + wxT(": "));
	sizer->Add(st_preview, 0, wxEXPAND | wxTOP | wxLEFT | wxRIGHT, 5);
	wxBoxSizer* sizer_preview = new wxBoxSizer(wxHORIZONTAL);
	lc_minis = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT);
	wxString lc_minis_texts[] = {R::NACHNAME, R::VORNAME, R::GEBURTSTAG, R::STRASSE_NR, R::PLZ_ORT, R::TEL, R::MOBILE, R::EMAIL, R::BEM};
	wxListItem lc_minis_cols[R::MINI_ATTS_NUM - 1];
	for (int i = 0; i < R::MINI_ATTS_NUM - 1; i++) {
		lc_minis_cols[i].SetText(lc_minis_texts[i]);
		lc_minis->InsertColumn(i, lc_minis_cols[i]);
	}
	for (int i = 0; i < R::MINI_ATTS_NUM - 1; i++) {
		lc_minis->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
	sizer_preview->Add(lc_minis, 1, wxEXPAND);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_preview->Add(bt_del, 0, 0);
	sizer->Add(sizer_preview, 1, wxEXPAND | wxALL, 5);

	wxStaticText* st_import_msg = new wxStaticText(this, R::ID_ANY, R::MINI_IMPORT_MSG);
	sizer->Add(st_import_msg, 0, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::IMPORTIEREN);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
}

void MiniImportDialog::notifyMinis() {
	lc_minis->DeleteAllItems();
	int num_minis = tmp_list.size();
	for (int i = 0; i < num_minis; i++) {
		Messdiener* m = &tmp_list.at(i);
		wxListItem item;
		item.SetId(i);
		lc_minis->InsertItem(item);
		lc_minis->SetItem(i, 0, m->name);
		lc_minis->SetItem(i, 1, m->vorname);
		lc_minis->SetItem(i, 2, m->geburtstag);
		lc_minis->SetItem(i, 3, m->strasse_nr);
		lc_minis->SetItem(i, 4, m->plz_ort);
		lc_minis->SetItem(i, 5, m->tel);
		lc_minis->SetItem(i, 6, m->mobile);
		lc_minis->SetItem(i, 7, m->email);
		lc_minis->SetItem(i, 8, m->bem);
	}
	for (int i = 0; i < R::MINI_ATTS_NUM - 1; i++) {
		lc_minis->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

BEGIN_EVENT_TABLE(MiniImportDialog, wxDialog)
EVT_BUTTON(R::ID_BT_COMPUTE, MiniImportDialog::onBtFile)
EVT_BUTTON(R::ID_BT_DEL, MiniImportDialog::onBtDel)
EVT_BUTTON(R::ID_BT_OK, MiniImportDialog::onBtOk)
EVT_BUTTON(R::ID_BT_CANCEL, MiniImportDialog::onBtCancel)
END_EVENT_TABLE()


void MiniImportDialog::onBtFile(wxCommandEvent&) {
	//delete old
	tmp_list.clear();

	wxFileDialog openFileDialog(this, R::CSV_DATEI_WAEHLEN, wxT(""), wxT(""), wxT("CSV-Dateien (*.csv)|*.csv|Alle (*.*)|*.*"), wxFD_OPEN | wxFD_FILE_MUST_EXIST);
	if (openFileDialog.ShowModal() == wxID_CANCEL) return;
	wxTextFile file(openFileDialog.GetPath());
	if (!file.Exists()) {
		wxMessageDialog dialog(this, R::MSG_FILE_NOT_FOUND, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
		dialog.ShowModal();
		return;
	}
	file.Open();
	wxString D;
	if (rb_semicolon->GetValue()) D = wxT(";");
	else if (rb_comma->GetValue()) D = wxT(",");
	else if (rb_tab->GetValue()) D = wxT("\t");
	else if (rb_space->GetValue()) D = wxT(" ");
	else {
		D = tc_sep->GetValue().Mid(0, 1);
		tc_sep->SetValue(D);
	}
	//iterate
	for (wxString line = file.GetFirstLine(); !file.Eof(); line = file.GetNextLine()) {
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		wxString name = wxT(""), vorname = wxT(""), geburtstag = wxT(""), strasse = wxT(""),
				ort = wxT(""), tel = wxT(""), mobile = wxT(""), email = wxT(""), bem = wxT("");
		wxString * items[R::MINI_ATTS_NUM - 1] = {&name, &vorname, &geburtstag, &strasse, &ort, &tel, &mobile, &email, &bem};
		int counter = 0;
		while (zr.HasMoreTokens() && counter < R::MINI_ATTS_NUM - 1) {
			*items[counter++] = Util::rmD(zr.NextToken());
		}
		Util::formatDate(geburtstag, &geburtstag);
		std::vector<Dienst*> dienste; //dummy
		tmp_list.push_back(Messdiener(name, vorname, dienste, geburtstag, strasse, ort, tel, mobile, email, bem));
	}
	notifyMinis();
	file.Close();
}

void MiniImportDialog::onBtDel(wxCommandEvent&) {
	int i = -1;
	bool didErase = false;
	int counter = 0;
	for (;;) {
		i = lc_minis->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		tmp_list.erase(tmp_list.begin() + (i - counter++));
		didErase = true;
	}
	if (didErase) notifyMinis();
}

void MiniImportDialog::onBtOk(wxCommandEvent&) {
	*edt = true;
	for (std::vector<Messdiener>::iterator iter_m = tmp_list.begin(); iter_m != tmp_list.end(); iter_m++) {
		list_mini->push_back(new Messdiener(*iter_m));
	}
	Close(true);
}

void MiniImportDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}


===== ./src/import/EinzelterminImportDialog.h =====
/* 
 * File:   EinzelterminImportDialog.h
 * Author: Yannik
 *
 * Created on August 29, 2016, 9:42 PM
 */

#ifndef EINZELTERMINIMPORTDIALOG_H
#define	EINZELTERMINIMPORTDIALOG_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include <wx/spinctrl.h>
#include <vector>
#include "../model-data/Einzeltermin.h"

class EinzelterminImportDialog : public wxDialog {
public:
	EinzelterminImportDialog(wxWindow* parent, std::vector<Einzeltermin*>* _list_einzel, bool* _edt, std::vector<Dienst*>* _list_dienst);
private:
	std::vector<Einzeltermin*>* list_einzel;
	bool* edt;
	std::vector<Dienst*>* list_dienst;

	std::vector<Einzeltermin> tmp_list;

	wxButton* bt_file;
	wxRadioButton* rb_semicolon;
	wxRadioButton* rb_comma;
	wxRadioButton* rb_tab;
	wxRadioButton* rb_space;
	wxRadioButton* rb_other;
	wxTextCtrl* tc_sep;
	wxChoice* ch_dienst;
	wxSpinCtrl* sp_anzahl;
	wxListCtrl* lc_termine;
	wxButton* bt_del;
	wxButton* bt_ok;
	wxButton* bt_cancel;

	void notifyTermine();
	DECLARE_EVENT_TABLE();
	void onBtFile(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtOk(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};

#endif	/* EINZELTERMINIMPORTDIALOG_H */



===== ./src/import/MiniImportDialog.h =====
/* 
 * File:   MiniImportDialog.h
 * Author: Yannik
 *
 * Created on October 8, 2015, 6:28 PM
 */

#ifndef MINIIMPORTDIALOG_H
#define	MINIIMPORTDIALOG_H

#include <wx/wx.h>
#include <wx/listctrl.h>
#include <vector>
#include "../model-data/Messdiener.h"

class MiniImportDialog : public wxDialog {
public:
	MiniImportDialog(wxWindow* parent, std::vector<Messdiener*>* _list_mini, bool* _edt);
private:
	std::vector<Messdiener*>* list_mini;
	bool* edt;

	std::vector<Messdiener> tmp_list;

	wxButton* bt_file;
	wxRadioButton* rb_semicolon;
	wxRadioButton* rb_comma;
	wxRadioButton* rb_tab;
	wxRadioButton* rb_space;
	wxRadioButton* rb_other;
	wxTextCtrl* tc_sep;
	wxListCtrl* lc_minis;
	wxButton* bt_del;
	wxButton* bt_ok;
	wxButton* bt_cancel;

	void notifyMinis();
	DECLARE_EVENT_TABLE();
	void onBtFile(wxCommandEvent&);
	void onBtDel(wxCommandEvent&);
	void onBtOk(wxCommandEvent&);
	void onBtCancel(wxCommandEvent&);
};

#endif	/* MINIIMPORTDIALOG_H */



===== ./src/import/EinzelterminImportDialog.cpp =====
/* 
 * File:   EinzelterminImportDialog.cpp
 * Author: Yannik
 * 
 * Created on August 29, 2016, 9:42 PM
 */

#include "EinzelterminImportDialog.h"
#include <wx/filedlg.h>
#include <wx/textfile.h>
#include <wx/tokenzr.h>
#include "../Util.h"
#include "../R.h"

EinzelterminImportDialog::EinzelterminImportDialog(wxWindow* parent, std::vector<Einzeltermin*>* _list_einzel, bool* _edt, std::vector<Dienst*>* _list_dienst)
: wxDialog(parent, R::ID_ANY, R::EINZELTERMIN_IMPORT_DIALOG, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER),
list_einzel(_list_einzel), edt(_edt), list_dienst(_list_dienst) {
	wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

	wxStaticText* st_head = new wxStaticText(this, R::ID_ANY, R::MINI_CSV_MSG);
	sizer->Add(st_head, 0, wxEXPAND | wxLEFT | wxTOP | wxRIGHT, 5);
	const wxString SEP = wxT(";");
	wxStaticText* st_cells = new wxStaticText(this, R::ID_ANY, R::NAME + SEP + R::ORT + SEP + R::DATUM
			+ SEP + R::ZEIT + SEP + R::ANZAHL + SEP + R::BEM);
	st_cells->SetFont(st_cells->GetFont().Bold());
	sizer->Add(st_cells, 0, wxEXPAND | wxLEFT | wxRIGHT | wxBOTTOM, 5);

	sizer->AddSpacer(5);
	wxBoxSizer* sizer_sep = new wxBoxSizer(wxHORIZONTAL);
	wxStaticText* st_sep = new wxStaticText(this, R::ID_ANY, R::SEPARATOR + wxT(": "));
	sizer_sep->Add(st_sep, 0, wxALIGN_CENTER_VERTICAL | wxALL, 0);
	rb_semicolon = new wxRadioButton(this, R::ID_ANY, R::SEMIKOLON, wxDefaultPosition, wxDefaultSize, wxRB_GROUP);
	sizer_sep->Add(rb_semicolon, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_comma = new wxRadioButton(this, R::ID_ANY, R::KOMMA);
	sizer_sep->Add(rb_comma, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_tab = new wxRadioButton(this, R::ID_ANY, wxT("Tab"));
	sizer_sep->Add(rb_tab, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_space = new wxRadioButton(this, R::ID_ANY, R::LEERZEICHEN);
	sizer_sep->Add(rb_space, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_other = new wxRadioButton(this, R::ID_ANY, R::ANDERES);
	sizer_sep->Add(rb_other, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	tc_sep = new wxTextCtrl(this, R::ID_ANY, wxT(""));
	sizer_sep->Add(tc_sep, 0, wxALIGN_CENTER_VERTICAL | wxALL, 2);
	rb_semicolon->SetValue(true);
	sizer->Add(sizer_sep, 0, wxEXPAND | wxALL, 5);

	sizer->AddSpacer(5);
	wxFlexGridSizer* sizer_dienst = new wxFlexGridSizer(2, 2, 0, 0);
	int num = list_dienst->size();
	wxString dienste_s[num];
	for (int i = 0; i < num; i++) {
		dienste_s[i] = list_dienst->at(i)->name;
	}
	wxStaticText* st_dienst = new wxStaticText(this, R::ID_ANY, wxT("Std.-") + R::DIENST);
	sizer_dienst->Add(st_dienst, 0, wxALIGN_CENTER_VERTICAL | wxALL, 0);
	ch_dienst = new wxChoice(this, R::ID_ANY, wxDefaultPosition, wxDefaultSize, num, dienste_s);
	ch_dienst->SetLabel(R::DIENST);
	ch_dienst->SetSelection(0); //seems to work with empty lists
	sizer_dienst->Add(ch_dienst, 0, wxEXPAND | wxALL, 2);
	wxStaticText* st_anzahl = new wxStaticText(this, R::ID_ANY, wxT("Std.-") + R::ANZAHL);
	sizer_dienst->Add(st_anzahl, 0, wxALIGN_CENTER_VERTICAL | wxALL, 0);
	sp_anzahl = new wxSpinCtrl(this, R::ID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 0, 1000000000, 1);
	sizer_dienst->Add(sp_anzahl, 0, wxEXPAND | wxALL, 2);
	sizer->Add(sizer_dienst, 0, wxALL, 5);

	sizer->AddSpacer(5);
	bt_file = new wxButton(this, R::ID_BT_COMPUTE, R::CSV_DATEI_WAEHLEN);
	sizer->Add(bt_file, 0, wxALL, 5);

	sizer->AddSpacer(5);
	wxStaticText* st_preview = new wxStaticText(this, R::ID_ANY, R::VORSCHAU + wxT(": "));
	sizer->Add(st_preview, 0, wxEXPAND | wxTOP | wxLEFT | wxRIGHT, 5);
	wxBoxSizer* sizer_preview = new wxBoxSizer(wxHORIZONTAL);
	lc_termine = new wxListView(this, R::ID_LC, wxDefaultPosition, wxDefaultSize,
			wxLC_REPORT);
	wxListItem lc_termine_cols[R::TEINZEL_NUM];
	for (int i = 0; i < R::TEINZEL_NUM; i++) {
		lc_termine_cols[i].SetText(R::TEINZEL_ATTS[i]);
		lc_termine->InsertColumn(i, lc_termine_cols[i]);
	}
	for (int i = 0; i < R::TEINZEL_NUM; i++) {
		lc_termine->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
	sizer_preview->Add(lc_termine, 1, wxEXPAND);
	bt_del = new wxButton(this, R::ID_BT_DEL, R::DEL);
	sizer_preview->Add(bt_del, 0, 0);
	sizer->Add(sizer_preview, 1, wxEXPAND | wxALL, 5);

	wxStaticText* st_import_msg = new wxStaticText(this, R::ID_ANY, R::EINZELTERMIN_IMPORT_MSG);
	sizer->Add(st_import_msg, 0, wxEXPAND | wxALL, 5);

	wxBoxSizer* btsizer = new wxBoxSizer(wxHORIZONTAL);
	wxPanel* pl_nn = new wxPanel(this);
	pl_nn->SetSize(30, -1);
	btsizer->Add(pl_nn, 1, wxEXPAND);
	bt_ok = new wxButton(this, R::ID_BT_OK, R::IMPORTIEREN);
	btsizer->Add(bt_ok);
	bt_cancel = new wxButton(this, R::ID_BT_CANCEL, R::CANCEL);
	btsizer->Add(bt_cancel);
	sizer->Add(btsizer, 0, wxALL | wxEXPAND, 5);

	SetSizerAndFit(sizer);
}

void EinzelterminImportDialog::notifyTermine() {
	lc_termine->DeleteAllItems();
	int num_termine = tmp_list.size();
	for (int i = 0; i < num_termine; i++) {
		Einzeltermin* t = &tmp_list.at(i);
		wxListItem item;
		item.SetId(i);
		lc_termine->InsertItem(item);
		lc_termine->SetItem(i, 0, t->name);
		lc_termine->SetItem(i, 1, t->ort);
		lc_termine->SetItem(i, 2, t->datum + wxT(" (") + R::WOCHENTAGE[Util::wxString_to_wxDateTime(t->datum).GetWeekDay()] + wxT(")"));
		lc_termine->SetItem(i, 3, t->zeit_beginn);
		lc_termine->SetItem(i, 4, Einzeltermin::printDienste(t));
		lc_termine->SetItem(i, 5, t->bem);
	}
	for (int i = 0; i < R::TEINZEL_NUM; i++) {
		lc_termine->SetColumnWidth(i, wxLIST_AUTOSIZE_USEHEADER);
	}
}

BEGIN_EVENT_TABLE(EinzelterminImportDialog, wxDialog)
EVT_BUTTON(R::ID_BT_COMPUTE, EinzelterminImportDialog::onBtFile)
EVT_BUTTON(R::ID_BT_DEL, EinzelterminImportDialog::onBtDel)
EVT_BUTTON(R::ID_BT_OK, EinzelterminImportDialog::onBtOk)
EVT_BUTTON(R::ID_BT_CANCEL, EinzelterminImportDialog::onBtCancel)
END_EVENT_TABLE()


void EinzelterminImportDialog::onBtFile(wxCommandEvent&) {
	//delete old
	tmp_list.clear();

	wxFileDialog openFileDialog(this, R::CSV_DATEI_WAEHLEN, wxT(""), wxT(""), wxT("CSV-Dateien (*.csv)|*.csv|Alle (*.*)|*.*"), wxFD_OPEN | wxFD_FILE_MUST_EXIST);
	if (openFileDialog.ShowModal() == wxID_CANCEL) return;
	wxTextFile file(openFileDialog.GetPath());
	if (!file.Exists()) {
		wxMessageDialog dialog(this, R::MSG_FILE_NOT_FOUND, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
		dialog.ShowModal();
		return;
	}
	file.Open();
	//delimiter
	wxString D;
	if (rb_semicolon->GetValue()) D = wxT(";");
	else if (rb_comma->GetValue()) D = wxT(",");
	else if (rb_tab->GetValue()) D = wxT("\t");
	else if (rb_space->GetValue()) D = wxT(" ");
	else {
		D = tc_sep->GetValue().Mid(0, 1);
		tc_sep->SetValue(D);
	}
	//std dienst
	Dienst* dienst = list_dienst->at(ch_dienst->GetSelection());
	int std_anzahl = sp_anzahl->GetValue();
	//iterate
	int counter_termin = 0;
	wxString failedLines = wxT("");
	wxString lastDate = wxT(""); //sometimes not mentioned if same as previous one
	for (wxString line = file.GetFirstLine(); !file.Eof(); line = file.GetNextLine()) {
		counter_termin++;
		wxStringTokenizer zr(line, D, wxTOKEN_RET_EMPTY_ALL);
		wxString name = wxT(""), ort = wxT(""), datum_s = wxT(""), zeit_s = wxT(""), anzahl_s = wxT(""), bem = wxT("");
		wxString * items[6] = {&name, &ort, &datum_s, &zeit_s, &anzahl_s, &bem};
		int counter = 0;
		while (zr.HasMoreTokens() && counter < 6) {
			*items[counter++] = Util::rmD(zr.NextToken());
		}
		//retrieve date
		wxString datum = wxT("");
		if (datum_s.IsSameAs(wxT("")) && !lastDate.IsSameAs(wxT(""))) datum = lastDate;
		else if (!Util::formatDate(datum_s, &datum)) {
			wxStringTokenizer zr(datum_s, wxT(" "));
			wxString d2 = zr.NextToken();
			while (zr.HasMoreTokens()) d2 = zr.GetNextToken();
			//form ANYTHING dd.mm.yyyy
			if (!Util::formatDate(d2, &datum)) {
				wxStringTokenizer zr(d2, wxT("."));
				if (zr.CountTokens() == 2) {
					long day, month_i;
					bool day_b = zr.NextToken().ToLong(&day, 10);
					bool month_b = zr.NextToken().ToLong(&month_i, 10);
					if (day_b && month_b && day >= 1 && month_i >= 1 && day <= 31 && month_i <= 12) {
						wxDateTime::Month month = wxDateTime::Month(month_i - 1);
						wxDateTime today = wxDateTime::Today();
						int year = today.GetYear();
						if (month < today.GetMonth() || (month <= today.GetMonth() && day < today.GetDay())) year++;
						if (day <= wxDateTime::GetNumberOfDays(month, year)) {
							wxDateTime date(day, month, year);
							if (date.IsValid()) {
								datum = Util::wxDateTime_to_wxString(date);
								lastDate = datum;
							}
						}
					}
				}
			}
		}
		if (datum.IsSameAs(wxT(""))) failedLines += wxString::Format(wxT("%i (") + R::DATUM + wxT(")"), counter_termin) + wxT("\n");
		else {
			wxString zeit;
			if (!Util::formatTime(zeit_s, &zeit)) failedLines += wxString::Format(wxT("%i (") + R::ZEIT + wxT(")"), counter_termin) + wxT("\n");
			else {
				long anzahl;
				if (anzahl_s.IsSameAs(wxT("-"))) anzahl = 0;
				else if (!anzahl_s.ToLong(&anzahl, 10)) anzahl = std_anzahl;
				std::vector<std::pair<Dienst*, int> > dienste;
				if (anzahl != 0) {
					dienste.push_back(std::make_pair(dienst, anzahl));
				}
				tmp_list.push_back(Einzeltermin(name, ort, datum, zeit, dienste, bem));
			}
		}
	}
	//evtl. fehlerhafte Zeilen
	if (failedLines.length() > 0) {
		wxMessageDialog dialog(this, R::MSG_RETRIEVE_NOT_POSSIBLE + wxT("\n") + failedLines, wxMessageBoxCaptionStr, wxOK | wxCENTRE);
		dialog.ShowModal();
	}
	notifyTermine();
	file.Close();
}

void EinzelterminImportDialog::onBtDel(wxCommandEvent&) {
	int i = -1;
	bool didErase = false;
	int counter = 0;
	for (;;) {
		i = lc_termine->GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (i == -1) {
			break;
		}
		tmp_list.erase(tmp_list.begin() + (i - counter++));
		didErase = true;
	}
	if (didErase) notifyTermine();
}

void EinzelterminImportDialog::onBtOk(wxCommandEvent&) {
	*edt = true;
	for (std::vector<Einzeltermin>::iterator iter_t = tmp_list.begin(); iter_t != tmp_list.end(); iter_t++) {
		list_einzel->push_back(new Einzeltermin(*iter_t));
	}
	Close(true);
}

void EinzelterminImportDialog::onBtCancel(wxCommandEvent&) {
	Close(true);
}

